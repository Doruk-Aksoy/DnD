#library "DND_SHRD"
#include "zcommon.h"

#include "DnD_Shared.h"

enum { //Shortened version of enum found at DnD_Stat.h
	DND_ARMOR_BONUS,
	DND_ARMOR_GREEN,
	DND_ARMOR_YELLOW,
	DND_ARMOR_BLUE,
	DND_ARMOR_RED
};

Script "DND Shared Item Check" (int type) {
	int pid = ActivatorTID();
	// find which item is in bounds
	//printbold(s:"DND Shared Item Check, type:", d:type);
	for(int closest = 0; closest < shared_type_items_counter[type]; ++closest) {
		// check if this item was picked up
		// prevent multiple pickup calls from being handled for the same player while this is being processed
		//printbold(s:"closest ID: ", d:closest, s:", Pickup state before ", d:Shared_Item_pickup_state[type][closest][pid - P_TIDSTART]);
		if (!(Shared_Item_pickup_state[type][closest][pid - P_TIDSTART]) &&
			(player_pickup_cubes_intersect(pid, SHARED_ITEM_TID_BEGIN + type*SHARED_ITEM_TYPE_TIDS_MAX + closest)))
		{
			Shared_Item_pickup_state[type][closest][pid - P_TIDSTART] = 1; //Make sure multiples running here will skip to others more reliably
			//printbold(s:"Can pick ", d:closest);
			bool pickedup = false;
			//Now run the scripts based on item type picked
			switch(type) {
				case SHI_REDARMOR:
					if(ACS_NamedExecuteWithResult("DND Armor Pickup Check", 300, DND_ARMOR_RED)) {
						pickedup = true;
						ACS_NamedExecuteAlways("DND Shared Item Pickup", 0, SHI_REDARMOR);
						ACS_NamedExecuteAlways("DND Armor Give", 0, DND_ARMOR_RED, 300);
						GiveInventory("RedArmorMsg", 1);
					}
					break;
				case SHI_BLUEARMOR:
					if(ACS_NamedExecuteWithResult("DND Armor Pickup Check", 200, DND_ARMOR_BLUE)) {
						pickedup = true;
						ACS_NamedExecuteAlways("DND Shared Item Pickup", 0, SHI_BLUEARMOR);
						ACS_NamedExecuteAlways("DND Armor Give", 0, DND_ARMOR_BLUE, 200);
						GiveInventory("BlueArmorMsg", 1);
					}
					break;
				case SHI_YELLOWARMOR:
					if(ACS_NamedExecuteWithResult("DND Armor Pickup Check", 150, DND_ARMOR_YELLOW)) {
						pickedup = true;
						ACS_NamedExecuteAlways("DND Shared Item Pickup", 0, SHI_YELLOWARMOR);
						ACS_NamedExecuteAlways("DND Armor Give", 0, DND_ARMOR_YELLOW, 150);
						GiveInventory("YellowArmorMsg", 1);
					}
					break;
				case SHI_GREENARMOR:
					if(ACS_NamedExecuteWithResult("DND Armor Pickup Check", 100, DND_ARMOR_GREEN)) {
						pickedup = true;
						ACS_NamedExecuteAlways("DND Shared Item Pickup", 0, SHI_GREENARMOR);
						ACS_NamedExecuteAlways("DND Armor Give", 0, DND_ARMOR_GREEN, 100);
						GiveInventory("GreenArmorMsg", 1);
					}
					break;
				case SHI_BACKPACK:
					pickedup = true;
					GiveInventory("BackpackPickMSG", 1);
					GiveInventory("NewBackpack", 1);
					break;
				case SHI_STIMPACK:
					if(!CheckInventory("TaltosUp") && ACS_ExecuteWithResult(819, 0)) {
						pickedup = true;
						GiveInventory("StimpackMsg", 1);
						ACS_NamedExecuteAlways("DnD Health Pickup", 0, 10);
					}
					break;
				case SHI_MEDKIT:
					if(!CheckInventory("TaltosUp") && ACS_ExecuteWithResult(819, 0)) {
						pickedup = true;
						GiveInventory("MedikitMsg", 1);
						ACS_NamedExecuteAlways("DnD Health Pickup", 0, 25);
					}
					break;
			}
			if(pickedup) {
				ACS_ExecuteAlways(801, 0, SHARED_ITEM_TID_BEGIN + type*SHARED_ITEM_TYPE_TIDS_MAX + closest);
				//printbold(s:"Picked ", d:closest, s: " ", d:Shared_Item_pickup_state[type][closest][pid - P_TIDSTART]);
			} else
				Shared_Item_pickup_state[type][closest][pid - P_TIDSTART] = 0; //Make sure the item is available for pickup again.
			break;
		}
	}
}

Script "DND Shared Item Init" (int type) {
	if(GameType() != GAME_SINGLE_PLAYER) {
		//printbold(s:"I am ", d:SHARED_ITEM_TID_BEGIN + type*SHARED_ITEM_TYPE_TIDS_MAX + shared_type_items_counter[type]);
		if (shared_type_items_counter[type] < SHARED_ITEM_TYPE_TIDS_MAX) //If it goes over limits, just ignore its existance.
			Thing_ChangeTID(0, SHARED_ITEM_TID_BEGIN + type*SHARED_ITEM_TYPE_TIDS_MAX + shared_type_items_counter[type]++);
	}
	else {
		Spawn(SP_SharedItems[type], GetActorX(0), GetActorY(0), GetActorZ(0), 0);
		Thing_Remove(0);
	}
}

Script 800 ENTER CLIENTSIDE {
	while(1) {
		if(PlayerNumber() == ConsolePlayerNumber()) {
			for(int i = 0; i < shared_item_queue_count; ++i) {
				SetActorProperty(shared_item_clientside_queue[i], APROP_ALPHA, 0.25);
				SetActorState(shared_item_clientside_queue[i], "IdlePicked", 0);
			}
			shared_item_queue_count = 0;
		}
		Delay(5);
	}
}

Script 801(int tid) CLIENTSIDE {
	if(PlayerNumber() == ConsolePlayerNumber())
		shared_item_clientside_queue[shared_item_queue_count++] = tid;
}

Script "DND Limited Respawn Item Init" (void) {
	if(!GetCVar("dnd_enable_limiteditems") || GameType() == GAME_SINGLE_PLAYER)
		Terminate;
	if(!ActivatorTID()) {
		Thing_ChangeTID(0, LIMITED_RESPAWN_TID_BEGIN + limitedrespawn_item_counter);
		LimitedItem_Respawns[limitedrespawn_item_counter++] = GetCVar("dnd_limitedrespawn_amount");
	}
	else {
		if(!LimitedItem_Respawns[ActivatorTID() - LIMITED_RESPAWN_TID_BEGIN])
			Thing_Remove(ActivatorTID());
		else
			LimitedItem_Respawns[ActivatorTID() - LIMITED_RESPAWN_TID_BEGIN]--;
	}
}