#library "DND"
#include "zcommon.h"
#nocompact

#include "DnD_MonsterData.h"
#include "DnD_Shared.h"
#include "DnD_Orbs.h"
#include "DnD.h"
#include "DnD_Prompts.h"

// this is here for convenience, tracks if a legendary monster was spawned
bool MadeLegendary = 0;

Script "DnD SBAR" (void) CLIENTSIDE {
	int item, itemcomp;
	str ammo, ammoalt;
	int wepid;
	while(IsAlive()) {
		if(!CheckInventory("ShowingMenu")) {
			if(GetCVar("dnd_killspree"))
				GiveInventory("KillSpreeOn", 1);
			itemcomp = GetSpawnHealth();
			item = GetActorProperty(0, APROP_HEALTH);
			SetInventory("P_HealthCap", itemcomp);
			if(item > itemcomp) {
				SetInventory("HPOverAmount", item - itemcomp);
				GiveInventory("HPOver100", 1);
				TakeInventory("HPNormal", 1);
				TakeInventory("HPBelow50", 1);
				TakeInventory("HPBelow25", 1);
			}
			else if(item > (itemcomp >> 1) - 1) {
				SetInventory("HPOverAmount", 0);
				TakeInventory("HPOver100", 1);
				GiveInventory("HPNormal", 1);
				TakeInventory("HPBelow50", 1);
				TakeInventory("HPBelow25", 1);
			}
			else if(item > (itemcomp >> 2) - 1) {
				SetInventory("HPOverAmount", 0);
				TakeInventory("HPOver100", 1);
				TakeInventory("HPNormal", 1);
				GiveInventory("HPBelow50", 1);
				TakeInventory("HPBelow25", 1);
			}
			else {
				SetInventory("HPOverAmount", 0);
				TakeInventory("HPOver100", 1);
				TakeInventory("HPNormal", 1);
				TakeInventory("HPBelow50", 1);
				GiveInventory("HPBelow25", 1);
			}
			
			item = GetArmorAmount();
			itemcomp = GetArmorCapFromID(GetArmorID());
			if(item > itemcomp) { // can happen with armor bonuses
				SetInventory("ARMOverAmount", item - itemcomp);
				GiveInventory("ARMOver100", 1);
				TakeInventory("ARMNormal", 1);
				TakeInventory("ARMBelow50", 1);
				TakeInventory("ARMBelow25", 1);
			}
			else if(item >= itemcomp >> 1) {
				SetInventory("ARMOverAmount", 0);
				TakeInventory("ARMOver100", 1);
				GiveInventory("ARMNormal", 1);
				TakeInventory("ARMBelow50", 1);
				TakeInventory("ARMBelow25", 1);
			}
			else if(item >= itemcomp >> 2) {
				SetInventory("ARMOverAmount", 0);
				TakeInventory("ARMOver100", 1);
				TakeInventory("ARMNormal", 1);
				GiveInventory("ARMBelow50", 1);
				TakeInventory("ARMBelow25", 1);
			}
			else {
				SetInventory("ARMOverAmount", 0);
				TakeInventory("ARMOver100", 1);
				TakeInventory("ARMNormal", 1);
				TakeInventory("ARMBelow50", 1);
				GiveInventory("ARMBelow25", 1);
			}
				
			if(((Timer() * 98) / (100 * TICRATE)) < GetLevelInfo(LEVELINFO_PAR_TIME))
				GiveInventory("H_UnderPar", 1);
			else
				TakeInventory("H_UnderPar", 1);

			if(GetLevelInfo(LEVELINFO_KILLED_MONSTERS) == GetLevelInfo(LEVELINFO_TOTAL_MONSTERS))
				GiveInventory("H_KillsAchieved", 1);
			else
				TakeInventory("H_KillsAchieved", 1);

			if(GetLevelInfo(LEVELINFO_FOUND_ITEMS) == GetLevelInfo(LEVELINFO_TOTAL_ITEMS))
				GiveInventory("H_ItemsAchieved", 1);
			else
				TakeInventory("H_ItemsAchieved", 1);

			if(GetLevelInfo(LEVELINFO_FOUND_SECRETS) == GetLevelInfo(LEVELINFO_TOTAL_SECRETS))
				GiveInventory("H_SecretsAchieved", 1);
			else
				TakeInventory("H_SecretsAchieved", 1);
				
			if(GetCVar("sv_infiniteammo"))
				GiveInventory("H_InfiniteAmmo", 1);
			else
				TakeInventory("H_InfiniteAmmo", 1);
			
			// primary ammo
			wepid = CheckInventory("DnD_WeaponID");
			ammo = GetWeaponAmmoType(wepid, 0);
			if(StrCmp(" ", ammo)) { // if uses ammo
				itemcomp = GetAmmoCapacity(ammo);
				item = CheckInventory(ammo);
				if(item > (itemcomp + 1) / 2) {
					GiveInventory("H_PrimaryGreen", 1);
					TakeInventory("H_PrimaryYellow", 1);
					TakeInventory("H_PrimaryRed", 1);
				}
				else if(item > Max(itemcomp / 4, 1)) {
					TakeInventory("H_PrimaryGreen", 1);
					GiveInventory("H_PrimaryYellow", 1);
					TakeInventory("H_PrimaryRed", 1);	
				}
				else {
					TakeInventory("H_PrimaryGreen", 1);
					TakeInventory("H_PrimaryYellow", 1);
					GiveInventory("H_PrimaryRed", 1);		
				}
			}
			
			// secondary ammo
			ammoalt = GetWeaponAmmoType(wepid, 1);
			if(StrCmp(" ", ammoalt) && ammo != ammoalt) { // if uses altammo and is not same as normal ammo
				itemcomp = GetAmmoCapacity(ammoalt);
				item = CheckInventory(ammoalt);
				if(item > (itemcomp + 1) / 2) {
					GiveInventory("H_SecondaryGreen", 1);
					TakeInventory("H_SecondaryYellow", 1);
					TakeInventory("H_SecondaryRed", 1);
				}
				else if(item > Max(itemcomp / 4, 1)) {
					TakeInventory("H_SecondaryGreen", 1);
					GiveInventory("H_SecondaryYellow", 1);
					TakeInventory("H_SecondaryRed", 1);	
				}
				else {
					TakeInventory("H_SecondaryGreen", 1);
					TakeInventory("H_SecondaryYellow", 1);
					GiveInventory("H_SecondaryRed", 1);		
				}
			}
		}
		Delay(const:5);
	}
}

Script "DnD Clientside Open" OPEN CLIENTSIDE {
	bool buttons = false;
	bool wepdrop = false;
	
	SetUserCVar(ConsolePlayerNumber(), "dnd_onclassmenu", false);
	
	while(true) {
		if(GameType() != GAME_SINGLE_PLAYER) {
			if(!GetCVar("compat_clientssendfullbuttoninfo"))
				Log(l:"DND_WARN_COMPATBUTTONS");
			else
				buttons = true;
			if(GetCVar("sv_weapondrop"))
				Log(l:"DND_WARN_WEAPONDROP");
			else
				wepdrop = true;
				
			if(wepdrop && buttons)
				break;
		}
		else
			break;
		Delay(const:TICRATE);
	}
}

Script "DnD On Map Load" OPEN {
	// empty translation
	CreateTranslation(DND_NO_TRANSLATION);
	CreateTranslation(DND_CRIT_TRANSLATION, 160:160=175:175);
	
	// init vars
	ResetSharedVariables();

	while(GetGameModeState() != GAMESTATE_INPROGRESS)
		Delay(const:TICRATE);
		
	CalculateMapDifficulty();
	UpdateLevelChestLimit();

	// wait while total level is not initialized
	while(!PlayerInformationInLevel[PLAYERLEVELINFO_LEVEL])
		Delay(const:TICRATE);

	Delay(const:TICRATE);
	if (GetLevelInfo(LEVELINFO_LEVELNUM) != 99) //Prevents quests from firing on VR map (Lexicon) - compendium hubmap can't be detected this way unfortunately.
		PickQuest();

	// commented out for now!
	//NPC_Setup();
}

Script "DND Check Hardcore Softcore" OPEN {
	while(true) {
		if((GetCVar("dnd_mode") >= DND_MODE_SOFTCORE) && (GameType() != GAME_SINGLE_PLAYER))
			HardcoreSet = CheckHardcoreSettings();
		Delay(const:105);
	}
}

// Basically shut the menu down
Script "DnD On Death" DEATH {
	int i, pnum = PlayerNumber();
	PlayerDied[pnum] += 1;
	// put this at the beginning to prevent the rare last second lvl 1 char auto-load bug.
	if(GetCVar("Survival")) {
		if(!CheckInventory("CurrentLives")) {
			PlayerLoaded[pnum] = 0;
			PlayerWillBeSaved[pnum] = false;
			PlayerTransferred[pnum] = false;
			PlayerCanLoad[pnum] = 0;
		}
	}
	
	UnmarkPlayerAsExited(pnum);
	GiveInventory("DnD_PDead", 1);
	SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
	TakeInventory("P_Frozen", 1);
	StatListOpened[pnum] = 0;
	SetInventory("ShowingMenu", 0);
	SetInventory("MenuOption", 5);
	SetInventory("MenuPosX", 0);
	SetInventory("MadeChoice", 0);
	SetInventory("DnD_PopupId", 0);
	SetInventory("Punisher_Perk50_Counter", 0); // reset earned bonuses on death
	
	TakeInventory("DnD_ShowPopup", 1);
	TakeInventory("DnD_ShowSellPopup", 1);
	TakeInventory("DnD_SellConfirm", 1);
	//SetInventory("MenuPosY", 5);
	ACS_NamedExecuteAlways("DND Menu Cleanup", 0, pnum);
	BreakTradesBetween(pnum);

	if(GetCVar("Survival")) {
		if(CheckInventory("CurrentLives"))
			TakeInventory("CurrentLives", 1);
		else {
			// if player was in middle of saving, don't accidently interfere if player leaves early
			// save accumulated stats when player leaves
			// things saved are in DnD_Activity.h

			if(GetCVar("dnd_mode") == DND_MODE_HARDCORE) {
				ACS_NamedExecuteAlways("DND Database Reset On Death", 0, pnum);
				ResetPlayerActivities(pnum, false);
			}
			else if(GetCVar("dnd_mode") == DND_MODE_SOFTCORE)
				ACS_NamedExecuteWithResult("DnD Save Player Activities", pnum, false);
			else {
				// get rid of these in local server or w.e situations if not hardcore or softcore
				// remove whatever feature this player had on them prior to loading (just in case)
				for(i = 0; i < MAX_CHARMS_EQUIPPABLE; ++i)
					if(Charms_Used[pnum][i].item_type != DND_ITEM_NULL)
						RemoveItemFeatures(pnum, i, DND_SYNC_ITEMSOURCE_CHARMUSED);
						
				ResetHardcoreStuff(pnum);
			}
		}
	}
	
	// Precious Life check
	if(active_quest_id == QUEST_NODYING) {
		// fail for all players in the game
		for(i = 0; i < MAXPLAYERS; ++i)
			if(PlayerInGame(i) && isActorAlive(i + P_TIDSTART))
				FailQuest(i + P_TIDSTART);
		active_quest_id = -1; // completely remove this quest from everyone now
	}
	
	ACS_NamedExecuteAlways("DnD Punisher Perk50 Display", 0, true);
	Thing_ChangeTID(0, 0);
}

Script "DnD Portable Kit Script" (void) {
	int healthcap = GetSpawnHealth();
	int bonus = GetHealingBonuses();
	int amt = healthcap / 100;
	amt = amt * (100 + bonus) / 100;
	while(GetActorProperty(0, APROP_HEALTH) < healthcap && CheckInventory("StoredMedkit")) {
		TakeInventory("StoredMedkit", 1);
		GiveInventory("HealthBonusX", amt);
		GiveInventory("DnD_MasterHealerQuest_HealAmount", amt);
	}
}

// Health Kits Script (Used by Portable Medikits as well, ported here)
Script "DnD Health Pickup" (int amt, int isspecial, int useTarget) {
	if(useTarget)
		SetActivatorToTarget(0);
	int curhp = GetActorProperty(0, APROP_HEALTH);
	int healthcap = GetSpawnHealth();
	int bonus = GetHealingBonuses();
	// holds the old amt
	int toGive = amt, base = amt;
	// the percentage of spawn health is amt to be given
	amt = healthcap * amt / 100;
	// consider healing bonuses from quests
	amt = amt * (100 + bonus) / 100;
	
	// health bonus
	if(isspecial == 5) {
		GiveInventory("HealthBonusX", amt);
		GiveInventory("DnD_MasterHealerQuest_HealAmount", amt);
		GiveInventory("Research_Body_Hp_1_Tracker", amt);
		if(HasMasteredPerk(STAT_MED) && amt / 10)
			HandleArmorPickup(DND_ARMOR_BONUS, amt / 10, false);
		Terminate;
	}
	else if(isspecial == 3) {
		// map toast heal
		amt = healthcap - curhp;
	    GiveInventory("HealthBonusX", amt);
		GiveInventory("DnD_MasterHealerQuest_HealAmount", amt);
		GiveInventory("Research_Body_Hp_1_Tracker", amt);
	    Terminate;
	}
	else if(isspecial == 2) { // ubersphere / megasphere
		toGive /= 100; // get the multiplier for mega / uber
		toGive = healthcap * toGive - curhp;
	}
	else if(isspecial == 1)
		toGive = amt + healthcap - curhp;
	else // for anything else (stims, medkits etc)
	    toGive = healthcap - curhp;
	
	if(toGive > amt)
		toGive = amt;
	
	if(CheckResearchStatus(RES_MEDKITSTORE) == RES_DONE && !isspecial) {
		if(curhp < healthcap) { // if my current curhp is less than max
			GiveInventory("HealthBonusX", toGive);
			GiveInventory("DnD_MasterHealerQuest_HealAmount", toGive);
			GiveInventory("Research_Body_Hp_1_Tracker", toGive);
			
			if(HasMasteredPerk(STAT_MED) && toGive / 10)
				HandleArmorPickup(DND_ARMOR_BONUS, toGive / 10, false);
		}
        if(toGive < amt)
            GiveInventory("StoredMedkit", Clamp_Between(amt - toGive, 1, base));
	}
	else {
		GiveInventory("HealthBonusX", toGive);
		GiveInventory("DnD_MasterHealerQuest_HealAmount", toGive);
		GiveInventory("Research_Body_Hp_1_Tracker", toGive);
		
		if(HasMasteredPerk(STAT_MED) && toGive / 10)
			HandleArmorPickup(DND_ARMOR_BONUS, toGive / 10, false);
	}
	
	HandleHealDependencyCheck();
}

Script "DnD Can Pick Health Item" (int type) {
	if (CheckInventory("CanLoad"))
		SetResultValue(-1);
	else
		SetResultValue(CanPickHealthItem(type));
}
// Health kits end here

Script "DnD Critical Input Handler" ENTER {
	int pnum = PlayerNumber();
    while(PlayerInGame(pnum)) {
		if(GetPlayerInput(-1, INPUT_BUTTONS) & BT_USE)
			GiveInventory("DnD_PressedUse", 1);
		
        SetInventory("MedkitItem", CheckInventory("StoredMedKit"));
        TakeInventory("FadeIntensity", 1);
		
		// had enough of armor fucking up
		/*if(!GetArmorAmount())
			SetInventory("DnD_ArmorType", 0);*/
		
        Delay(const:1);

		// we can flash again now
		PlayerScriptsCheck[DND_SCRIPT_BLEND][pnum] = true;
    }
}

Script "DnD Weapon Input Handler" (int wepid) {
	bool temp = false;
	int pnum = PlayerNumber();
	switch(wepid) {
		case DND_WEAPON_HELLSMAW:
			while(PlayerInGame(pnum) && CheckInventory("DnD_WeaponID") == wepid) {
				// additional hack for the slayer/hells maw weapon's dynamic fire modes	
				if(!CheckInventory("ShowingMenu")) {
					// shit hacks to prevent some bug...
					if(temp) {
						GiveInventory("HellsMawSynthActive", 1);
						GiveInventory("SynthFireFix", 1);
						temp = false;
					}
					
					if(CheckInventory("HellsMawSynthActive")) {
						if(GetPlayerInput(-1, INPUT_BUTTONS) & BT_ATTACK) 
							GiveInventory("HellsMawSynthFireLeft", 1);
						else 
							TakeInventory("HellsMawSynthFireLeft", 1);
						
						if (GetPlayerInput(-1, INPUT_BUTTONS) & BT_ALTATTACK) 
							GiveInventory("HellsMawSynthFireRight", 1);
						else 
							TakeInventory("HellsMawSynthFireRight", 1);
							
						if(isAlive() && (CheckInventory("HellsMawFiringRight") || CheckInventory("HellsMawFiringLeft")))
							SetActorState(0, "Melee");
					}
				}
				else if(!temp) {
					temp = true;
					TakeInventory("HellsMawSynthActive", 1);
				}
				Delay(const:1);
			}
			TakeInventory("HellsMawSynthFireLeft", 1);
			TakeInventory("HellsMawSynthFireRight", 1);
		break;
		case DND_WEAPON_SLAYER:
			while(PlayerInGame(pnum) && CheckInventory("DnD_WeaponID") == wepid) {
				if(!CheckInventory("ShowingMenu") && (GetPlayerInput(-1, INPUT_BUTTONS) & BT_ALTATTACK) && !CheckInventory("SlayerTimer"))
					GiveInventory("SlayerBack", 1);
				Delay(const:1);
			}
		break;
		case DND_WEAPON_HADES:
			while(PlayerInGame(pnum) && CheckInventory("DnD_WeaponID") == wepid) {
				if(!CheckInventory("ShowingMenu") && (GetPlayerInput(-1, INPUT_BUTTONS) & BT_ALTATTACK) && CheckInventory("HadesBurstFired") && !CheckInventory("HadesBurstTimer")) {
					GiveInventory("MakeHadesBurst", 1);
					GiveInventory("HadesBurstCooldown", 1);
					TakeInventory("HadesBurstFired", 1);
				}
				Delay(const:1);
			}
		break;
		case DND_WEAPON_TORPEDOLAUNCHER:
			while(PlayerInGame(pnum) && CheckInventory("DnD_WeaponID") == wepid) {
				if(!CheckInventory("ShowingMenu") && (GetPlayerInput(-1, INPUT_BUTTONS) & BT_ALTATTACK) && !CheckInventory("TorpedoTimer")) {
					GiveInventory("TorpedoBoomSignal", 1);
					GiveInventory("TorpedoTimer", 1);
					ActivatorSound("Torpedo/Beep", 108);
				}
				Delay(const:1);
			}
		break;
		case DND_WEAPON_VOIDCANNON:
			while(PlayerInGame(pnum) && CheckInventory("DnD_WeaponID") == wepid) {
				if(!CheckInventory("ShowingMenu") && (GetPlayerInput(-1, INPUT_BUTTONS) & BT_ALTATTACK))
					GiveInventory("VoidDetonation", 1);
				Delay(const:1);
			}
		break;
	}
}

// blend scripts, for some reason they seem to be running twice...
Script "DnD Get Pain Alpha" (void) CLIENTSIDE {
	int dmg_received = CheckInventory("DnD_DamageFade");
	if(CheckInventory("SynthMaskToken"))
		dmg_received /= DND_SYNTHMASK_EFFECT;
		
	// max 75% alpha on really hard hits
	// we get the relative weight of this damage compared to our health cap
	int cap = CheckInventory("PlayerHealthCap");
	if(!cap)
		cap = GetSpawnHealth();
	// return min 10% of alpha at any damage regardless, it looks too weak to notice otherwise
	dmg_received = Min(DND_PAINBLEND_MAXALPHA, 10 + dmg_received * 100 / cap);
	
	SetResultValue(dmg_received);
}

Script "DnD Get Pain Tics" (void) CLIENTSIDE {
	int dmg_received = CheckInventory("DnD_DamageFade");
	if(CheckInventory("SynthMaskToken"))
		dmg_received /= DND_SYNTHMASK_EFFECT;
		
	// dont go too overboard with this, cap it
	int cap = CheckInventory("PlayerHealthCap");
	if(!cap)
		cap = GetSpawnHealth();
	
	dmg_received = Clamp_Between(dmg_received * DND_PAINBLEND_MAXTICS / cap, DND_PAINBLEND_MINTICS, DND_PAINBLEND_MAXTICS);

	SetResultValue(dmg_received);
}

// made this clientside as its easier on server for load
Script "DnD Blend Start" (int blend_id) CLIENTSIDE {
	switch(blend_id) {
		case PAINBLEND_RED:
			GiveInventory("PainBlend_Red", 1);
		break;
		case PAINBLEND_GREEN:
			GiveInventory("PainBlend_Green", 1);
		break;
		case PAINBLEND_DARKSLATEGRAY:
			GiveInventory("PainBlend_DarkSlateGray", 1);
		break;
		case PAINBLEND_MIDNIGHTBLUE:
			GiveInventory("PainBlend_MidnightBlue", 1);
		break;		
		case PAINBLEND_DARKSLATEBLUE:
			GiveInventory("PainBlend_DarkSlateBlue", 1);
		break;
		case PAINBLEND_ORANGE:
			GiveInventory("PainBlend_Orange", 1);
		break;
		case PAINBLEND_LIGHTGREEN:
			GiveInventory("PainBlend_LightGreen", 1);
		break;
		case PAINBLEND_DARKGOLDENROD:
			GiveInventory("PainBlend_DarkGoldenRod", 1);
		break;
		case PAINBLEND_LIGHTBLUE:
			GiveInventory("PainBlend_LightBlue", 1);
		break;
		case PAINBLEND_LIGHTSLATEBLUE:
			GiveInventory("PainBlend_LightSlateBlue", 1);
		break;
		case PAINBLEND_MEDIUMPURPLE:
			GiveInventory("PainBlend_MediumPurple", 1);
		break;
		case PAINBLEND_BLUE:
			GiveInventory("PainBlend_Blue", 1);
		break;
		case PAINBLEND_GRAY:
			GiveInventory("PainBlend_Gray", 1);
		break;
	}
	SetResultValue(0);
}

Script "DnD Hit Blend" (int blend_id) {
	int pnum = PlayerNumber();
	
	// player got hurt, but wait till we get OK for next tic to have accumulated the damage
	while(!PlayerScriptsCheck[DND_SCRIPT_BLEND][pnum])
		Delay(const:1);
	
	int amt = CheckInventory("DnD_DamageReceived");
	if(!amt)
		Terminate;
		
	// and since blend scripts run twice, this had to be done... pass along the accumulated data and overwrite for next use
	SetInventory("DnD_DamageFade", amt);
	SetInventory("DnD_DamageReceived", 0);
	
	PlayerScriptsCheck[DND_SCRIPT_BLEND][pnum] = false;
	
	ACS_NamedExecuteWithResult("DnD Blend Start", blend_id);

	SetResultValue(0);
}

Script "DnD Synth Mask Acquired" (void) {
	int res = CheckInventory("SynthMaskToken") ? DND_SYNTHMASK_EFFECT : 1;
	SetResultValue(res);
}

Script "DND Killing Spree End" (int spree, int mult, int reward) CLIENTSIDE {
	LocalAmbientsound("KillStreak/Show", 127);
	SetHudSize(480, 360, 0);
	str temp = "KILLST";
	for(int i = 0; i < 4; ++i) {
		SetFont(StrParam(s:temp, d:i + 1));
		HudMessage(s:"A"; HUDMSG_FADEOUT, DND_SPREE_BLOODID, CR_WHITE, 220.4, 324.0, 3.0, 1.0);		
		Delay(3);
	}
	SetFont("MONFONT");
	HudMessage(s:"\ci", l:GetSpreeText(Clamp_Between(mult, 1, MAX_SPREE_TEXT)), s:"!\c- \cix", f:mult * 0.25, s:"\c- ", l:"DND_TEXT_BONUS", s:"!"; HUDMSG_FADEINOUT, DND_SPREE_TEXT1ID, CR_WHITE, 240.4, 320.0, 2.0, 1.0, 1.0);
	HudMessage(l:"DND_TEXT_GAINEDEXTRA", s:" \cf", d:reward, s: "\c- ", l:"DND_STAT16", s:"!"; HUDMSG_FADEINOUT, DND_SPREE_TEXT2ID, CR_WHITE, 240.4, 328.0, 2.0, 1.0, 1.0);
}

Script "DnD Killing Spree Timer" (void) {
	while(CheckInventory("DnD_SpreeTimer")) {
		TakeInventory("DnD_SpreeTimer", 1);
		Delay(const:1);
	}
	// countdown over, reset spree xp and handle spree stuff
	TakeInventory("DnD_SpreeCountdownRunning", 1);

	if(CheckInventory("DnD_MultikillCounter")) {
		while(CheckInventory("DnD_SpreeTimer"))
			Delay(const:1);
		if(CheckInventory("DnD_MultikillCounter") >= DND_SPREE_TRIGGER && isAlive()) {
			int spree = CheckInventory("DnD_MultiKillCounter") + 1, mult = 0, reward = 0, temp;
			SetInventory("DnD_MultiKillCounter", 0);
			// shows kill spree result on hud
			// for every 10 enemy killed in spree, add a 0.25 multiplier
			// base multiplication factor is 0.25
			mult = Clamp_Between(spree / DND_SPREE_PER, 1, MAX_SPREE_TEXT); // how many .25 to add
			temp = CheckInventory("SpreeXP") / DND_SPREE_BASE;
			while(mult) {
				// no overflow
				if(reward < INT_MAX - temp)
					reward += temp;
				--mult;
			}
			if(CheckInventory("DnD_QuestReward_KillingSpree15"))
				reward += reward * DND_QUEST_BERSERK_SPREEBONUS / 100;
			ACS_NamedExecuteAlways("DND Killing Spree End", 0, spree, spree / DND_SPREE_PER, reward);
			GiveInventory("Exp", reward);
			GiveInventory("LevelExp", reward);
			GiveInventory("LevelUpChecker", 1);
			CalculateExpRatio();
			SetInventory("SpreeXP", 0);
			
			// check 10 kill spree quest
			if(active_quest_id == QUEST_10SPREES && !IsQuestComplete(0, QUEST_10SPREES)) {
				GiveInventory("DnD_BerserkQuest_SpreeCounter", 1);
				if(CheckInventory("DnD_BerserkQuest_SpreeCounter") >= DND_QUEST_BERSERK_SPREEREQ)
					CompleteQuest(ActivatorTID(), QUEST_10SPREES);
			}
			
			// ravager armor add
			int armor_id = GetArmorID();
			int armor_amt = GetArmorAmount();
			if(armor_id == DND_ARMOR_RAVAGER && armor_amt) {
				int cap = GetArmorCapFromID(armor_id);
				if(armor_amt < cap) {
					ACS_NamedExecuteAlways("DND Armor Give", 0, DND_ARMOR_RAVAGER, cap - armor_amt);
					GiveInventory("RavagerEffect", 1);
					LocalAmbientSound("items/armorbonus", 127);
				}
			}
			
			// punisher perk 2 -- -2 means was at least merciless
			temp = spree / DND_SPREE_PER;
			if(CheckInventory("Punisher_Perk25") && temp >= 2) {
				temp = DND_PUNISHER_SPREERECOVER + DND_PUNISHER_SPREEPERBONUS * (temp - 2);
				ACS_NamedExecuteAlways("DnD Health Pickup", 0, temp);
				ACS_NamedExecuteAlways("DND Armor Give", 0, armor_id, temp);
			}
		}
		else {
			SetInventory("DnD_MultikillCounter", 0);
			SetInventory("SpreeXP", 0);
		}
		
		// spree ended
		TakeInventory("Punisher_Perk5_MoveSpeed", 1);
	}
}

Script "DND Mugshot Grin" (void) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	SetMugshotState("Grin");
}

Script "DND On Revive" (void) {
	TakeInventory("Mo_Died", 1);
	//Mob that gets revived don't call Monster Scale script. Make sure some of its effects get reapplied here.
	int this = ActivatorTID();
	int id = this - DND_MONSTERTID_BEGIN;
	if (MonsterProperties[id].maxhp) { // This could be skipped if all mobs have their Monster Scaling.
		SetEliteFlag(DND_REVIVED, true); // Add "Revived" trait to mob. Also gives "Mo_Revived" item.
		// Reapply the elite FX.
		if (MonsterProperties[id].isElite)
			ACS_NamedExecuteAlways("DND Elite Special FX", 0);
		//printbold(s:"Monster id: ",d:MonsterProperties[id].id,s:", (After Respawn) Mob spawn hp:", d:GetActorProperty(0, APROP_SpawnHealth), s:", Mob hp:", d:GetActorProperty(0, APROP_Health), s:", Mob realhp",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp);
		//Mob revives with "APROP_SpawnHealth" HP. Make sure it respawns with the right max hp.
		int maxhp = MonsterProperties[id].maxhp;
		int dmg = GetActorProperty(0, APROP_SpawnHealth) - GetActorProperty(0, APROP_Health);
		SetActorProperty(0, APROP_HEALTH, maxhp);
		Clamp_Between(dmg, 0, maxhp + 1);
		Thing_Damage2(this, dmg, "None");
		//Mob might actually be dead by this point.
		if (GetActorProperty(0, APROP_Health) > maxhp) //In the rare case the mob keeps the very high hp
			Thing_Damage2(this, GetActorProperty(0, APROP_Health) + 1, "None"); //Just kill it
			
		HandleMonsterClassInnates(this, MonsterProperties[id].id);
		HandleSpecialTraits(this, MonsterProperties[id].id);
	}
	//printbold(s:"(Really After Respawn) Mob spawn hp:", d:GetActorProperty(0, APROP_SpawnHealth), s:", Mob hp:", d:GetActorProperty(0, APROP_Health));
	ACS_NamedExecuteAlways("DnD On Revive CS", 0);
	GiveInventory("DnD_MonsterSetupDone", 1);
}

Script "DnD On Revive CS" (void) CLIENTSIDE {
	TakeInventory("Mo_Died", 1);
}

// Make sure clients are aware too
Script "DND On Kill CS" KILL CLIENTSIDE {
	GiveInventory("Mo_Died", 1);
}

Script "DnD On Kill Forced CS" (void) CLIENTSIDE {
	GiveInventory("Mo_Died", 1);
}

Script "DnD Wanderer Explosions" (int this, int target) {
	int hpdamage = MonsterProperties[this - DND_MONSTERTID_BEGIN].maxhp / DND_WANDERER_EXP_DAMAGE;
	if(hpdamage < 0)
		hpdamage = 1;
	
	int exptid = DND_WANDERER_EXP_TID + target - P_TIDSTART;
	SpawnForced("Wanderer_Explosion", GetActorX(this), GetActorY(this), GetActorZ(this) + GetActorProperty(this, APROP_HEIGHT) / 2 + 24.0, exptid);
	SetUserVariable(exptid, "user_dmg", hpdamage);
	SetActivator(exptid);
	SetPointer(AAPTR_TARGET, target);
	Thing_ChangeTID(exptid, 0);
}

Script "DnD Check Elite Clear" (void) CLIENTSIDE {
	SetActivatorToTarget(0);
	//printbold(d:ActivatorTID());
	SetResultValue(!ActivatorTID() || CheckInventory("Mo_Died") || GetActorProperty(0, APROP_HEALTH) <= 0);
}

// Used for exp and credit calculations
Script "DND On Kill" KILL {
	int this = ActivatorTID();
	
	// pet check -- pets dont have anything going for them beyond here
	if(IsPet(this)) {
		Thing_ChangeTID(0, 0);
		Terminate;
	}
	
	int m_id = this - DND_MONSTERTID_BEGIN;
	GiveInventory("Mo_Died", 1);
	TakeInventory("DnD_CullSuccess", 1);
	// don't continue if monster is revived or summoned
	if(HasTrait(m_id, DND_SUMMONED) || HasTrait(m_id, DND_REVIVED))
		Terminate;
	
	int target = GetActorProperty(0, APROP_TARGETTID);
	bool killerWasntPlayer = target < P_TIDSTART || target > P_TIDSTART + MAXPLAYERS - 1;
	// only work if you can determine target as a player
	if(killerWasntPlayer && !CurrentLevelData[LEVELDATA_WISDOMMASTERED] && !CurrentLevelData[LEVELDATA_GREEDMASTERED])
		Terminate;
		
	// remove freeze and chill timers
	SetInventory("DnD_ChillStacks", 0);
	SetInventory("DnD_FreezeTimer", 0);
	
	if(MonsterProperties[m_id].trait_list[DND_REBIRTH]) {
		GiveInventory("DnD_RebirthItem", 1);
		MonsterProperties[m_id].trait_list[DND_REBIRTH] = false;
	}
	
	if(MonsterProperties[m_id].trait_list[DND_SUBORDINATE])
		HandleSubordinateSpawn(this, m_id);
		
	if(MonsterProperties[m_id].trait_list[DND_MARKOFCHAOS]) {
		--NPC_States[DND_NPC_DARKWANDERER].offer_progress;
		// adds 5 seconds for killing it to the timer
		NPC_States[DND_NPC_DARKWANDERER].time += 5 * (1 + GetMonsterSizeType(MonsterProperties[m_id].id));
	}
	else if(NPC_States[DND_NPC_DARKWANDERER].n_state == NPC_STATE_VOTE_ACCEPT && NPC_States[DND_NPC_DARKWANDERER].offer >= NPC_OFFER_1) {
		// 20% chance to add 1, 4 or 7 seconds depending on monster size
		NPC_States[DND_NPC_DARKWANDERER].time += !random(0, 4) * (1 + 3 * GetMonsterSizeType(MonsterProperties[m_id].id));
	}
	
	if(IsUniqueMonster(MonsterProperties[m_id].id))
		HandleUniqueDeath(MonsterProperties[m_id].id);
		
	if(MonsterProperties[m_id].trait_list[DND_PHANTASM])
		Spawn("Phantasm", GetActorX(0), GetActorY(0), GetActorZ(0), 0);
	
	int expshare = GetCVar("dnd_sharexp");
	int creditshare = GetCVar("dnd_sharecredit");
	
    // decide how exp/credit base is calculated
	int exptemp = MonsterProperties[m_id].maxhp / DND_HEALTHEXPSCALE;
	int credtemp = (DND_HEALTHCREDITUPSCALE * MonsterProperties[m_id].maxhp) / DND_HEALTHCREDITSCALE;
    int pnum = 0, i = MonsterProperties[m_id].level;
	
	if(i > 75)
		credtemp /= DND_HEALTHCREDITAFTER75SCALE;
	else if(i > 50)
		credtemp /= DND_HEALTHCREDITAFTER50SCALE;
	
	if(credtemp < DND_MIN_CREDIT)
		credtemp = DND_MIN_CREDIT;
	
	if(MonsterProperties[m_id].isElite) {
		exptemp += exptemp * DND_ELITE_EXP_BONUS / 100;
		credtemp += credtemp * DND_ELITE_CREDIT_BONUS / 100;
	}
	
	int pcount = Clamp_Between(PlayerCount(), 1, DND_MAX_SHARE);
	int expscale = Clamp_Between(GetCVar("dnd_exp_scale"), 1, EXP_SCALE_MAX);
	int creditscale = Clamp_Between(GetCVar("dnd_credit_scale"), 1, CREDIT_SCALE_MAX);
	int addone = 0;
		
	// add monster scale stuff
	if(MonsterProperties[m_id].level > 1) {
		exptemp += exptemp * MonsterProperties[m_id].level * Clamp_Between(GetCVar("dnd_monster_rewardscalepercent"), 1, 25) / 100;
		credtemp += credtemp * MonsterProperties[m_id].level * Clamp_Between(GetCVar("dnd_monster_rewardscalepercent"), 1, 25) / 100;
	}
	
	// if full share is on we won't divide by player count, but if it isn't we will
	if(!GetCVar("dnd_fullshare")) {
		exptemp = (exptemp * expscale) / pcount;
		if(exptemp < MIN_EXP_GAIN)
			exptemp = MIN_EXP_GAIN;
		credtemp = (credtemp * creditscale) / pcount;
		if(credtemp < MIN_CREDIT_GAIN)
			credtemp = MIN_CREDIT_GAIN;
	}
	else {
		exptemp *= expscale;
		credtemp *= creditscale;
	}
	
	// from here on out the scale variables and pcount are useless
	pcount = GetCVar("dnd_gainrange");
	
	// if player killed this, distribute exp and credit normally, otherwise scan for players who have mastered wisdom or greed for this
	if(!killerWasntPlayer) {
		// reuse old variable -- we dont need killerplayer w.e info
		killerWasntPlayer = MonsterProperties[m_id].isElite;
		HandleMonsterTemporaryWeaponDrop(m_id, target - P_TIDSTART, killerWasntPlayer, false);
	
		if(expshare || creditshare) {
			for(i = 0; i < MAXPLAYERS; ++i) {
				expscale = 0;
				creditscale = 0;
				pnum = P_TIDSTART + i;
				if(IsActorAlive(pnum) && pnum != target) { // dont give twice
					// check if range flag is on, if it is check the range
					addone = AproxDistance(GetActorX(target) - GetActorX(pnum), GetActorY(target) - GetActorY(pnum)) >> 16 <= pcount;
					if(expshare && (!GetCVar("dnd_gainonlyinrange") || addone || HasActorMasteredPerk(pnum, STAT_WIS)))
						expscale = RewardActorExp(pnum, exptemp);
						
					if(creditshare && (!GetCVar("dnd_gainonlyinrange") || addone || HasActorMasteredPerk(pnum, STAT_GRE)))
						creditscale = RewardActorCredit(pnum, credtemp);
					
					// if something could be provided, show it to user
					if(expscale || creditscale) {
						SetActivator(pnum);
						ACS_NamedExecuteWithResult("DND Show Kill Digits", pnum, expscale, creditscale);
					}
				}
			}
		}
		
		// now give target his stuff (if expshare or creditshare, one of them was not on the target would not receive it in the loop)
		expscale = RewardActorExp(target, exptemp);
		creditscale = RewardActorCredit(target, credtemp);
		SetActivator(target);
		ACS_NamedExecuteWithResult("DND Show Kill Digits", target, expscale, creditscale);
	}
	else {
		expshare = 0;
		creditshare = 0;
		for(i = 0; i < MAXPLAYERS; ++i) {
			expscale = 0;
			creditscale = 0;
			target = P_TIDSTART + i;
			if(IsActorAlive(target)) {
				if(HasActorMasteredPerk(target, STAT_WIS)) {
					expscale = RewardActorExp(target, exptemp);
					++expshare;
				}
				
				if(HasActorMasteredPerk(target, STAT_GRE)) {
					creditscale = RewardActorCredit(target, credtemp);
					++creditshare;
				}
				
				if(expscale || creditscale) {
					SetActivator(target);
					ACS_NamedExecuteWithResult("DND Show Kill Digits", target, expscale, creditscale);
				}
				
				// quit early if we concluded all mastery players
				if(expshare == CurrentLevelData[LEVELDATA_WISDOMMASTERED] && creditshare == CurrentLevelData[LEVELDATA_GREEDMASTERED])
					break;
			}
		}
		
		// guaranteed temp weapon drop
		HandleMonsterTemporaryWeaponDrop(m_id, -1, 0, true);
		
		// this is where we will cut off this script in case the monster wasn't killed by a player for perk masteries
		Terminate;
	}
	
	// from here on out, killerWasntPlayer stores if the monster is an elite or not
	// set activator back to the monster
	SetActivator(this);

	if(CheckActorInventory(target, "Wanderer_Perk50"))
		ACS_NamedExecuteAlways("DnD Wanderer Explosions", 0, this, target);
		
	if(CheckInventory("DnD_OverloadTimer") && !CheckInventory("DnD_OverloadLockTime")) {
		GiveInventory("DnD_OverloadZapGiver", 1);
		ACS_NamedExecuteAlways("DnD Monster Overload Zap", 0, this, target);
	}
	SetInventory("DnD_OverloadTimer", 0);
	
	// Handle Drops
	// drop coins if there should be
	if(GetCVar("dnd_credit_drops")) {
		// calculate chance of getting credit drops, more chance if monster is an elite and if player has quest
		HandleCashDrops(m_id, target - P_TIDSTART, killerWasntPlayer);
	}
	
	if(HasActorMasteredPerk(target, STAT_MUN) && RunDefaultDropChance(target - P_TIDSTART, killerWasntPlayer, DND_MUNITION_MASTERY_CHANCE)) {
		SpawnDrop("DnD_AmmoToken", 24.0, 16, 0, 0);
		if(HasActorMasteredPerk(target, STAT_LUCK) && random(0, 1.0) <= DND_MASTERY_LUCKCHANCE)
			SpawnDrop("DnD_AmmoToken", 24.0, 16, 0, 0);
	}

	// soul ammo drop -- considers ability - soulstealer as well
	if(
		(CanDropSoulAmmo() && RunDefaultDropChance(target - P_TIDSTART, killerWasntPlayer, DND_SOULAMMO_DROPRATE)) ||
		(IsDemon() && ((CheckInventory("BookCausedDeath") || (CheckActorInventory(target, "Ability_SoulStealer") && CheckInventory("MagicCausedDeath")))))
	  )
	{
		if(random(1, 100) <= DND_SOULAMMO_SMALLCHANCE || CheckInventory("BookCausedDeath")) {
			SpawnDrop("Souls", 24.0, 16, 0, 0);
			if(HasActorMasteredPerk(target, STAT_LUCK) && random(0, 1.0) <= DND_MASTERY_LUCKCHANCE)
				SpawnDrop("Souls", 24.0, 16, 0, 0);
		}
		else {
			SpawnDrop("LargeSouls", 24.0, 16, 0, 0);
			if(HasActorMasteredPerk(target, STAT_LUCK) && random(0, 1.0) <= DND_MASTERY_LUCKCHANCE)
				SpawnDrop("LargeSouls", 24.0, 16, 0, 0);
		}
		TakeInventory("BookCausedDeath", 1);
		TakeInventory("MagicCausedDeath", 1);
	}

	if(!GetCVar("dnd_allresearchesfound")) {
		// make it less likely to drop
		// addone is the chance here (reusing old variables)
		addone = random(0, DND_RESEARCH_DROPMULT * DND_RESEARCH_MAX_CHANCE);
		/*#ifdef ISDEBUGBUILD
			SpawnResearch();
		#else*/
			if(GetCVar("dnd_ignore_dropweights") || RunDropChance(target - P_TIDSTART, killerWasntPlayer, Clamp_Between(GetCVar("dnd_researchdroprate"), 0.0, DND_RESEARCH_MAX_CHANCE), 0.0, addone))
				SpawnResearch(target - P_TIDSTART);
		//#endif
	}
	
	// Talent Capsule Drop
	//if(RunDefaultDropChance(target - P_TIDSTART, killerWasntPlayer, DND_TALENTCAPSULE_DROPRATE))
	//	SpawnTalentCapsule();
	
	// Chest Key
	HandleChestKeyDrop(killerWasntPlayer);
	
	// if elite, roll orb and equipment drops
	if(GetCVar("dnd_ignore_dropweights") || killerWasntPlayer) {
		// handle orb drops
		HandleEliteDrops();
	}
	
	// accessory drops (accept only from cyber and spider masterminds)
	/*#ifdef ISDEBUGBUILD
		SpawnAccessory();
	#else*/
	if(IsBoss()) {
		if(RunDropChance(target - P_TIDSTART, killerWasntPlayer, (Clamp_Between(GetCVar("dnd_accessory_droprate"), 0, 100) * 1.0) / 100, 0, 1.0)) {
			if(GetAveragePlayerLevel() >= Clamp_Between(GetCVar("dnd_accessorylevel"), 1, 100)) {
				// we can drop the spawner
				SpawnAccessory();
			}
		}
	}
	//#endif
	
	// Demon Bane check
	if(active_quest_id == QUEST_KILL10BOSSES && IsBoss()) {
		GiveActorInventory(target, "DnD_BossKillQuest_Counter", 1);
		if(!IsQuestComplete(target, QUEST_KILL10BOSSES) && CheckActorInventory(target, "DnD_BossKillQuest_Counter") == DND_QUEST_BOSSKILLER_REQ)
			CompleteQuest(target, QUEST_KILL10BOSSES);
	}
	
	// Elite Slayer check
	if(active_quest_id == QUEST_KILL20ELITES && killerWasntPlayer) {
		GiveActorInventory(target, "DnD_EliteKillQuest_Counter", 1);
		if(!IsQuestComplete(target, QUEST_KILL20ELITES) && CheckActorInventory(target, "DnD_EliteKillQuest_Counter") == DND_QUEST_ELITEKILLER_REQ)
			CompleteQuest(target, QUEST_KILL20ELITES);
	}
	
	// Legendary Kill Item
	if(MonsterProperties[m_id].id >= LEGENDARY_START) {
		for(i = 0; i < MAXPLAYERS; ++i) {
			if(PlayerInGame(i) && IsActorAlive(i + P_TIDSTART)) {
				UpdateLegendaryKill(i, MonsterProperties[m_id].id - LEGENDARY_START);
				
				if(active_quest_id - DND_LEGQUEST_START == MonsterProperties[m_id].id - LEGENDARY_START)
					CompleteQuest(i + P_TIDSTART, active_quest_id);
			}
		}
	}
	
	#ifdef ISDEBUGBUILD
		//SpawnElixir(0);
		SpawnCharm(0, true);
		SpawnOrb(0, true);
		//SpawnToken(0, true);
	#endif
	
	HandleCharmLootDrop(killerWasntPlayer);
	
	// doomguy drop
	if(CheckActorInventory(target, "Doomguy_Perk25") && RunDefaultDropChance(i, killerWasntPlayer, DND_DOOMGUY_DROPCHANCE)) {
		pcount = MonsterProperties[m_id].maxhp;
		SpawnDrop("Doomguy_DemonSoul", 24.0, 16, pcount & 0xFFFF, pcount >> 16);
		if(HasActorMasteredPerk(target, STAT_LUCK) && random(0, 1.0) <= DND_MASTERY_LUCKCHANCE)
			SpawnDrop("Doomguy_DemonSoul", 24.0, 16, pcount & 0xFFFF, pcount >> 16);
	}
	
	// if marked by talisman
	pcount = CheckInventory("HunterTalismanMarkBool");
	SetInventory("HunterTalismanMarkBool", 0);
	
	if(isZombie())
		GiveActorInventory(target, "DnD_ShotUndead", 1);
	
	// required delay for transition from specific death state labels
	Delay(const:1);
	
	HandleOtherDrops(target);
	
	// check zombie summon
	if(!IsLostSoul() && !IsRobotic()) {
		addone = CheckActorInventory(target, "IATTR_ChanceToRaiseZombieFromKills");
		if(HasRoomForPets(target) && CheckActorInventory(target, "SummonedZombiePets") < MAX_SUMMON_ZOMBIECOUNT && addone >= random(1, 100)) {
			// raise zombie
			HandleZombieRaiseOnDeath(target);
		}
	}
	
	// chaos marked monsters are removed on death, no ressing
	if(CheckActorInventory(target, "StatbuffCounter_SlainMonstersRIP") || MonsterProperties[m_id].trait_list[DND_MARKOFCHAOS])
		ACS_NamedExecuteAlways("DnD Monster RIP", 0);
	
	SetActivator(target);
	
	// keep the kill tally
	IncrementPlayerLifetimeKills();
	
	if(CheckInventory("Punisher_Perk50")) {
		GiveInventory("Punisher_Perk50_Counter", 1);
		ACS_NamedExecuteAlways("DnD Punisher Perk50 Display", 0, false);
	}
	
	// research track
	if(isBoss() && CheckResearchStatus(RES_IMP1) == RES_NA) {
		GiveInventory("Research_Body_Im_1_Tracker", 1);
		if(CheckInventory("Research_Body_Im_1_Tracker") == GetAmmoCapacity("Research_Body_Im_1_Tracker")) {
			GiveResearch(RES_IMP1, true);
			// take these off so they don't take netid
			TakeInventory("Research_Body_Im_1_Tracker", 65535);
		}
	}
	
	if(isDemon() && CheckResearchStatus(RES_SLOT3UPG3) == RES_NA) {
		GiveInventory("Research_Slot3Upgrade3_Tracker", 1);
		if(CheckInventory("Research_Slot3Upgrade3_Tracker") == GetAmmoCapacity("Research_Slot3Upgrade3_Tracker")) {
			GiveResearch(RES_SLOT3UPG3, true);
			// take these off so they don't take netid
			TakeInventory("Research_Slot3Upgrade3_Tracker", 65535);
		}
	}
	
	// Kill spree
	if(GetCVar("dnd_killspree"))
		ActivateKillingSpree();
	// Hunter Talisman Heal
	if(pcount) {
		GiveInventory("HunterTalismanHealFXSpawner", 1);
		ACS_NamedExecuteAlways("DnD Health Pickup", 0, GetSpawnHealth() / DND_HUNTERTALISMAN_HEALFACTOR);
	}
	
	addone = CheckInventory("IATTR_HealOnKill");
	if(addone) {
		pcount = GetMissingHealth();
		addone = (pcount * addone) / 100;

		// if player is missing some health, but our factor was 0, make it 1
		if(!addone && pcount)
			addone = 1;
		
		if(addone) {
			Spawn("DarkHealEffectSpawner", GetActorX(0), GetActorY(0), GetActorZ(0), 0);
			ACS_NamedExecuteAlways("DnD Health Pickup", 0, addone);
		}
	}
}

Script "DnD Monster RIP" (int tid) {
	Delay(const:RIP_MONSTER_FADE_DELAY);
	SetActorProperty(tid, APROP_RENDERSTYLE, STYLE_Translucent);
	int a = GetActorProperty(tid, APROP_ALPHA);
	for(int i = 1; i < RIP_FADE_TIMER; ++i) {
		SetActorProperty(tid, APROP_ALPHA, a - (i * 1.0) / RIP_FADE_TIMER);
		Delay(const:1);
	}
	Thing_Remove(tid);
}

Script "DND Show Kill Digits" (int tid, int exp, int credit) CLIENTSIDE {
	// spectators shouldn't see this
	// for some reason exp and credit can be 0, no idea how, but this fixes it
	SetResultValue(0);
	if(ConsolePlayerNumber() != PlayerNumber() || !PlayerInGame(ConsolePlayerNumber()) || (!exp && !credit))
		Terminate;
	GiveActorInventory(tid, "DnD_Exp_Counter", exp);
	GiveActorInventory(tid, "DnD_Credit_Counter", credit);
	GiveActorInventory(tid, "DnD_ExpCredit_Timer", 1);
	
	// check if we can truly terminate early, if we can, extend timer
	if(PlayerScriptsCheck[DND_SCRIPT_EXPTRACKER][ConsolePlayerNumber()]) {
		// refresh duration if we're already running one
		if(CheckActorInventory(tid, "DnD_ExpCredit_Timer"))
			GiveActorInventory(tid, "DnD_ExpCredit_Timer", 1);
		Terminate;
	}
	
	PlayerScriptsCheck[DND_SCRIPT_EXPTRACKER][ConsolePlayerNumber()] = true;
	while(CheckActorInventory(tid, "DnD_ExpCredit_Timer"))
		Delay(const:2);
	if((CheckActorInventory(tid, "DnD_Exp_Counter") || CheckActorInventory(tid, "DnD_Credit_Counter")) && !CheckActorInventory(tid, "DnD_IntermissionState"))
		Log(s:"\ccGains pickup  : \c[Y5]", d:CheckActorInventory(tid, "DnD_Exp_Counter"), s:" exp and ", d:CheckActorInventory(tid, "DnD_Credit_Counter"), s:" credits.");
	SetActorInventory(tid, "DnD_Exp_Counter", 0);
	SetActorInventory(tid, "DnD_Credit_Counter", 0);
	PlayerScriptsCheck[DND_SCRIPT_EXPTRACKER][ConsolePlayerNumber()] = false;
}

// Stat Reset
Script 832 (void) {
	int statpts = Calculate_Stats();
	int perkpts = Calculate_Perks();
	Reset_RPGInfo(RESET_STATS | RESET_PERKS);
	StatListOpened[PlayerNumber()] = 0;
	// don't use set here, it removes unallocated pts
	GiveInventory("AttributePoint", statpts);
	GiveInventory("PerkPoint", perkpts);
}

// Weapon pickup checks, bulkiness armor check and agamotto check
Script "DnD Periodic Checks" ENTER {
	int temp;
	while(isAlive()) {
		// Agamotto check
		if(CheckInventory("AgamottoCheck")) {
			int input = GetPlayerInput(-1, INPUT_BUTTONS);
			if(input & (BT_FORWARD | BT_BACK | BT_MOVELEFT | BT_MOVERIGHT)) {
				if(!CheckInventory("AgamottoDefense")) {
					GiveInventory("AgamottoDefense", 1);
					TakeInventory("AgamottoOffense", 1);
				}
			}
			else if(!CheckInventory("AgamottoOffense")) {
				TakeInventory("AgamottoDefense", 1);
				GiveInventory("AgamottoOffense", 1);
			}
		}
		else {
			TakeInventory("AgamottoDefense", 1);
			TakeInventory("AgamottoOffense", 1);
		}
		
		// Sigil Check
		if(CheckInventory("SigilCheck")) {
			// give item only if there is no sigil powerup currently on player
			if(HasNoSigilPower()) {
				switch(CheckInventory("SigilCheck")) {
					case 1: // fire
						GiveInventory("ElementPower_Fire", 1);
					break;
					case 2:
						GiveInventory("ElementPower_Ice", 1);
					break;
					case 3:
						GiveInventory("ElementPower_Lightning", 1);
					break;
					case 4:
						GiveInventory("ElementPower_Earth", 1);
					break;
				}
				SetInventory("SigilCheck", (CheckInventory("SigilCheck") % 4) + 1);
			}
		}
		
		// for cautious quest
		if(active_quest_id == QUEST_HPOVER50 && GetActorProperty(0, APROP_HEALTH) < GetSpawnHealth())
			GiveInventory("DnD_HealthLess50", 1);

		if(active_quest_id == QUEST_SPEND25K && CheckInventory("DnD_MoneySpentQuest") >= DND_QUEST_MONEYMAKERREQ && !IsQuestComplete(ActivatorTID(), QUEST_SPEND25K))
			CompleteQuest(ActivatorTID(), QUEST_SPEND25K);
		
		// this used to be 7, but I reduced frequency, hopefully nothing was too dependent on this
		Delay(const:10);
	}
}

// 894 is for database save

// Special Interaction script with NPCs
Script 895 (int val, int this) {
	if(!CheckInventory("ShowingMenu") && !CheckInventory("NPC_Trigger_Cooldown")) {
		GiveInventory("NPC_Trigger_Cooldown", 1);
		switch(val) {
			case 0:
				// dark wanderer engage script
				if(!CheckInventory("ShowingPrompt")) {
					// open
					SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
					GiveInventory("P_Frozen", 1);
					GiveInventory("ShowingPrompt", 1);
					LocalAmbientSound("RPG/MenuClose", 127);
					
					// setup
					SetInventory("Mouse_X", HUDMAX_XF / 2);
					SetInventory("Mouse_Y", HUDMAX_YF / 2);
					ClearPlayerInput(PlayerNumber(), true);
					
					bool first_time = false;
					// the inventory check makes sure you see greeting text even if you dont partake
					if((!HasMetNPC(DND_NPC_DARKWANDERER) || CheckInventory("DarkWandererFirstTime"))) {
						GiveInventory("DarkWandererFirstTime", 1);
						first_time = true;
					}
					else {
						// we met before, roll a specific dialog id that remains for the map
						SetInventory("ReceivedDialogID", NPC_States[DND_NPC_DARKWANDERER].dialog);
					}
					
					FaceActor(this, ActivatorTID());

					ACS_NamedExecuteAlways("DnD Prompt Dark Wanderer", 0, first_time, NPC_States[DND_NPC_DARKWANDERER].offer, NPC_States[DND_NPC_DARKWANDERER].n_state);
					
					MarkNPCMet(DND_NPC_DARKWANDERER);
				}
				else {
					// close
					ClosePrompt();
				}
			break;
		}
	}
}

Script "DnD Prompt Dark Wanderer" (int first_time, int offer_id, int n_state) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
		
	// draw the background once
	SetHudSize(HUDMAX_X, HUDMAX_Y, 1);
	SetFont("THORM1");
	HudMessage(s:"A"; HUDMSG_PLAIN, RPGMENUID, -1, 400.0, 160.0, 0.0, 0.0);
	SetHudSize(HUDMAX_X_PROMPT, HUDMAX_Y_PROMPT, 1);
	SetFont("PROMPT");
	HudMessage(s:"A"; HUDMSG_PLAIN, RPGMENUBACKGROUNDID, -1, 480.0, 320.0, 0.0, 0.0);

	// draw greetings text
	SetFont("SMALLFONT");
	SetHudClipRect(160, 128, 532, 600, 532);
	
	menu_pane_T& CurrentPane = GetPane();
	ResetPane(CurrentPane);
	
	// vote state isnt concluded
	bool voting_ongoing = n_state != NPC_STATE_VOTE_DECLINE && n_state != NPC_STATE_VOTE_ACCEPT;
	int yOff = 384.0;
	
	if(first_time) {
		if(n_state != NPC_STATE_VOTE_ACCEPT) {
			HudMessage(
				l:GetPromptText(DW_GREET_FIRST_TIME1), 
				s:"\n\n", l:GetPromptText(DW_GREET_FIRST_TIME2), 
				s:"\n\n", l:GetPromptText(DW_GREET_FIRST_TIME3),
				s:"\n\n\c[Y5]---------------------------------------\n\n",
				s:"\c[W3]", l:"DND_CHALLENGE", s:":\n\n", l:GetPromptText(DW_CHALLENGE_BEGIN + offer_id - 1);
				HUDMSG_PLAIN, RPGMENUITEMID, CR_WHITE, 160.1, 128.1, 0.0, 0.0
			);
		}
		else {
			HudMessage(
				l:GetPromptText(DW_GREET_FIRST_TIME1), 
				s:"\n\n", l:GetPromptText(DW_GREET_FIRST_TIME2), 
				s:"\n\n", l:GetPromptText(DW_GREET_FIRST_TIME3),
				s:"\n\n\c[Y5]---------------------------------------\n\n",
				s:"\c[W3]", l:"DND_CHALLENGE", s:" - \cd", l:"DND_ACCEPTED", s:"\c[W3]:\n\n", l:GetPromptText(DW_CHALLENGE_BEGIN + offer_id - 1);
				HUDMSG_PLAIN, RPGMENUITEMID, CR_WHITE, 160.1, 128.1, 0.0, 0.0
			);

		}
		if(voting_ongoing) {
			AddBoxToPane_Points(CurrentPane, 340.0, 132.0, 300.0, 124.0);
			AddBoxToPane_Points(CurrentPane, 260.0, 132.0, 220.0, 124.0);
		}
	}
	else if(n_state != NPC_STATE_VOTE_ACCEPT) {
		HudMessage(
			l:GetPromptText(CheckInventory("ReceivedDialogID")),
			s:"\n\n\c[Y5]---------------------------------------\n\n",
			s:"\c[W3]", l:"DND_CHALLENGE", s:":\n\n", l:GetPromptText(DW_CHALLENGE_BEGIN + offer_id - 1);
			HUDMSG_PLAIN, RPGMENUITEMID, CR_WHITE, 160.1, 128.1, 0.0, 0.0
		);
		
		if(voting_ongoing) {
			AddBoxToPane_Points(CurrentPane, 340.0, 196.0, 300.0, 188.0);
			AddBoxToPane_Points(CurrentPane, 260.0, 196.0, 220.0, 188.0);
		}
		
		yOff = 256.0;
	}
	else {
		HudMessage(
			s:"\c[W3]", l:"DND_CHALLENGE", s:" - \cd", l:"DND_ACCEPTED", s:"\c[W3]:\n\n", l:GetPromptText(DW_CHALLENGE_BEGIN + offer_id - 1);
			HUDMSG_PLAIN, RPGMENUITEMID, CR_WHITE, 160.1, 128.1, 0.0, 0.0
		);
		
		yOff = 192.0;
	}
		
	int mousex, mousey;
	int boxid = MAINBOX_NONE, boxid_prev = MAINBOX_NONE;
	int i, j, k;
	int pnum = PlayerNumber();
	bool sendInput = false;
	while(CheckInventory("ShowingPrompt") && !CheckInventory("ShowingMenu")) {
		// cursor handling
		mousex = GetCursorPos(GetPlayerInput(ConsolePlayerNumber(), INPUT_YAW), MOUSE_INPUT_X);
		mousey = GetCursorPos(GetPlayerInput(ConsolePlayerNumber(), INPUT_PITCH), MOUSE_INPUT_Y);
		SetInventory("Mouse_X", mousex);
		SetInventory("Mouse_Y", mousey);
		
		SetHudClipRect(0, 0, 0, 0);
		SetHudSize(HUDMAX_X, HUDMAX_Y, 1);
		DrawCursor();
		SetHudSize(HUDMAX_X_PROMPT, HUDMAX_Y_PROMPT, 1);
		
		// button id recognition
		boxid = GetTriggeredBoxOnPane(CurrentPane, mousex, mousey);
		if(boxid != boxid_prev && boxid != MAINBOX_NONE)
			LocalAmbientSound("RPG/MenuMove", 127);
			
		boxid_prev = boxid;
		
		// accept
		if(voting_ongoing) {
			SetFont("SMALLFONT");
			if(CheckInventory("NPC_Offer_Accepted")) {
				HudMessage(l:"DND_ACCEPT"; HUDMSG_PLAIN, RPGMENUITEMID - 3, CR_GREEN, 320.4, yOff, 0.0, 0.0);
				SetFont("TRADBTNC");
			}
			else if(boxid == MBOX_1) {
				HudMessage(s:"\c[M3]", l:"DND_ACCEPT"; HUDMSG_PLAIN, RPGMENUITEMID - 3, CR_WHITE, 320.4, yOff, 0.0, 0.0);
				SetFont("TRADBTNH");
			}
			else {
				HudMessage(s:"\c[Y5]", l:"DND_ACCEPT"; HUDMSG_PLAIN, RPGMENUITEMID - 3, CR_WHITE, 320.4, yOff, 0.0, 0.0);
				SetFont("TRADBTN");
			}
			HudMessage(s:"A"; HUDMSG_PLAIN, RPGMENUITEMID - 1, CR_WHITE, 320.4, yOff, 0.0, 0.0);
			
			// decline
			SetFont("SMALLFONT");
			if(CheckInventory("NPC_Offer_Declined")) {
				HudMessage(l:"DND_DECLINE"; HUDMSG_PLAIN, RPGMENUITEMID - 4, CR_GREEN, 480.4, yOff, 0.0, 0.0);
				SetFont("TRADBTNC");
			}
			else if(boxid == MBOX_2) {
				HudMessage(s:"\c[M3]", l:"DND_DECLINE"; HUDMSG_PLAIN, RPGMENUITEMID - 4, CR_WHITE, 480.4, yOff, 0.0, 0.0);
				SetFont("TRADBTNH");
			}
			else {
				HudMessage(s:"\c[Y5]", l:"DND_DECLINE"; HUDMSG_PLAIN, RPGMENUITEMID - 4, CR_WHITE, 480.4, yOff, 0.0, 0.0);
				SetFont("TRADBTN");
			}
			HudMessage(s:"A"; HUDMSG_PLAIN, RPGMENUITEMID - 2, CR_WHITE, 480.4, yOff, 0.0, 0.0);
			
			// draw people voting yes and no here
			j = 0;
			k = 0;
			SetFont("SMALLFONT");
			for(i = 0; i < MAXPLAYERS; ++i) {
				if(NPC_States[DND_NPC_DARKWANDERER].voters[i] == 1) {
					HudMessage(n:i + 1; HUDMSG_PLAIN, RPGMENUITEMID - 5 - j - k, CR_UNTRANSLATED, 320.4, yOff + 16.0 * (j + 1), 0.0, 0.0);
					++j;
				}
				else if(NPC_States[DND_NPC_DARKWANDERER].voters[i] == -1) {
					HudMessage(n:i + 1; HUDMSG_PLAIN, RPGMENUITEMID - 5 - j - k, CR_UNTRANSLATED, 480.4, yOff + 16.0 * (k + 1), 0.0, 0.0);
					++j;
				}
			}
		}
		
		// check inputs
		ListenNPCInput();
		sendInput = CheckInventory("MenuInput") != 0;
		if(sendInput) {
			// server gets a few extra info in boxid
			if(!MenuInputData[pnum][DND_MENUINPUT_PAYLOAD])
				MenuInputData[pnum][DND_MENUINPUT_PAYLOAD] = (boxid | MenuInputData[pnum][DND_MENUINPUT_PLAYERCRAFTCLICK]);
			i = PlayerNumber() | (CheckInventory("MenuInput") << 16);
			// guarantee nonzero input
			if(i) {
				//Log(s:"trying to send prev item ", d:MenuInputData[pnum][DND_MENUINPUT_PAYLOAD] >> 16, s: " vs ", d:MenuInputData[pnum][DND_MENUINPUT_PLAYERCRAFTCLICK] >> 16);
				NamedRequestScriptPuke("DND Server Box Receive - NPC", i, MenuInputData[pnum][DND_MENUINPUT_PAYLOAD], DND_NPC_DARKWANDERER);
			}
		}
		
		Delay(const:1);
		
		// retry ack
		if(!CheckInventory("DND_ACK")) {
			if(sendInput) {
				GiveInventory("DND_ACKLoop", 1);
				//temp = boxid | (CheckInventory("DnD_PlayerItemIndex") << DND_MENU_ITEMSAVEBITS1) | (CheckInventory("DnD_PlayerPrevItemIndex") << DND_MENU_ITEMSAVEBITS2);
				//Log(s:"trying to send prev item loop beg", d:MenuInputData[pnum][DND_MENUINPUT_PAYLOAD] >> 16, s: " vs ", d:MenuInputData[pnum][DND_MENUINPUT_PLAYERCRAFTCLICK] >> 16);
				ACS_NamedExecuteAlways("DnD Retry Sending UntiL ACK - NPC", 0, PlayerNumber() | (CheckInventory("MenuInput") << 16), MenuInputData[pnum][DND_MENUINPUT_PAYLOAD], DND_NPC_DARKWANDERER);
			}
		}
		else {
			sendInput = false;
			SetInventory("MenuInput", 0);
			//Log(s:"reset input data");
			MenuInputData[pnum][DND_MENUINPUT_PAYLOAD] = 0;
			MenuInputData[pnum][DND_MENUINPUT_PLAYERCRAFTCLICK] = 0;
		}
	}
}

Script "DnD Retry Sending UntiL ACK - NPC" (int payload1, int payload2, int npc_id) CLIENTSIDE {
	if(!payload1 || CheckInventory("DND_ACKLoop"))
		Terminate;
	while(!CheckInventory("DnD_ACK")) {
		//Log(s:"running till ack received with ", d:payload1, s: " ", d:payload2, s: " ", d:mainboxid);
		//Log(s:"trying to send prev item ", d:payload2 >> 16);
		NamedRequestScriptPuke("DND Server Box Receive - NPC", payload1, payload2, npc_id);
		Delay(const:1);
	}
	TakeInventory("DND_ACKLoop", 1);
}

Script "DND Server Box Receive - NPC" (int pnum, int boxid, int npc_id) NET {
	// don't let garbage data slip in
	if(!pnum)
		Terminate;
	int temp = pnum >> 16;
	pnum &= 0xFFFF;
		
	if(!MenuInputData[pnum][DND_MENUINPUT_DELAY]) {
		SetActivator(pnum + P_TIDSTART);
		MenuInputData[pnum][DND_MENUINPUT_DELAY] = DND_MENU_INPUTDELAYTICS;
		MenuInputData[pnum][DND_MENUINPUT] = temp;
		GiveInventory("DND_ACK", 1);
		
		if(temp == DND_MENUINPUT_USEBUTTON) {
			// force close the menu for us
			ClosePrompt();
		}
		else if(boxid != MAINBOX_NONE) {
			if(boxid == MBOX_1) {
				// in case of accept, declare a vote and wait majority or if only player in game, skip this phase
				ACS_NamedExecuteWithResult("DnD NPC Vote Register", 1, npc_id, pnum);
				LocalAmbientSound("RPG/MenuChoose", 127);
				GiveInventory("NPC_Offer_Accepted", 1);
				TakeInventory("NPC_Offer_Declined", 1);
			}
			else if(boxid == MBOX_2) {
				// decline -- mark our vote as a no, wait for voting to conclude optionally
				ACS_NamedExecuteWithResult("DnD NPC Vote Register", -1, npc_id, pnum);
				LocalAmbientSound("RPG/MenuChoose", 127);
				GiveInventory("NPC_Offer_Declined", 1);
				TakeInventory("NPC_Offer_Accepted", 1);
			}
		}
		
		ClearPlayerInput(pnum, true);
		
		Delay(const:DND_MENU_INPUTDELAYTICS);
		MenuInputData[pnum][DND_MENUINPUT_DELAY] = 0;
	}
}

Script "DnD NPC Vote Register" (int vote, int npc_id, int pnum) {
	if(!NPC_States[npc_id].voting) {
		NPC_States[npc_id].voting = true;
		NPC_States[npc_id].n_state = NPC_STATE_VOTE_ONGOING;
		ACS_NamedExecuteWithResult("DnD NPC Voting", npc_id);
	}
	
	// register vote
	NPC_States[npc_id].vote_count += vote;
	NPC_States[npc_id].voters[pnum] = vote;
		
	// check if majority is met -- if our (yes vote count) - (current player count / 2) > 0 that means we can skip further checks, we have majority
	int majority = PlayerCount() / 2 + (PlayerCount() > 1 && (PlayerCount() & 1));
	int curr = NPC_States[npc_id].vote_count - majority;
	int i;
	if(curr > 0) {
		// settle the vote as majority voting yes
		SetFont("BIGFONT");
		SetHUDSize(HUDMAX_X, HUDMAX_Y, 1);
		HudMessageBold(l:"DND_VOTEPASSED", s:"!"; HUDMSG_FADEOUT, RPGMENUBACKGROUNDID + 1, CR_GREEN, 240.4, 16.0, 1.0, 1.0);
		
		ConcludeVoting(npc_id, NPC_STATE_VOTE_ACCEPT);
		
		// handle npc completion
		while(!SpawnedChests)
			Delay(const:10);
		HandleNPC(npc_id);
	}
	else {
		// check if majority actually declined instead of accepted, so we can close voting early
		curr = 0;
		for(i = 0; i < MAXPLAYERS; ++i) {
			if(NPC_States[npc_id].voters[i])
				++curr;
		}
		// conclude voting
		if(curr >= majority) {
			HudMessageBold(s:""; HUDMSG_PLAIN, RPGMENUBACKGROUNDID + 1, CR_WHITE, 240.4, 16.0, 1.0, 0.0);
			SetFont("BIGFONT");
			SetHUDSize(HUDMAX_X, HUDMAX_Y, 1);
			HudMessageBold(l:"DND_VOTEFAILED", s:"!"; HUDMSG_FADEOUT, RPGMENUHELPCORNERID, CR_RED, 240.4, 16.0, 1.0, 1.0);
			ConcludeVoting(npc_id, NPC_STATE_VOTE_DECLINE);
		}
		else
			ACS_NamedExecuteWithResult("DnD NPC Vote Sync", pnum, vote, npc_id);
	}
}

Script "DnD Close Prompt Delayed" (int pnum, int npc_id) {
	NPC_States[npc_id].voters[pnum] = 0;
	Delay(const:17);
	ClosePrompt();
}

Script "DnD NPC Voting" (int npc_id) {
	// this is the timer, when this runs out and a majority is not found, we auto decline
	int time = DND_VOTE_TIME * TICRATE;
	while(time > 0 && NPC_States[npc_id].voting) {
		// display the timer to everyone for vote countdown
		SetFont("BIGFONT");
		SetHUDSize(HUDMAX_X, HUDMAX_Y, 1);
		HudMessageBold(d:time / TICRATE, s:" ", l:"DND_TOVOTE", s:"!"; HUDMSG_PLAIN, RPGMENUBACKGROUNDID + 1, CR_WHITE, 240.4, 16.0, 2.0, 0.0);
		
		Delay(const:1);
		--time;
	}
	
	if(NPC_States[npc_id].n_state == NPC_STATE_VOTE_ONGOING) {
		HudMessageBold(s:""; HUDMSG_PLAIN, RPGMENUBACKGROUNDID + 1, CR_WHITE, 240.4, 16.0, 1.0, 0.0);
		SetFont("BIGFONT");
		SetHUDSize(HUDMAX_X, HUDMAX_Y, 1);
		HudMessageBold(l:"DND_VOTEFAILED", s:"!"; HUDMSG_FADEOUT, RPGMENUHELPCORNERID, CR_RED, 240.4, 16.0, 1.0, 1.0);
		
		ConcludeVoting(npc_id, NPC_STATE_VOTE_DECLINE);
	}
}

Script "DnD NPC Vote Sync" (int pnum, int vote, int npc_id) CLIENTSIDE {
	if(pnum == -1) {
		// reset
		NPC_States[npc_id].vote_count = 0;
		for(int i = 0; i < MAXPLAYERS; ++i)
			NPC_States[npc_id].voters[pnum] = 0;
	}
	else {
		// update
		NPC_States[npc_id].vote_count += vote;
		NPC_States[npc_id].voters[pnum] = vote;
	}
	SetResultValue(0);
}

Script 896 (void) {
	int check = 0;
	for(int i = 0; i < MAXTEMPWEPS; ++i)
		if(CheckInventory(TemporaryWeaponData[i][TEMPWEP_NAME])) {
			check = 1;
			break;
		}
	SetResultValue(!check);
}

Script 897 (void) {
	int i = random(0, MAXTEMPWEPS - 1);
	GiveInventory(TemporaryWeaponData[i][TEMPWEP_AMMO], 999);
	GiveInventory(TemporaryWeaponData[i][TEMPWEP_NAME], 1);
	// sawedoff has clip
	if(!i)
		GiveInventory("SawedoffCounter", 2);
		
	SetWeapon(TemporaryWeaponData[i][TEMPWEP_NAME]);
	LocalAmbientSound("weapons/pickup", 127);
}

Script 898 (int msg) CLIENTSIDE {
	if(PlayerNumber() != ConsolePlayerNumber()) 
		Terminate;
	if(msg)
		Log(l:"DND_TEXT_TIPBOXON");
	else
		Log(l:"DND_TEXT_TIPBOXOFF");
}

Script 899 (int tips) NET CLIENTSIDE {
	if(GetCVar("dnd_weapontips")) {
		SetCVar("dnd_weapontips", 0);
		ACS_ExecuteAlways(898, 0, 0);
	}
	else {
		SetCVar("dnd_weapontips", 1);
		ACS_ExecuteAlways(898, 0, 1);
	}
}

// 900 is in the menu.c

Script 902 (int forceset, int id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	int i = CheckInventory("AmmoChangeMessage");
	if(forceset)
		i = id;
	if(!CheckInventory("NoAmmoMessage")) {
		SetFont("BIGFONT");
		HudMessage(l:"DND_TEXT_NOWUSING", s:" ", s:GetSpecialAmmoTag(i), s:"!"; HUDMSG_PLAIN | HUDMSG_LOG, DND_SPECIALAMMO_TEXTID, CR_WHITE, 0.5, 0.1, 2.0);
		// hack: update ammo table to trick hud
		int pos = GetWeaponPosFromTable();
		Weapons_Data[pos][WEAPON_AMMO1] = GetSpecialAmmoString(i, AMMOINFO_NAME);
	}
}

// Current weapon tip
Script 903 (void) NET CLIENTSIDE {
	DoWeaponTip(GetWeaponPosFromTable());
}

Script "DnD Weapon Tip Trigger" (int wepid, int targetToUse) CLIENTSIDE {
	if(targetToUse)
		SetActivator(targetToUse);
		
	// just tucked here for convenience
	ACS_NamedExecuteAlways("DND Mugshot Grin", 0);
		
	if(GetCVar("dnd_weapontips"))
		Terminate;
	DoWeaponTip(wepid);
}

// 904 is used by the menu

// temporary drops
Script 905 (int mode) NET {
	if(!mode) {
		int pos = GetWeaponPosFromTable();
		int curweap = pos - TEMPBEGIN; // to put it in range of the temporary weapons
		int amt;
		// valid range, no drop spam and not able to while firing and has ammo to spare
		// gross hax, fix later
		if(curweap >= 0 && curweap < MAXTEMPWEPS && !CheckInventory("DropItemCooldown") && CheckInventory("TempWeaponReady")) {
			amt = CheckInventory(TemporaryWeaponData[curweap][TEMPWEP_AMMO]);
			
			// put the clip in there as ammo
			if(pos == DND_WEAPON_SAWEDOFF) {
				amt += CheckInventory("SawedoffCounter");
				SetInventory("SawedoffCounter", 0);
			}
			
			if(amt) {
				int temptid = ActivatorTID() + P_TEMPTID;
				GiveInventory("DropItemCooldown", 1);
				// the dropped versions have _D suffix
				SpawnForced(StrParam(s:TemporaryWeaponData[curweap][TEMPWEP_DROP], s:"_D"), GetActorX(0) + cos(GetActorAngle(0)), GetActorY(0) + sin(GetActorAngle(0)), GetActorZ(0) + 32, temptid);
				SetActorProperty(temptid, APROP_MASS, amt);
				ThrustThing(GetActorAngle(0) >> 8, 16, 0, temptid);
				ThrustThingZ(temptid, 8, 0, 0);
				Thing_ChangeTID(temptid, 0); // clear tid to prevent stupid shit
				GiveInventory("ForceWeaponRemove", 1);
				CleanTempAmmo();
			}
		}
	}
}

// 906 to 914 reserved
script "DnD Aspect Ratio Check ENTER" ENTER CLIENTSIDE {
	SetupScreenOffsets();
	delay(const:105);
	restart;
}

script "DnD Aspect Ratio Check RESPAWN" RESPAWN CLIENTSIDE {
	SetupScreenOffsets();
	delay(const:105);
	restart;
}

// For each ammo category, use a multiple of 10 to store values
Script 917 (int ammo_category, int weptype) {
    // if a change did occur
	if(HasSpecialAmmoForWeapon(ammo_category) != SpecialAmmoRanges[ammo_category][0]) {
		SetSpecialAmmoMode(ammo_category, weptype);
		if(ammo_category == AMMO_TYPE_SHELL || ammo_category == AMMO_TYPE_HEAVYSHELLS)
			SetInventory(Weapons_Data[GetWeaponPosFromTable()][WEAPON_AMMO2], 0);
		ActivatorSound("AmmoType/Switch", 127);
		Delay(const:4);
	}
	else
		GiveInventory("NoAmmoMessage", 1);
	SetInventory("AmmoChangeMessage", 0);
}

// type = 0, check stat, type = 1, check accessory
// refactor later
Script 918 (int type, int acc, int notarget) {
	int res = 0;
	
	if(!type) { 
		if(!acc) // get strength
			res = CheckInventory("PSTAT_Strength");
	}
	else if(type == 1) { // check for accessory
		int tid = ActivatorTID();
		if(!notarget)
			tid = GetActorProperty(0, APROP_TARGETTID);
		
		if(IsAccessoryEquipped(tid, acc))
			res = 1;
	}
	else if(type == 2) { // check for abilities
		if(notarget)
			SetActivator(0, AAPTR_TARGET);
		switch(acc) {
			case 0:
				if(CheckInventory("Ability_Reloader"))
					res = 1;
			break;
			case 1:
				if(CheckInventory("Ability_Arcanery"))
					res = 1;
			break;
		}
	}
	else if(type == 3) { // talents
		if(notarget)
			SetActivator(0, AAPTR_TARGET);
		res = CheckInventory(TalentNames[acc]);
	}
	else if(type == 4) { // dexterity
		if(notarget)
			SetActivator(0, AAPTR_TARGET);
		res = GetDexterity();
	}
	else if(type == 5) { // bulkiness
		if(notarget)
			SetActivator(0, AAPTR_TARGET);
		res = CheckInventory("PSTAT_Bulkiness");
	}
	else if(type == 6) { // gunslinger
		if(notarget)
			SetActivator(0, AAPTR_TARGET);
		res = CheckInventory("DnD_QuestReward_Slot2DmgIncrease");
	}
	else if(type == 7) { // boomsticks
		if(notarget)
			SetActivator(0, AAPTR_TARGET);
		res = CheckInventory("DnD_QuestReward_ShotgunDmgIncrease");
	}
	else if(type == 8) { // super weapons
		if(notarget)
			SetActivator(0, AAPTR_TARGET);
		res = CheckInventory("DnD_QuestReward_SuperWeaponDamage");
	}
	else if(type == 9)
		res = GetActorProperty(0, APROP_TARGETTID);
	SetResultValue(res);
}

Script 919 (void) NET CLIENTSIDE {
	if(!GetCVar("dnd_nofx")) {
		SetFont("SMALLFONT");
		HudMessage(l:"DND_TEXT_SFXOFF"; HUDMSG_FADEINOUT | HUDMSG_LOG, 1, CR_WHITE, 0.5, 0.24, 1.2, 0.5, 0.35);
		SetCVar("dnd_nofx", 1);
	}
	else {
		SetFont("SMALLFONT");
		HudMessage(l:"DND_TEXT_SFXON"; HUDMSG_FADEINOUT | HUDMSG_LOG, 1, CR_GOLD, 0.5, 0.24, 1.2, 0.5, 0.35);
		SetCVar("dnd_nofx", 0);
	}
	Delay(const:5);
}

Script "DND Special FX Handle" OPEN CLIENTSIDE {
	int pnum = ConsolePlayerNumber(); // interesting detail here: open script normally has no activator, but client runs this as soon as they connect so this value matters, not playernumber
	while(PlayerInGame(pnum) || PlayerIsSpectator(pnum)) {
		if(GetCVar("dnd_nofx"))
			Thing_Remove(SPECIAL_FX_TID);
		Delay(const:1);
	}
}

// Added because the above script doesn't work for SP case
Script "DnD Special FX Handle - SP" ENTER CLIENTSIDE {
	if(GameType() != GAME_SINGLE_PLAYER)
		Terminate;
	while(true) {
		if(GetCVar("dnd_nofx"))
			Thing_Remove(SPECIAL_FX_TID);
		Delay(const:1);
	}
}

Script "DnD Remove Check Special" (int sp, int extra) CLIENTSIDE {
	// remove if spectator
	if(!PlayerInGame(ConsolePlayerNumber()))
		Thing_Remove(0);
	else if(!extra) {
		if(ConsolePlayerNumber() != sp - 1)
			Thing_Remove(0);
	}
	else if(extra == DND_SPECIAL_RESEARCH) {
		// research remove depends on if the guy has this research
		// no player check in SP
		if(GameType() != GAME_SINGLE_PLAYER) {
			if(ConsolePlayerNumber() != (sp & 0xFFFF) - 1 || CheckActorResearchStatus(ConsolePlayerNumber() + P_TIDSTART, sp >> 16))
				Thing_Remove(0);
		}
		else if(CheckActorResearchStatus(ConsolePlayerNumber() + P_TIDSTART, sp >> 16))
			Thing_Remove(0);
	}
	else if(extra & (DND_SPECIAL_ORB | DND_SPECIAL_TALENTCAPSULE | DND_SPECIAL_ELIXIR | DND_SPECIAL_CHARM)) {
		if((sp & 0xFFFF) != 256 && ConsolePlayerNumber() != (sp & 0xFFFF) - 1)
			Thing_Remove(0);
		else
			SetActorProperty(0, APROP_ALPHA, 1.0);
	}
}

Script 920 (int mode) {
	if(!mode) {
		SlowPlayer(0, SF_FREEZE, 0);
	}
	else {
		// hacky fix: while this player can load, hold back on fixing player movement
		while(HardcoreSet && PlayerCanLoad[PlayerNumber()])
			Delay(17);
		if(mode == 1) {
			if(!CheckInventory("ShowingMenu")) // don't break menu functionality
				SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
			RestoreRPGStat(RES_PLAYERSPEED);
			TakeInventory("P_Frozen", 1);
		}
		else if(mode == 2) {
			if(!CheckInventory("MinigunFiring"))
				SlowPlayer(0.75, 0, 0);
		}
	}
}

Script 921 (int type, int duration) {
	Delay(duration);
	switch(type) {
		case 0:
			GiveInventory("ChangeReflect", 1);
			TakeInventory("P_Invulnerable", 1);
		break;
		case 1:
			SetPlayerProperty(0, 0, PROP_BUDDHA);
			TakeInventory("P_Invulnerable", 1);
		break;
	}
}

script 922 (int actor_num, int radius, int totalactors) {
     int angle = GetUserVariable(0, "user_angle") * 360; 
     Thing_ChangeTID(0, REFLECTFXTID);
	 SetActivatorToTarget(0);
	 int owner = ActivatorTID();
	 // the below arrangement ensures each and every actor gets a unique TID relative to the owner's tid
	 int newtid =  REFLECTFXTID + ((owner % 100) + 1) * totalactors + actor_num;
	 Thing_ChangeTID(REFLECTFXTID, newtid);
	 
	 int cx = radius * cos(angle) + GetActorX(owner);
	 int cy = radius * sin(angle) + GetActorY(owner);
	 int cz = GetActorZ(owner) + 32.125;
	 
	 SetActorPosition(newtid, cx, cy, cz, 0);
}

// Till 922 are reserved for mons.c

Script "DnD Setup Shootable" (void) {
	if(!ActivatorTID())
		GiveShootableTID();
}

// Monster scaler -- add scaling stuff here
Script "DnD Monster Scale" (int monsterid, int isSummoned) {
	if(!ActivatorTID())
		GiveMonsterTID();
	//printbold(s:"Monster id: ",d:monsterid,s:", (After Spawn) Mob spawn hp:", d:GetActorProperty(0, APROP_SpawnHealth), s:", Mob hp:", d:GetActorProperty(0, APROP_Health), s:", Mob realhp",d:realhp);
	//Make sure mob gets to right amount of hp at this point
	int maxhp, base, add, pcount = PlayerInformationInLevel[PLAYERLEVELINFO_COUNTATSTART], this = ActivatorTID(), realhp = MonsterData[monsterid].health;
	int m_id = this - DND_MONSTERTID_BEGIN;
	if(!pcount)
		pcount = 1;
	
	LoadMonsterTraits(monsterid);
	if(isSummoned)
		MonsterProperties[m_id].trait_list[DND_SUMMONED] = true;
	
	if(GetCVar("dnd_monsterscale")) {
		// scaling code -- delay is because monsters are initialized before enter scripts are executed
		while(DnD_StateChecker[DND_STATECHECK_PLAYERJOIN] < PlayerInformationInLevel[PLAYERLEVELINFO_COUNTATSTART])
			Delay(const:3);
		//This delay needs a check
		//Delay(35); // wait just in case someone leaves, disconnect script will correct the level
		pcount = PlayerInformationInLevel[PLAYERLEVELINFO_COUNTATSTART];
		if(!pcount)
			pcount = 1;
		maxhp = ScaleMonster(pcount, realhp);
	}
	else {
		maxhp = realhp;
		MonsterProperties[m_id].basehp = maxhp;
		MonsterProperties[m_id].maxhp = maxhp;
		MonsterProperties[m_id].level = 1;
	}
	MonsterProperties[m_id].id = monsterid;

	// run elite checks
	if(
		!IsEliteException(m_id, monsterid) && GetCVar("dnd_enable_elites") 																&& 
		RollEliteChance() && PlayerInformationInLevel[PLAYERLEVELINFO_LEVEL] / pcount >= GetCVar("dnd_elite_spawnlevel")				&&
		!IsUniqueMonster(monsterid)
	)
	{
		MonsterProperties[m_id].isElite = true;
		
		//printbold(s:"(Before Elite bonuses) Mob spawn hp:", d:GetActorProperty(0, APROP_SpawnHealth), s:", Mob hp:", d:GetActorProperty(0, APROP_Health), s:", Mob realhp",d:realhp);
		
		// Elite bonuses
		base = maxhp;
		add = base * DND_ELITE_HPSCALE / 100;
		maxhp = base + add;
		MonsterProperties[m_id].basehp = maxhp;
		MonsterProperties[m_id].maxhp = maxhp;
		// roll more traits randomly
		int traitcount = random(DND_MIN_ELITEMODS, DND_MAX_ELITEMODS);
		//printbold(s:"DecideEliteTraits: TID: ", d: ActivatorTID());
		DecideEliteTraits(traitcount);
		// Double Health
		if(MonsterProperties[m_id].trait_list[DND_VITAL]) {
			base = maxhp;
			add = base * DND_ELITE_VITAL_SCALE / 100;
			maxhp = Clamp_Between(base + add, 1, INT_MAX);
			MonsterProperties[m_id].basehp = maxhp;
			MonsterProperties[m_id].maxhp = maxhp;
		}
	}
	
	// sync the decided traits
	ACS_NamedExecuteWithResult(
		"DnD Sync Monster Trait CS", 
		m_id, 
		GetMonsterTraits(m_id, 0),
		GetMonsterTraits(m_id, 1),
		GetMonsterTraits(m_id, 2)
	);
	
	//printbold(s:"(Before dmg) Mob spawn hp:", d:GetActorProperty(0, APROP_SpawnHealth), s:", Mob hp:", d:GetActorProperty(0, APROP_Health), s:", Mob realhp",d:realhp, s:", Mob current hp:", d:maxhp);
	int dmg = GetActorProperty(0, APROP_SpawnHealth) - GetActorProperty(0, APROP_Health);
	SetActorProperty(0, APROP_HEALTH, maxhp);
	
	ScaleMonsterMass(MonsterProperties[m_id].level);
	Clamp_Between(dmg, 0, maxhp + 1);
	Thing_Damage2(ActivatorTID(), dmg, "None");
	//Mob might actually be dead by this point.
	if (GetActorProperty(0, APROP_Health) > maxhp) {
		// In the rare case the mob keeps the very high hp, if some reason SetActorProperty fails.
		// Just kill it
		Thing_Damage2(ActivatorTID(), GetActorProperty(0, APROP_Health) + 1, "None");
		SetResultValue(0);
		Terminate;
	}
	
	// handle all innate resists, weaknesses etc.
	HandleMonsterClassInnates(m_id, monsterid);
	
	// handle things that should be given specifically to certain traits
	HandleSpecialTraits(m_id, monsterid);
	
	GiveInventory("DnD_MonsterSetupDone", 1);
	
	SetResultValue(0);
}

// properties holds stuff like the monster's type, demon, robotic etc.
Script "DnD Custom Monster Scale" (int properties, int traits, int traits2) {
	if(!ActivatorTID())
		GiveMonsterTID();
	int maxhp, base, add, pcount = PlayerCount(), this = ActivatorTID(), realhp = GetActorProperty(0, APROP_SPAWNHEALTH);
	int m_id = this - DND_MONSTERTID_BEGIN;
	if(!pcount)
		pcount = 1;
	if(GetCVar("dnd_monsterscale")) {
		// scaling code -- delay is because monsters are initialized before enter scripts are executed
		while(DnD_StateChecker[DND_STATECHECK_PLAYERJOIN] < PlayerCount())
			Delay(const:3);
		if(!pcount)
			pcount = 1;
		maxhp = ScaleMonster(pcount, realhp);
	}
	else {
		maxhp = realhp;
		MonsterProperties[m_id].basehp = maxhp;
		MonsterProperties[m_id].maxhp = maxhp;
		MonsterProperties[m_id].level = 1;
	}

	MonsterProperties[m_id].id = DND_CUSTOMMONSTER_ID;

	if(GetCVar("dnd_enable_elites") && !MonsterProperties[m_id].trait_list[DND_LEGENDARY] && RollEliteChance() && PlayerInformationInLevel[PLAYERLEVELINFO_LEVEL] / pcount >= GetCVar("dnd_elite_spawnlevel")) {
		MonsterProperties[m_id].isElite = true;

		// Elite bonuses
		base = maxhp;
		add = base * DND_ELITE_HPSCALE / 100;
		maxhp = base + add;
		MonsterProperties[m_id].basehp = maxhp;
		MonsterProperties[m_id].maxhp = maxhp;
		// roll more traits randomly
		int traitcount = random(DND_MIN_ELITEMODS, DND_MAX_ELITEMODS);
		DecideEliteTraits(traitcount);
		// Double Health
		if(MonsterProperties[m_id].trait_list[DND_VITAL]) {
			base = maxhp;
			add = base * DND_ELITE_VITAL_SCALE / 100;
			maxhp = Clamp_Between(base + add, 1, INT_MAX);
			MonsterProperties[m_id].basehp = maxhp;
			MonsterProperties[m_id].maxhp = maxhp;
		}
	}

	int dmg = GetActorProperty(0, APROP_SpawnHealth) - GetActorProperty(0, APROP_Health);
	SetActorProperty(0, APROP_HEALTH, maxhp);
	
	ScaleMonsterMass(MonsterProperties[m_id].level);
	Clamp_Between(dmg, 0, maxhp + 1);
	Thing_Damage2(ActivatorTID(), dmg, "None");
	//Mob might actually be dead by this point.
	if (GetActorProperty(0, APROP_Health) > maxhp) //In the rare case the mob keeps the very high hp
		Thing_Damage2(ActivatorTID(), GetActorProperty(0, APROP_Health) + 1, "None"); //Just kill it
}

// Decide monster to spawn on a certain monster category given weight list
Script "DnD Monster Spawner" (int category) {
    // count and initialization
	int i = 0;
    // add up total count and weight sum of category
    if(!MonsterCategoryData[category][MONSTERDATA_VARIATIONCOUNT]) {
        for(; i < MAX_MONSTER_VARIATIONS && Monster_Weights[category][i] != DND_MWEIGHT_ENDMARKER; MonsterCategoryData[category][MONSTERDATA_WEIGHTSUM] += Monster_Weights[category][i], ++i);
		MonsterCategoryData[category][MONSTERDATA_VARIATIONCOUNT] = i;
	}
		
    int sum = MonsterCategoryData[category][MONSTERDATA_WEIGHTSUM];
    bool picked = false;
    // for each bin, do condition check, see if roll fits in a range
    // wait for the players to enter (returns 0 to imply everyone ready)
    while(PlayerInformationInLevel[PLAYERLEVELINFO_MAXLEVEL] <= 0 || PlayersNotReadyForHardcore())
        Delay(const:10);
	picked = false;
	// throttle the spawns
	if(GameType() != GAME_SINGLE_PLAYER)
		Delay(17 * (random(0, DND_MAX_MONSTERDELAY) + 1)); //Added 1 second for player level to be accurate first (people might load at last second).
	int roll, bin;
	int avg_level = GetAveragePlayerLevel();
	// roll legendary monster chance and do checks of it
	if(!MadeLegendary && category == DND_CYBERDEMONID && random(1, 100) <= Clamp_Between(GetCVar("dnd_legendary_chance"), 1, 100) && avg_level >= 25) {
		MadeLegendary = 1;
		// decide which legendary
		roll = random(1, DND_MAX_LEGENDARY);
		SetActorState(0, StrParam(s:"Leg", d:roll), true);
		ACS_NamedExecuteAlways("DND Announcer", 0, DND_ANNOUNCER_LEGENDARYMONSTER);
	}
	else {
		// check for unique possibility here
		if(!UniqueMonsterAvailability[category] && avg_level >= 25 && random(0, 1.0) <= GetCVar("dnd_uniquemonster_spawnchance")) {
			SetActorState(0, "Unique", true);
			UniqueMonsterAvailability[category] = true;
			Terminate;
		}
	
		int factor = Clamp_Between(GetCVar("dnd_monster_variation_factor"), 1.0, 5.0);
		while(!picked) {
			roll = random(0, sum);
			bin = 0;
			// start i from 0 here, because bin starts from 0 the added weight should be consistent with where we started
			// count is 1 more than the index allowed as is expected, so if it picked the next we must subtract 1 from bin
			for(i = 0; bin < MonsterCategoryData[category][MONSTERDATA_VARIATIONCOUNT] && i < roll; ++bin)
				i += Monster_Weights[category][bin];
			--bin;
			// go to vanilla if bin is 0
			if(!bin) {
				SetActorState(0, "Vanilla", true);
				picked = true;
			}
			else {
				// dumb spawner, just check weight
				if(!GetCVar("dnd_usesmartmonsterspawner")) {
					SetActorState(0, StrParam(s:"Var", d:bin), true);
					picked = true;
				}
				else {
					// investigate later if the bias is proper
					int m_level = Monster_Weights[category][bin] << 16;
					int ratio = FixedDiv(Monster_Weights[category][0] << 16, m_level);
					int bias = random(factor / 5, factor);
					if(ratio <= bias + PlayerInformationInLevel[PLAYERLEVELINFO_MAXLEVEL] * FixedDiv(1.0, ratio) / 5) {
						SetActorState(0, StrParam(s:"Var", d:bin), true);
						picked = true;
					}
				}
			}
		}
	}
}

Script 961 (int type, int amt, int item) {
	if(type == 2)
		SetActorProperty(0, APROP_ALPHA, 0.5);
	else if(type == 3)
		SetActorProperty(0, APROP_ALPHA, 1.0);
	else if(type == 4) {
		if(!item) {
			//MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].traits = amt;
			Log(s:"I shouldn't have been called by ", s:GetActorClass(0));
		}
	}
	else if(type == 5) {
		SetResultValue(GetActorProperty(0, APROP_HEALTH) < MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp >> 1);
	}
	else if(type == 6) {
		// don't judge me, this shit just doesn't work in decorate of zan 3.0...
		Spawn("DarkHealEffectSpawner", GetActorX(0), GetActorY(0), GetActorZ(0));
	}
	else if(type == 7) {
		//printbold(s:"ActivatorTID",d:ActivatorTID(),s:" basehp",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].basehp,s:" maxhp",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp,s:" level",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].level,s:" id",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].id,s:" traits",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].traits,s:" traits2",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].traits2,s:" nameskip",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].nameskip,s:" properties",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].properties);
		amt = MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp;
		if(!amt)
			amt = GetActorProperty(0, APROP_SpawnHealth);
		SetResultValue(amt);
	}
}

// 962 - 969 are in mons.c

script 970 (int type, int actor_num, int radius) CLIENTSIDE {
	int angle, this, owner, cx, cy, cz;
	if(!type) {
		this = ActivatorTID();
		angle = (GetUserVariable(this, "user_angle") * 360) % 1.0;
		owner = GetActorProperty(this, APROP_HEALTH);
		cx = radius * cos(angle) + GetActorX(owner);
		cy = radius * sin(angle) + GetActorY(owner);
		cz = GetActorZ(owner) + 108.0;

		SetActorPosition(this, cx, cy, cz, 0);
	}
	else {
		angle = (GetUserVariable(0, "user_angle") * 360) % 1.0;
		this = ActivatorTID();
		owner = GetActorProperty(this, APROP_HEALTH);
		
		if(CheckInventory("AvatarOnAttack")) {
			angle = (60 * (actor_num - 1)) * 360;
			SetUserVariable(this, "user_angle", 60 * (actor_num - 1));
		}
		
		cx = radius * cos(angle) + GetActorX(owner);
		cy = radius * sin(angle) + GetActorY(owner);
		cz = GetActorZ(owner) + 108.0;
		SetActorPosition(this, cx, cy, cz, 0);
	}
}

// 971 - 972 are in mons.c

Script 973 (int mode) { // Avatar tid / targeter
	if (mode == 1) {
		int owner = ActivatorTID(), curdist;
		
		SetActivator(owner, AAPTR_TARGET);
		int target = ActivatorTID();
		SetActivator(owner);
		
		for(int i = 0; i < AVATAR_SOUL_COUNT; i++) {
			// choose closest target
			curdist = INT_MAX;
			for(int j = 0; j < MAXPLAYERS; j++) {
				int dist = fdistance(owner, P_TIDSTART + j);
				if(GetActorProperty(P_TIDSTART + j, APROP_HEALTH) > 0 && dist < curdist) {
					target = P_TIDSTART + j;
					curdist = dist;
				}
			}
			
			SetActorPosition(owner, GetActorX(owner), GetActorY(owner), GetActorZ(owner) + 56.0, 0);
			SpawnProjectile(owner, "HolyMissile2", GetActorAngle(owner), 128, 0, 0, AVATAR_SOUL_TID);
			SetActorPosition(owner, GetActorX(owner), GetActorY(owner), GetActorZ(owner) - 56.0, 0);
			SetActorPosition(AVATAR_SOUL_TID, GetActorX(AVATAR_SOUL_TID), GetActorY(AVATAR_SOUL_TID), GetActorZ(AVATAR_SOUL_TID) + 54.0, 0);
			SetActivator(AVATAR_SOUL_TID);
			SetPointer(AAPTR_TARGET, owner);
			SetPointer(AAPTR_TRACER, target);
			int dx = GetActorX(target) - GetActorX(AVATAR_SOUL_TID);
			int dy = GetActorY(target) - GetActorY(AVATAR_SOUL_TID);
			SetActorAngle(AVATAR_SOUL_TID, VectorAngle(dx, dy));
			Thing_ChangeTID(AVATAR_SOUL_TID, 0);
			SetActivator(owner);
			Delay(const:12);
		}
	}
	else {
		if(GetActorProperty(0, APROP_HEALTH) < MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp / 3)
			GiveInventory("AcolyteSummoner", 1);
	}
}

// Form the blade vortex
Script 974 (int radius) {
	int tid = ActivatorTID(); // Owner TID
	int newtid = tid + VORTEXTIDSTART + 16 * ((tid + 1) % 100);
	
	for(int m = 0; m < 16; m++)
		Thing_Remove(newtid + m);
	
	int cx, cy, cz;
	cz = GetActorZ(tid) + 26.125;
	int pang = GetActorAngle(tid) >> 8;
	
	// i goes to 16, pang += 16 to complete 256, 360 degrees of doom.
	for(int i = 0; i < 16; ++i) {
		// initial radius is 1/32th of the intended to make all of the blades spawn properly
		cx = GetActorX(tid) + radius*cos(pang<<8)/32;
		cy = GetActorY(tid) + radius*sin(pang<<8)/32;
		pang += 16;
		Spawn("VortexBlade", cx, cy, cz, newtid + i, 0); // Basically, first 1032 are for playernum 0, then a 32 is added and it becomes 1064 etc... Max Value is 3144. (For 64th player)
		SetActivator(newtid + i);
		SetPointer(AAPTR_TARGET, tid);
		SetActivator(tid);
	}
	ACS_executeAlways(975, 0, tid, pang, radius); // Align coords
}

// Constantly rotate the ring
Script 975 (int tid, int pang, int radius) {
	// Create the phase
	int angadd = 0;
	int bladetid = tid + VORTEXTIDSTART + 16 * ((tid + 1) % 100);
	str tocheck = "VortexTimer";
	if(CheckInventory("Ability_Arcanery"))
		tocheck = "VortexTimer2";
	while(true) {
		if(!CheckActorInventory(tid, tocheck) || GetActorProperty(tid, APROP_HEALTH) <= 0) {
			for(int m = 0; m < 16; ++m)
				Thing_Remove(bladetid + m);
			angadd = 0;
			break;
		}
		
		int cx, cy;
		int cz = GetActorZ(tid) + 26.125;
		
		for(int i = 0; i < 16; ++i) {
			pang += 16;
			cx = GetActorX(tid) + radius*cos((pang+angadd)<<8);
			cy = GetActorY(tid) + radius*sin((pang+angadd)<<8);
			SetActorPosition(bladetid + i, cx, cy, cz, 0);
		}
		angadd += 2;
		Delay(const:1);
	}
}

Script "DnD Golgoth Health Check" (void) {
	Delay(const:35);
	int comp = MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp / 2;
	while(GetActorProperty(0, APROP_HEALTH) < comp)
		Delay(const:10);
	GiveInventory("DnD_Boolean", 1);
	GiveInventory("MakeNoPain", 1);
}

Script "DnD Monster Trait Take" (int flag1, int flag2, int flag3, int flag4) {
	int m_tid = ActivatorTID() - DND_MONSTERTID_BEGIN;
	MonsterProperties[m_tid].trait_list[flag1] = false;
	if(flag2 != -1)
		MonsterProperties[m_tid].trait_list[flag2] = false;
	if(flag3 != -1)
		MonsterProperties[m_tid].trait_list[flag3] = false;
	if(flag4 != -1)
		MonsterProperties[m_tid].trait_list[flag4] = false;
	ACS_NamedExecuteWithResult("DnD Monster Trait Take CS", flag1, flag2, flag3, flag4);
	SetResultValue(0);
}

Script "DnD Monster Trait Take CS" (int flag1, int flag2, int flag3, int flag4) CLIENTSIDE {
	int m_tid = ActivatorTID() - DND_MONSTERTID_BEGIN;
	MonsterProperties[m_tid].trait_list[flag1] = false;
	if(flag2 != -1)
		MonsterProperties[m_tid].trait_list[flag2] = false;
	if(flag3 != -1)
		MonsterProperties[m_tid].trait_list[flag3] = false;
	if(flag4 != -1)
		MonsterProperties[m_tid].trait_list[flag4] = false;
	SetResultValue(0);
}

Script "DnD Monster Trait Take - TID" (int tid, int flag1, int flag2, int flag3) {
	int m_tid = tid - DND_MONSTERTID_BEGIN;
	MonsterProperties[m_tid].trait_list[flag1] = false;
	if(flag2 != -1)
		MonsterProperties[m_tid].trait_list[flag2] = false;
	if(flag3 != -1)
		MonsterProperties[m_tid].trait_list[flag3] = false;
	ACS_NamedExecuteWithResult("DnD Monster Trait Take CS", tid, flag1, flag2, flag3);
	SetResultValue(0);
}

Script "DnD Monster Trait Take CS - TID" (int tid, int flag1, int flag2, int flag3) CLIENTSIDE {
	int m_tid = tid - DND_MONSTERTID_BEGIN;
	MonsterProperties[m_tid].trait_list[flag1] = false;
	if(flag2 != -1)
		MonsterProperties[m_tid].trait_list[flag2] = false;
	if(flag3 != -1)
		MonsterProperties[m_tid].trait_list[flag3] = false;
	SetResultValue(0);
}

Script "DnD Monster Trait Take Single" (int tid, int flag) {
	int m_tid = tid - DND_MONSTERTID_BEGIN;
	MonsterProperties[m_tid].trait_list[flag] = false;
	ACS_NamedExecuteWithResult("DnD Monster Trait Take Single CS", tid, flag);
	SetResultValue(0);
}

Script "DnD Monster Trait Take Single CS" (int tid, int flag) CLIENTSIDE {
	int m_tid = tid - DND_MONSTERTID_BEGIN;
	MonsterProperties[m_tid].trait_list[flag] = false;
	SetResultValue(0);
}

Script "DnD Monster Trait Give" (int flag1, int flag2, int flag3, int flag4) {
	int m_tid = ActivatorTID() - DND_MONSTERTID_BEGIN;
	MonsterProperties[m_tid].trait_list[flag1] = true;
	if(flag2 != -1)
		MonsterProperties[m_tid].trait_list[flag2] = true;
	if(flag3 != -1)
		MonsterProperties[m_tid].trait_list[flag3] = true;
	if(flag4 != -1)
		MonsterProperties[m_tid].trait_list[flag4] = true;
	ACS_NamedExecuteWithResult("DnD Monster Trait Give CS", flag1, flag2, flag3, flag4);
	SetResultValue(0);
}

Script "DnD Monster Trait Give CS" (int flag1, int flag2, int flag3, int flag4) CLIENTSIDE {
	int m_tid = ActivatorTID() - DND_MONSTERTID_BEGIN;
	MonsterProperties[m_tid].trait_list[flag1] = true;
	if(flag2 != -1)
		MonsterProperties[m_tid].trait_list[flag2] = true;
	if(flag3 != -1)
		MonsterProperties[m_tid].trait_list[flag3] = true;
	if(flag4 != -1)
		MonsterProperties[m_tid].trait_list[flag4] = true;
	SetResultValue(0);
}

Script "DnD Monster Trait Give Single" (int tid, int flag) {
	int m_tid = tid - DND_MONSTERTID_BEGIN;
	MonsterProperties[m_tid].trait_list[flag] = true;
	ACS_NamedExecuteWithResult("DnD Monster Trait Give Single CS", tid, flag);
	SetResultValue(0);
}

Script "DnD Monster Trait Give Single CS" (int tid, int flag) CLIENTSIDE {
	int m_tid = tid - DND_MONSTERTID_BEGIN;
	MonsterProperties[m_tid].trait_list[flag] = true;
	SetResultValue(0);
}

// Checks Ankh
Script "DnD Ankh Checker" (void) {
	int pnum = PlayerNumber();
	while(PlayerInGame(pnum)) {
		if(!CheckInventory("ParsingData")) {
			// ankh check
			if(!CheckInventory("P_Invulnerable") && GetActorProperty(0, APROP_HEALTH) == 1 && !CheckInventory("Intervened") && IsAccessoryEquipped(ActivatorTID(), DND_ACCESSORY_ANGELICANKH) && CheckInventory("CanIntervene")) {
				GiveInventory("Intervention", 1);
				GiveInventory("Intervened", 1);
				TakeInventory("CanIntervene", 1);
				GiveInventory("InterventionFXSpawner", 1);
				GiveInventory("P_Invulnerable", 1);
				ACS_ExecuteAlways(921, 0, 1, INTERVENTION_DURATION);
			}
		}
		Delay(const:5);
	}
}

Script "DnD Player Levelup Check" (void) {
	HandleLevelup();
}

// Weapon tip display
Script 977 (int type, int itemnum) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
	    Terminate;
	if(!type && !CheckInventory("ParsingData")) { // weapon tip
		str text = GetWeaponTipText(itemnum);
		int len = StrLen(StrParam(l:text));
		
		LocalAmbientSound("Weapon/Popup", 127);
		SetHudSize(640, 480, 1);
		
		if(len < 120) {
			SetFont("MSGBOXX");
			len = 0;
		}
		else if(len < 240) {
			SetFont("MSGBOX2");
			len = 0;
		}
		else {
			SetFont("MSGBOX3");
			len = 64;
		}
		
		int hud_pos = (GetHudRight(640) << 16) - QSTBOX_XF / 2 + 0.4;
		HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVEID, CR_UNTRANSLATED, hud_pos, 48.1, 4.0, 1.0, 1.0);
		SetFont(Weapons_Data[itemnum][WEAPON_ICON]);
		HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVEICO, CR_UNTRANSLATED, hud_pos + 16.0, 64.0, 4.0, 1.0, 1.0);
		SetFont("OBJFONT");
		HudMessage(d:GetGameSlotOfWeapon(itemnum); HUDMSG_FADEINOUT, SURVIVETOPTEXTID, CR_GOLD, hud_pos - 99.0, 70.0, 4.0, 1.0, 1.0);

		hud_pos = (GetHudRight(960) << 16) - 3 * QSTBOX_XF / 2 + 42.1;
		SetHudSize(960, 600, 1);
		SetHudClipRect(hud_pos >> 16, 96, 320, 128 + len, 320);
		HudMessage(l:text; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 104.1, 4.0, 1.0, 1.0);
		SetHudClipRect(0, 0, 0, 0);
	}
}

// Checking for Bonuses
Script "DnD Bonus Detect" OPEN {
	int KillBonus, ItemBonus, SecretBonus, BonusBonus;
	int curkills, curitems, cursecrets, bonusval;
	Delay(const:35);

	while(true) {
		if(!GetCVar("dnd_disablelevelbonus")) {
			curkills = GetLevelInfo(LEVELINFO_KILLED_MONSTERS);
			curitems = GetLevelInfo(LEVELINFO_FOUND_ITEMS);
			cursecrets = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
			
			if(GetLevelInfo(LEVELINFO_TOTAL_MONSTERS)) {
				if(!KillBonus && curkills >= GetLevelInfo(LEVELINFO_TOTAL_MONSTERS)) {
					DistributeBonus(BONUS_KILL);
					KillBonus = 1;
				}
			}
			else
				KillBonus = 2; // means there were no monsters at all

			if(GetLevelInfo(LEVELINFO_TOTAL_ITEMS)) {
				if(!ItemBonus && curitems >= GetLevelInfo(LEVELINFO_TOTAL_ITEMS)) {
					DistributeBonus(BONUS_ITEM);
					ItemBonus = 1;
				}
			}
			else
				ItemBonus = 2; // means there were no items at all
			
			if(GetLevelInfo(LEVELINFO_TOTAL_SECRETS)) { // if there are some secrets
				if(!SecretBonus && cursecrets >= GetLevelInfo(LEVELINFO_TOTAL_SECRETS)) {
					DistributeBonus(BONUS_SECRET);
					SecretBonus = 1;	
				}
			}
			else
				SecretBonus = 2;
			
			// if there was at least some bonus involved!
			if(KillBonus && ItemBonus && SecretBonus && !BonusBonus && (KillBonus + ItemBonus + SecretBonus != 6)) {
				Delay(4);
				DistributeBonus(BONUS_BONUS);
				BonusBonus = 1;
			}
		}
		Delay(const:17);
	}
}

Script "DnD Bonus Message State" (int bonustype) CLIENTSIDE {
	for(int i = 0; i < DND_BONUS_SCREENTIME; ++i)
		Delay(const:35);
	DnD_StateChecker[bonustype + 1] = 0;
};

Script "DnD Bonus Message Show" (int bonustype) CLIENTSIDE {
	// add 1 to skip playerjoin state
	ACS_NamedExecuteAlways("DnD Bonus Message State", 0, bonustype);
	Delay(bonustype + 1);
	DnD_StateChecker[bonustype + 1] = 1;
	int y = DnD_BonusMessageY(bonustype);
	ShowBonusMessage(bonustype, y);
}

Script "DnD Monster Scanner Picker" (void) {
	int this = ActivatorTID();
	while(isActorAlive(this)) {
		SetActivatorToTarget(this);
		
		int montid = ActivatorTID();
		int m_id = 0;
		int healthbarcolor = 0;
		
		if(montid == this || CheckInventory("EnemyInDisguise")) {
			// player has no targets
			SetActivator(this);
			SetInventory("TargetMaximumHealth", 0);
			SetInventory("TargetCurrentHealth", 0);
			SetInventory("TargetHealthBarColor", 0);
			SetInventory("TargetLevel", 0);
			SetInventory("TargetIsWhat", 0);
			SetInventory("TargetIsElite", 0);
			SetInventory("TargetFortify", 0);
		}
		else {
			if(!CheckInventory("EnemyInDisguise") && (CheckActorProperty(0, APROP_Friendly, 0) || CheckInventory("FriendlyInDisguise")))
				healthbarcolor = 1;
			else if(CheckActorProperty(0, APROP_Friendly, 1) || CheckInventory("EnemyInDisguise"))
				healthbarcolor = 0;
			
			// manipulate player stuff now
			SetActivator(this);
			
			// this part retrieves data from server
			// if not a pet
			bool pet_state = IsPet(montid);
			if(!pet_state) {
				// this part uses the inventory method to avoid having to constantly sync variables between clients
				m_id = montid - DND_MONSTERTID_BEGIN;
				SetInventory("TargetMaximumHealth", MonsterProperties[m_id].maxhp);
				SetInventory("TargetLevel", MonsterProperties[m_id].level);
				SetInventory("TargetIsWhat", MonsterProperties[m_id].id);
				SetInventory("TargetIsElite", MonsterProperties[m_id].isElite);
				SetInventory("TargetFortify", CheckActorInventory(montid, "MonsterFortifyCount"));
			}
			else {
				// this part uses the inventory method to avoid having to constantly sync variables between clients
				m_id = montid - DND_PETTID_BEGIN;
				SetInventory("TargetMaximumHealth", PetMonsterProperties[m_id].maxhp);
				SetInventory("TargetLevel", PetMonsterProperties[m_id].level);
				SetInventory("TargetIsWhat", PetMonsterProperties[m_id].id);
				SetInventory("TargetIsElite", PetMonsterProperties[m_id].isElite);
				SetInventory("TargetFortify", CheckActorInventory(montid, "MonsterFortifyCount"));
			}
			SetInventory("TargetTID", montid);
			SetInventory("TargetMonId", m_id);
			SetInventory("TargetHealthBarColor", healthbarcolor);
			SetInventory("TargetCurrentHealth", GetActorProperty (montid, APROP_Health));
			
			SetCVarString(Strparam(s:"DND_NAMETAGS", i:PlayerNumber()), GetActorProperty(montid, APROP_NAMETAG));
			
			// fixes initialization bug
			SetActivator(this);
		}
		Delay(const:2);
	}
	SetResultValue(0);
}

// takes flag segments
Script "DnD Sync Monster Trait CS" (int m_id, int v1, int v2, int v3) CLIENTSIDE {
	// get all of the flagsets now
	int i;
	if(v1) {
		for(i = 0; i < 32; ++i)
			MonsterProperties[m_id].trait_list[i] = IsSet(v1, i);
		MonsterProperties[m_id].hasTrait = true;
	}
	
	if(v2) {
		for(i = 32; i < 64; ++i)
			MonsterProperties[m_id].trait_list[i] = IsSet(v2, i - 32);
		MonsterProperties[m_id].hasTrait = true;
	}

	if(v3) {
		for(i = 64; i < MAX_MONSTER_TRAITS; ++i)
			MonsterProperties[m_id].trait_list[i] = IsSet(v3, i - 64);
		MonsterProperties[m_id].hasTrait = true;
	}
	SetResultValue(0);
}

Script "DnD Sync Pet Monster Trait CS" (int id, int v1, int v2, int v3) CLIENTSIDE {
	int m_id = id - DND_PETTID_BEGIN;
	
	// get all of the flagsets now
	int i;
	if(v1) {
		for(i = 0; i < 32; ++i)
			PetMonsterProperties[m_id].trait_list[i] = IsSet(v1, i);
		PetMonsterProperties[m_id].hasTrait = true;
	}
	
	if(v2) {
		for(i = 32; i < 64; ++i)
			PetMonsterProperties[m_id].trait_list[i] = IsSet(v2, i - 32);
		PetMonsterProperties[m_id].hasTrait = true;
	}

	if(v3) {
		for(i = 64; i < MAX_MONSTER_TRAITS; ++i)
			PetMonsterProperties[m_id].trait_list[i] = IsSet(v3, i - 64);
		PetMonsterProperties[m_id].hasTrait = true;
	}
	
	SetResultValue(0);
}

Script "DnD Monster Scanner" (void) CLIENTSIDE {
	int mmaxhp, monhp, monlevel, monid, mon_tid, m_id;
	int hdisp, fortify_amt;
	int hdisp_prev = -1, fortify_amt_prev = -1;	
	str barGraphic = "";
	str fortGraphic = "";
	bool mon_isPet = false;
	
	while(isAlive()) {
		// disable during intermission
		if(CheckInventory("DnD_IntermissionState"))
			break;
	
		// if we have any shared items in our player queue to turn, do turn them
		mmaxhp = CheckInventory("TargetMaximumHealth");
		if(mmaxhp && GetCVar("dnd_monsterbars")) {
			monhp = CheckInventory("TargetCurrentHealth");
			monlevel = CheckInventory("TargetLevel");
			mon_tid = CheckInventory("TargetTID");
			monid = CheckInventory("TargetIsWhat");
			m_id = CheckInventory("TargetMonId");
			hdisp = (monhp * 100 / mmaxhp);
			// clamp to 100 on certain monsters' overheal abilities (Warmaster for example)
			if(hdisp > 100)
				hdisp = 100;
			fortify_amt = (CheckInventory("TargetFortify") * 100 / mmaxhp);
			int i, j;
			
			SetHudSize(800, 600, 0);
			SetFont(MonsterTypeInfo[GetMonsterType(monid)][MONSTER_TYPE_INFO_ICON]);	
			HudMessage(s:"a"; HUDMSG_FADEOUT, MONSTER_TYPEICONID, CR_UNTRANSLATED, 270.0, 27.0, MONSTERINFO_HOLDTIME);
			HudMessage(s:"a"; HUDMSG_FADEOUT, MONSTER_TYPEICONID_RIGHT, CR_UNTRANSLATED, 540.0, 27.0, MONSTERINFO_HOLDTIME);
			// inner text
			SetFont ("MONFONT");
			HudMessage(l:"DND_STAT18_SHORT", s:": ", i:monlevel, s:"  ", i:monhp, s:"/", i:mmaxhp; HUDMSG_FADEOUT, MONSTER_TEXTID, CR_WHITE, 400.0, 27.0, MONSTERINFO_HOLDTIME);
			
			bool is_unique = 0;
			mon_isPet = IsPet(mon_tid);
			
			if(!mon_isPet) {
				is_unique = IsUniqueMonster(monid);
				str prefix = "";
				if(CheckInventory("TargetIsElite"))
					prefix = StrParam(s:"\cf", l:"DND_ELITE", s:" ");
				if(MonsterProperties[m_id].trait_list[DND_LEGENDARY])
					HudMessage(s:prefix, s:GetCVarString(Strparam(s:"DND_NAMETAGS", i:PlayerNumber())); HUDMSG_FADEOUT, MONSTER_NAMEID, CR_RED, 404.4, 10.0, MONSTERINFO_HOLDTIME);
				else if(is_unique)
					HudMessage(s:prefix, s:GetCVarString(Strparam(s:"DND_NAMETAGS", i:PlayerNumber())); HUDMSG_FADEOUT, MONSTER_NAMEID, CR_RED, 404.4, 10.0, MONSTERINFO_HOLDTIME);
				else if(IsMonsterIdBoss(monid))
					HudMessage(s:prefix, s:GetCVarString(Strparam(s:"DND_NAMETAGS", i:PlayerNumber())); HUDMSG_FADEOUT, MONSTER_NAMEID, CR_ORANGE, 404.4, 10.0, MONSTERINFO_HOLDTIME);
				else
					HudMessage(s:prefix, s:GetCVarString(Strparam(s:"DND_NAMETAGS", i:PlayerNumber())); HUDMSG_FADEOUT, MONSTER_NAMEID, CR_WHITE, 404.4, 10.0, MONSTERINFO_HOLDTIME);
			}
			else
				HudMessage(s:prefix, s:GetCVarString(Strparam(s:"DND_NAMETAGS", i:PlayerNumber())); HUDMSG_FADEOUT, MONSTER_NAMEID, CR_WHITE, 404.4, 10.0, MONSTERINFO_HOLDTIME);
			
			// made this way to reduce variable dependancy and if statement use
			if(CheckInventory("TargetHealthBarColor")) {
				if(!is_unique)
					SetFont("MNRHPBAR");
				else
					SetFont("MNUHPBAR");
				HudMessage(s:"a"; HUDMSG_FADEOUT, MONSTER_BARID, CR_UNTRANSLATED, 400.0, 27.0, MONSTERINFO_HOLDTIME);
				
				if(monhp) {
					if(fortify_amt) {
						if(fortify_amt_prev != fortify_amt)
							fortGraphic = StrParam(s:"FFR_", d:fortify_amt);
					
						SetFont(fortGraphic);
						HudMessage(s:"a"; HUDMSG_FADEOUT, MONSTER_BARFILLID, CR_GREEN, 305.1, 27.0, MONSTERINFO_HOLDTIME);
						
						if(hdisp > 0) {
							if(hdisp_prev != hdisp)
								barGraphic = StrParam(s:"FBR_", d:hdisp);
								
							SetFont(barGraphic);
							HudMessage(s:"a"; HUDMSG_FADEOUT, MONSTER_BARFILLOVERLAY, CR_GREEN, 305.1, 27.0, MONSTERINFO_HOLDTIME);
						}
					}
					else {
						if(hdisp > 0) {
							if(hdisp_prev != hdisp)
								barGraphic = StrParam(s:"FBR_", d:hdisp);

							SetFont(barGraphic);
							HudMessage(s:"a"; HUDMSG_FADEOUT, MONSTER_BARFILLID, CR_GREEN, 305.1, 27.0, MONSTERINFO_HOLDTIME);
						}
					}
				}
			}
			else {
				SetFont("MNGHPBAR");
				HudMessage(s:"a"; HUDMSG_FADEOUT, MONSTER_BARID, CR_UNTRANSLATED, 400.0, 27.0, MONSTERINFO_HOLDTIME);
				
				if(hdisp > 0) {
					if(hdisp_prev != hdisp)
						barGraphic = StrParam(s:"FGR_", d:hdisp);
					
					SetFont(barGraphic);
					HudMessage(s:"a"; HUDMSG_FADEOUT, MONSTER_BARFILLID, CR_GREEN, 305.1, 27.0, MONSTERINFO_HOLDTIME);
				}
			}

			i = j = 0;
			// show monster traits
			// legendary monsters show no traits at all
			if(!mon_isPet) {
				if(MonsterProperties[m_id].trait_list[DND_LEGENDARY]) {
					SetFont ("MONFONT");
					HudMessage(s:"\c[D1]", l:"DND_EMOD_LEGENDARY_LONG"; HUDMSG_FADEOUT, MONSTER_TRAITID + j, CR_WHITE, 404.4, 44.0 + 8.0 * j, MONSTERINFO_HOLDTIME);
				}
				else if(MonsterProperties[m_id].trait_list[DND_MARKOFCHAOS]) {
					SetFont ("MONFONT");
					HudMessage(s:"\c[D1]", l:"DND_EMOD_MARKOFCHAOS_NOCOL"; HUDMSG_FADEOUT, MONSTER_TRAITID + j, CR_WHITE, 404.4, 44.0 + 8.0 * j, MONSTERINFO_HOLDTIME);
				}
				else if(MonsterProperties[m_id].hasTrait) {
					SetFont ("MONFONT");
					for(i = 0; i < MAX_MONSTER_TRAITS; ++i) {
						if(MonsterProperties[m_id].trait_list[i]) {
							HudMessage(l:GetMonsterTraitLabel(i); HUDMSG_FADEOUT, MONSTER_TRAITID + j, CR_WHITE, 404.4, 44.0 + 8.0 * j, MONSTERINFO_HOLDTIME);
							++j;
						}
					}
				}
			}
			else if(PetMonsterProperties[m_id].hasTrait) {
				SetFont ("MONFONT");
				for(i = 0; i < MAX_MONSTER_TRAITS; ++i) {
					if(PetMonsterProperties[m_id].trait_list[i]) {
						HudMessage(l:GetMonsterTraitLabel(i); HUDMSG_FADEOUT, MONSTER_TRAITID + j, CR_WHITE, 404.4, 44.0 + 8.0 * j, MONSTERINFO_HOLDTIME);
						++j;
					}
				}
			}
		}
		else {
			hdisp = -1;
			fortify_amt = -1;
		}
		Delay(const:2);
		
		fortify_amt_prev = fortify_amt;
		hdisp_prev = hdisp;
	}
}

// This is mostly similar to zdoom source with some changes (I believe)
Script "DnD Monster Kill Ice Chunks" (int r, int h) CLIENTSIDE {
	int numChunks = Max(5, (r * h) / 32);
	for(int i = Max(24, numChunks + Random(0, numChunks / 4 - 1)); i >= 0; --i) {
		int xo = GetActorX(0) + r * random(-1.0, 1.0);
		int yo = GetActorY(0) + r * random(-1.0, 1.0);
		int zo = GetActorZ(0) + h * random(0, 1.0);

		SpawnForced("IceChunkCS", xo, yo, zo, DND_ICECHUNK_TID);
		SetActorVelocity(DND_ICECHUNK_TID, random(-1.0, 1.0), random(-1.0, 1.0), ((zo - GetActorZ(0)) / h) * 4, 0, 0);
		Thing_ChangeTID(DND_ICECHUNK_TID, 0);
	}

	SetResultValue(0);
}

// Calculate chance of item drop, drop if needed (out of 100)
Script "DnD Item Dropchance" (int basechance) {
	SetActivatorToTarget(0);
	basechance <<= 16;
	basechance /= 100;
	SetResultValue(RunDefaultDropChance(ActivatorTID() - P_TIDSTART, CheckInventory("MonsterIsElite"), basechance));
}

// Some Generic Chat Log Script
Script "DnD Message Logger" (int type, int id, int id_is_special) CLIENTSIDE {
	if(PlayerNumber() != ConsolePlayerNumber()) Terminate;
	if(!type)
		Log(s:"\cc", l:"DND_PICKUP_WEAPON", s:": \c[Y5]", s:TemporaryWeaponData[id - TEMPBEGIN][TEMPWEP_TAG], s:" - 9\c-");
	else if(type == 1) {
		id = MapClassicWeaponToTableID(id);
		Log(s:"\cc", l:"DND_PICKUP_WEAPON", s:": \c[Y5]", l:GetWeaponTag(id), s:" - ", d:GetGameSlotOfWeapon(id), s:"\c-");
	}
    else if(type == 2) {
		if(id_is_special)
			Log(s:"\cc", l:"DND_PICKUP_RESEARCH", s:": \c[Y5]", l:"DND_PICKUP_DISCOVERED", s:" ", l:GetResearchLabel(id >> 16), s:"!");
		else
			Log(s:"\cc", l:"DND_PICKUP_RESEARCH", s:": \c[Y5]", l:"DND_PICKUP_DISCOVERED", s:" ", l:GetResearchLabel(id), s:"!");
	}
	else if(type == 3)
		HandleSharedItemPickupMessage(id);
	else if(type == 4)
		Log(s:"\cc", l:"DND_PICKUP_HEALTH", s:": \c[Y5]", l:"DND_PICKUP_DEMONESSENCE");
	else
		Log(s:ChestKeyText[id]);
}

// Pickup check for the temporary weapons
Script 986 (int wepnum, int type) {
	int who = ActivatorTID();
	if(type) {
		SetActivatorToTarget(0);
		who = ActivatorTID();
	}
	wepnum -= TEMPBEGIN;
	int t = 0;
	for(int i = 0; i < MAXTEMPWEPS; ++i) {
		if(i == wepnum) {   
			// do we have max ammo on this weapon
			if(CheckActorInventory(who, TemporaryWeaponData[i][TEMPWEP_AMMO]) == GetAmmoCapacity(TemporaryWeaponData[i][TEMPWEP_AMMO]))
			  ++t;
		}
		else if(CheckActorInventory(who, TemporaryWeaponData[i][TEMPWEP_NAME])) { // do I have any temp weapon
			if(!CheckActorInventory(who, TemporaryWeaponData[i][TEMPWEP_AMMO])) // hack to prevent a desync problem
				TakeActorInventory(who, TemporaryWeaponData[i][TEMPWEP_NAME], 1);
			else
				++t;
		}
	}
	SetResultValue(!t);
}

Script "DnD On Respawn" RESPAWN {
	Thing_ChangeTID(0, P_TIDSTART + PlayerNumber());
	TakeInventory("PowerReflection", 1);
	TakeInventory("DnD_PDead", 1);
	SetInventory("PlayerIsLeeching", 0);
	RestoreRPGStat(RES_ACCURACY | RES_EXPLOSIONRADIUS | RES_ALLRESISTS);
	ACS_NamedExecuteAlways("DnD Health Pickup", 0, 100, 4); // full heal
	
	// run the monster scanner script again on respawn
	ACS_NamedExecuteWithResult("DnD Monster Scanner Picker");
	ACS_NamedExecuteAlways("DnD Monster Scanner", 0);
	
	ACS_NamedExecuteAlways("DnD SBAR", 0);
	
	// if game mode is coop, we don't want any sort of reset on death here! make sure it's not coop
	/*if(GetCVar("Survival")) {
		if(CheckInventory("CurrentLives"))
			TakeInventory("CurrentLives", 1);
		else {
			Reset_RPGInfo(RESET_LEVEL | RESET_CREDIT | RESET_STATS | RESET_PERKS);
			StatListOpened[PlayerNumber()] = 0;
			ResetWeaponMods(PlayerNumber());
			ResetPlayerBonuses(PlayerNumber());
		}
	}*/
	
	// for properly setting up taltos translucency when spawn protection is on
	while(GetActorProperty(0, APROP_INVULNERABLE) && !CheckInventory("P_Invulnerable"))
		Delay(const:5);
	if(CheckInventory("TaltosUp"))
		GiveInventory("TaltosEffect", 1);
		
	ACS_NamedExecuteAlways("DnD Punisher Perk50 Display", 0, true);
}

Script 988 (int wepslot, int type) {
	int res = 0;
	if(!type) {
		if(CheckSlotWeapon(wepslot))
			res = 1;
	}
	else if(type == 1) {
		if(GetCVar("sv_weaponstay"))
			res = 1;
	}
	SetResultValue(res);
}

// Clear upon leaving
Script "DnD On Disconnect" (int pnum) DISCONNECT {
	//Just to make sure a rare lvl 1 char load bug doesn't happen
	PlayerWillBeSaved[pnum] = false;
	PlayerTransferred[pnum] = false;

	ACS_NamedExecuteAlways("DnD Class Select Cleanup", 0);
	// if someone quit during countdown just remove this
	HudMessage(s:""; HUDMSG_PLAIN, DND_HARDCORE_SCREENID, CR_RED, 320.0, 240.0, 1);
	StatListOpened[pnum] = 0;
	PlayerCanLoad[pnum] = 0;
	BreakTradesBetween(pnum);
	
	// if player was in middle of saving, don't accidently interfere if player leaves early
	// save accumulated stats when player leaves
	// things saved are in DnD_Activity.h
	ACS_NamedExecuteWithResult("DnD Save Player Activities", pnum, true);
	PlayerDied[pnum] = 0;
}

// End of level checks
Script "DnD On Unloading" UNLOADING {
	int tid;
	MapInfo[DND_MAPINFO_MAPCHANGED] = true;
	//Field items are global, but new items simply replace old ones no questions asked, so no need to clear this.
	//ResetFieldInventory();
	BreakAllTrades();
	for(int i = 0; i < MAXPLAYERS; ++i) {
		if(!PlayerInGame(i))
			continue;
			
		tid = P_TIDSTART + i;
		// Now using PlayerWillBeSaved, because some servers might use multiple lives setting.
		// if hardcore modes are set, check this, otherwise simply give the player the things if they managed to survive the level regularly
	    if(((PlayerWillBeSaved[i] && HardcoreSet) || !HardcoreSet) && GetActorProperty(tid, APROP_HEALTH) > 0) { 
		    GiveActorInventory(tid, "LevelToken", 1);
			StatListOpened[i] = 0;
            GiveActorInventory(tid, "Budget", (1 + HardcoreSet) * ((MapDifficulty + 1) + DND_BUDGET_BASE));
			GiveActorInventory(tid, "RoundsSurvived", 1);
		}
		// Check quests
		if(active_quest_id != -1)
			CheckMapExitQuest(i, active_quest_id);
	}
}

// Enter level checks
Script "DnD Player Setup" ENTER {
	ACS_NamedExecuteAlways("DnD Class Select Cleanup", 0);
	Thing_ChangeTID(0, P_TIDSTART + PlayerNumber());
	SetInventory("SphereMade", 0);
	SetInventory("OrbUseType", 0);
	SetInventory("OrbResult", 0);
	// reset anything related to kill sprees on entering a new map
	SetInventory("SpreeXP", 0);
	SetInventory("DnD_SpreeTimer", 0);
	SetInventory("DnD_SpreeCountdownRunning", 0);
	SetInventory("DnD_MultikillCounter", 0);
	SetInventory("LevelExp", 0);
	SetInventory("LevelCredit", 0);
	
	ClearLingeringBuffs();
	
	// statistics reset
	SetInventory("DnD_Kills", 0);
	ResetStatistics();
	
	// now everyone has this, no need to buy
	GiveInventory("Ability_MonsterInfo", 1);
	CleanPetStuff();
	//SetInventory("MapDifficultyClientside", MapDifficulty); //Already to be set somewhere else.
	SetInventory("DnD_MasterHealerQuest_HealAmount", 0); // reset this upon map restart
	SetInventory("DnD_BoughtArmor", 0);
	int pnum = PlayerNumber(), curlvl, i = 0;
	int temp = 0;
	bool wait_other_players = false;
	SetInventory("PlayersNotReady", PlayerCount());
	SetInventory("PlayerIsLoggedIn", PlayerIsLoggedIn(pnum)); //Only used to let player know if he's logged in at start (clientside doesn't have this function).
	GiveInventory("ParsingData", 1);
	ResetAllSpellCooldowns(); // reset all leftover cooldowns
	
	// scanner runner
	ACS_NamedExecuteWithResult("DnD Monster Scanner Picker");
	ACS_NamedExecuteAlways("DnD Monster Scanner", 0);
	ACS_NamedExecuteAlways("DnD SBAR", 0);
	
	// begin hardcore countdown
	if(HardcoreSet && (GetCVar("dnd_mode") >= DND_MODE_SOFTCORE)) {
		GiveInventory("P_Frozen", 1);
		GiveInventory("DontAttack", 1);
		while(GetGameModeState() == GAMESTATE_COUNTDOWN)
			Delay(const:17);
		SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
		SetPlayerProperty(0, 2, PROP_INVULNERABILITY);

		PlayerWillBeSaved[pnum] = true;
		// display countdown timer
		if (!PlayerLoaded[pnum]) {
			PlayerCanLoad[pnum] = 1;
			SetInventory("CanLoad", 1);
			
			ResetPlayerItems(pnum);
			
			// the above reset actual items of player, the below resets variables used to denote inventories and such
			ResetPlayerInfo(pnum);
			
			ACS_NamedExecuteAlways("DND Hardcore Timer", 0);
		}
		else
			PlayerCanLoad[pnum] = 0; //it's in else part, because loop might end early otherwise.
		
		// 0 means they are ready
		int players_not_ready = PlayersNotReadyForHardcore();
		i = 0;
		temp = Clamp_Between(GetCVar("dnd_loadtime"), DND_HARDCORE_LOADTIME, 100) << 1;
		while(players_not_ready && i < temp && PlayerInGame(pnum)) {
			//Update logged in status to client as needed by hardcode timer.
			if (CheckInventory("PlayerIsLoggedIn") != PlayerIsLoggedIn(pnum))
				SetInventory("PlayerIsLoggedIn", PlayerIsLoggedIn(pnum));
			// we loaded, reduce on wait time
			if(!CheckInventory("CanLoad")) {
				PlayerCanLoad[pnum] = 0;
				// message the players to wait for an amount of players to ready up (also update not ready count)
				players_not_ready = PlayersNotReadyForHardcore();
				if (players_not_ready > 0) //This is actually possible, even here!
					ACS_NamedExecuteAlways("DND Wait For Other Players Message", 0, players_not_ready);
			}
			++i;
			if ((i == temp) && PlayerIsLoggedIn(pnum) && CheckInventory("CanLoad"))
				if (ACS_NamedExecuteWithResult("DnD Load Character Check", pnum, 0) == 11) //DND_CHARLOADED
					ACS_ExecuteAlways(1001,0,0);
				else if (ACS_NamedExecuteWithResult("DnD Create Character Check", pnum, 0) == 1) //DND_LOGIN_CREATECHAROK
					ACS_ExecuteAlways(1003,0,0);
			Delay(const:TICRATE / 2);
		}
	}
	
	if(!PlayerInGame(pnum)) {
		PlayerCanLoad[pnum] = 0;
		Terminate;
	}
	SetInventory("PlayersNotReady", 0);
	
	++DnD_StateChecker[DND_STATECHECK_PLAYERJOIN];
	
	// Checks if we should set the lives to the inventory or not (also includes one time execute things)
	// when player joins for the first time - when loading char, this section gets skipped
	if(CheckInventory("SetMyLives")) {
		// can only reflect once per map
		SetInventory("ReflectCount", 0);
		SetInventory("Intervened", 0);
		SetInventory("CanIntervene", 1);
		TakeInventory("SetMyLives", 1);
		SetInventory("ShowingMenu", 0);
		SetInventory("ShowingPrompt", 0);
		Reset_RPGInfo(RESET_LEVEL | RESET_CREDIT | RESET_STATS | RESET_PERKS);
		StatListOpened[pnum] = 0;
		GiveInventory(" Fists ", 1);
		GiveInventory(" Pistol ", 1);
		if(GetCVar("dnd_allresearchesfound"))
			GiveAndDoAllResearch();
		ACS_NamedExecuteAlways("DND Menu Cleanup", 0, pnum);
	}
	
	if(PlayerInGame(pnum)) {
		curlvl = GetStat(STAT_LVL);
		PlayerInformationInLevel[PLAYERLEVELINFO_LEVEL] += curlvl;
		++PlayerInformationInLevel[PLAYERLEVELINFO_COUNTATSTART];
		if(PlayerInformationInLevel[PLAYERLEVELINFO_MAXLEVEL] < curlvl)
			PlayerInformationInLevel[PLAYERLEVELINFO_MAXLEVEL] = curlvl;
		if(PlayerInformationInLevel[PLAYERLEVELINFO_MINLEVEL] > curlvl)
			PlayerInformationInLevel[PLAYERLEVELINFO_MINLEVEL] = curlvl;
	}
	
	ClearQuestCheckers();
	
	PostPlayerLoadRoutine(pnum);
	
	if(HardcoreSet) {
		ACS_NamedExecuteAlways("DND Hardcore Monster Message", 0);
		// wait for monsters to appear
		Delay(17 * (DND_MAX_MONSTERDELAY + 2));
	}
	
	UnfreezePlayer();
	
	// if map changed, reset accessory stuff
	if(MapInfo[DND_MAPINFO_MAPCHANGED]) {
		SetInventory("ReflectCount", 0);
		SetInventory("Intervened", 0);
		SetInventory("P_Invulnerable", 0);
	}
	TakeInventory("PowerReflection", 1);
	// order of the above reset is important
	if(!GetCVar("sv_maxlives"))
		SetInventory("CurrentLives", 0);
	else
		SetInventory("CurrentLives", GetCvar("sv_maxlives") - 1);
	
	RestoreRPGStat(RES_ACCURACY | RES_EXPLOSIONRADIUS | RES_ALLRESISTS);
	
	// a little hack to prevent ankh going off when finishing maps with 1 hp
	if(GetActorProperty(0, APROP_HEALTH) == 1 && CheckInventory("CanIntervene"))
		HealThing(1);
	
	// Give Temporal Sphere
	if(CheckInventory("Ability_Temporal") && !CheckInventory("TemporalSphere"))
        GiveInventory("TemporalSphere", 1);
	
	if(CheckInventory("QuestCompletionToken"))
		ACS_NamedExecuteAlways("DND Quest Complete", 0);
	// for properly setting up taltos translucency when spawn protection is on
	while(GetActorProperty(0, APROP_INVULNERABLE) && !CheckInventory("P_Invulnerable"))
		Delay(const:7);
	if(CheckInventory("TaltosUp"))
		GiveInventory("TaltosEffect", 1);
	
	TakeInventory("QuestWasPicked", 1); // helps sync clientside variable Quest_Pick_Done
	while(!Quest_Pick_Done)
		Delay(const:10);
		
	GiveInventory("QuestWasPicked", 1);
	if(active_quest_id != -1) {
		SetInventory("ActiveQuestID", active_quest_id + 1);
		ACS_NamedExecuteAlways("DND Announcer", 0, DND_ANNOUNCER_QUEST);
	}
	else
		SetInventory("ActiveQuestID", 0);
		
	// moved here to attempt to fix the reflect pendant issue
	// just in case
	if(DnD_StateChecker[DND_STATECHECK_PLAYERJOIN] >= PlayerCount())
		MapInfo[DND_MAPINFO_MAPCHANGED] = false;
		
	while(CheckInventory("TipBoxOpen"))
		Delay(const:17);
		
	// give some time for completion thing to get through
	SetInventory("QuestCompletionToken", 0);
	if(HardcoreSet && !CheckInventory("HardcoreDebuff"))
		GiveInventory("HardcoreDebuff", 1);
		
	/*if(isPlayerClass(DND_PLAYER_DOOMGUY) && CheckInventory("Doomguy_Perk25"))
		MapInfo[DND_MAPINFO_HASDOOMGUY] = true;*/
	
	SetInventory("DnD_PTotalLevel", PlayerInformationInLevel[PLAYERLEVELINFO_LEVEL]);
	// for zombie quest to work
	TakeInventory("DnD_ShotUndead", 1);
	TakeInventory("ParsingData", 1);
	if(!(HardcoreSet && (GetCVar("dnd_mode") >= DND_MODE_SOFTCORE)))
		ACS_NamedExecuteAlways("DnD Ankh Checker", 0);
}

Script "Force Sync Player Global Data" (void) {
	int pnum = PlayerNumber();
	SyncAllItemData(pnum, DND_SYNC_ITEMSOURCE_CHARMUSED);
	SyncAllItemData(pnum, DND_SYNC_ITEMSOURCE_PLAYERINVENTORY);
	SyncAllItemData(pnum, DND_SYNC_ITEMSOURCE_STASH);
	SyncAllClientsideVariables(pnum);
}

// Control for ammo capacity
Script 992 (int t, int simple) {
	SetResultValue(CheckAmmoPickup(t, simple));
}

Script "DnD On Player Enter CS" ENTER CLIENTSIDE {
	int status = GetCVar("dnd_dashstatus");
	NamedRequestScriptPuke("DnD User CVAR Status Receive", status);

	ResetPlayerScriptChecks();
	if(ConsolePlayerNumber() != PlayerNumber()) 
		Terminate;
	if(GetCVar("dnd_showmapinfo"))
		SetInventory("ShowMapInfo", 1);
		
	ACS_NamedExecuteAlways("DnD Punisher Perk50 Display", 0, true);
	// Set the ammo capacity
	// SetAmmoCapacity("ExpVisual", LevelCurve[CheckInventory("Level") - 1]);
}

Script "DND Monster Damage Scale" (int flags) {
	if(flags & 1) // target
		SetactivatorToTarget(0);
	int this = ActivatorTID() - DND_MONSTERTID_BEGIN;
	int res = Clamp_Between(MonsterProperties[this].level, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 1, 100);
	if(MonsterProperties[this].isElite)
		res = FixedMul(res, 1.0 + GetEliteBonusDamage());
	if(MonsterProperties[this].trait_list[DND_EXTRASTRONG])
		res = FixedMul(res, 1.0 + DND_ELITE_EXTRASTRONG_BONUS);
	if(MonsterProperties[this].trait_list[DND_MARKOFCHAOS])
		res = FixedMul(res, 1.0 + CHAOSMARK_DAMAGEBUFF);
	if(MonsterProperties[this].level > 50)
		res = FixedMul(res, 1.0 + DND_AFTER50_INCREMENT_DAMAGE);
	if(flags & DND_WDMG_ISRIPPER)
		res >>= 1;
	SetResultValue(res >> 16);
}

// saved here for future in case damage values fuck up
Script "DND Monster Damage Scale2" (int dmg, int flags) {
	if(flags & 1) // target
		SetactivatorToTarget(0);
	int this = ActivatorTID() - DND_MONSTERTID_BEGIN;
	int res = Clamp_Between(MonsterProperties[this].level, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 1, 100);
	if(MonsterProperties[this].isElite)
		res = FixedMul(res, 1.0 + GetEliteBonusDamage());
	if(MonsterProperties[this].trait_list[DND_EXTRASTRONG])
		res = FixedMul(res, 1.0 + DND_ELITE_EXTRASTRONG_BONUS);
	if(MonsterProperties[this].level > 50)
		res = FixedMul(res, 1.0 + DND_AFTER50_INCREMENT_DAMAGE);
	SetResultValue((dmg * res) >> 16);
}

// A generic checker function
Script 994 (int type, int extra, int wantNoAmmo) {
	int res = 0;
	int temp;
	if(type == 1) {
		if(!extra) { // attack check
			if(CheckInventory("FireLeft") && CheckInventory("AkimboClipLeft"))
				res = 2;
			if(!CheckInventory("FireLeft") && CheckInventory("AkimboClipRight"))
				res = 3;
			// force reload when out of ammo
			if(!res || (!CheckInventory("AkimboClipLeft") && !CheckInventory("AkimboClipRight")))
				res = 1;
		}
		else { // reload check
			if(CheckInventory("Clip")) {
				int cap = GetAmmoCapacity("AkimboClipLeft");
				res = CheckInventory("AkimboClipLeft") < cap || CheckInventory("AkimboClipRight") < cap;
			}
		}
	}
	else if(type == 3)
		res = GetPlayerInput(-1, INPUT_BUTTONS) & BT_ALTATTACK;
	else if(type == 4)
		res = Clamp_Between(GetCVar("dnd_respawn_count"), 1, 0x7FFFFFFF);
	else if(type > 4 && type < 9) { // keep until cleanup
		if(GetCVar("dnd_monsterscale")) {
			int bonus = 0;
			if(type == 5) {
				bonus = (MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[DND_EXTRASTRONG]) ? DND_ELITE_EXTRASTRONG_BONUS : 0;
				res = (Clamp_Between(MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].level, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 1, 100));
				if(MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].isElite)
					res = FixedMul(res, 1.0 + DND_ELITE_DMGSCALE + bonus);
				res >>= 16;
			}
			else if(type == 6) {
				SetActivatorToTarget(0);
				bonus = (MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[DND_EXTRASTRONG]) ? DND_ELITE_EXTRASTRONG_BONUS : 0;
				res = (Clamp_Between(MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].level, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 1, 100));
				if(MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].isElite)
					res = FixedMul(res, 1.0 + DND_ELITE_DMGSCALE + bonus);
				res >>= 16;
			}
			else if(type == 7) {
				bonus = (MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[DND_EXTRASTRONG]) ? DND_ELITE_EXTRASTRONG_BONUS : 0;
				res = (Clamp_Between(extra, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 1, 100));
				if(MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].isElite)
					res = FixedMul(res, 1.0 + DND_ELITE_DMGSCALE + bonus);
				res >>= 16;
			}
			else if(type == 8)
				res = MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].level;
		}
	}
	else if(type == 9)
		res = GetPlayerInput(-1, INPUT_BUTTONS) & BT_RELOAD;
	else if(type == 10) { // checks shell clip size
		str tocheck = "ShellSize_8N";
		str ammotype = "Shell";
		str weptype = "SpecialAmmoMode_3";
		if(extra == 1)
			tocheck = "ShellSize_8";
		else if(extra == 2)
			tocheck = "ShellSize_10";
		else if(extra == 3)
			tocheck = "ShellSize_12";
		else if(extra == 4) {
			tocheck = "ShellSize_2";
			weptype = "SpecialAmmoMode_3X";
		}
		ammotype = GetSpecialAmmoString(CheckInventory(weptype), AMMOINFO_NAME);
		res = CheckInventory(ammotype) > CheckInventory(tocheck);
		if(wantNoAmmo) {
			// we are either holding fire when we have no ammo for early reload cancel, or we are holding reload when we have ammo, for early reload cancel
			temp = GetPlayerInput(-1, INPUT_BUTTONS);
			res &= (!CheckInventory(tocheck) && (temp & BT_ATTACK)) || (temp & BT_RELOAD);
		}
	}
    else if(type == 11) // has research?
        res = CheckResearchStatus(extra) == RES_NA;
    else if(type == 12)
        res = CheckInventory("LightningStacks");
    else if(type == 13) {
        // check riotgun mode switch possibility
        int norm = !!CheckInventory("RiotgunShell"), nitro = !!CheckInventory("NitroShell"), explo = !!CheckInventory("ExplodingShell");
        // only let switching if more than 1 is available
        res = norm || explo || nitro;
    }
	else if(type == 14)
		res = GetActorProperty(0, APROP_INVULNERABLE);
	SetResultValue(res);
}

Script "DnD Check Special Match" (int multispecial) {
	int sp = GetActorProperty(0, APROP_MASS), res = 0;
	int who = 0;
	SetActivatorToTarget(0);
	who = ActivatorTID();
	if(!multispecial)
		res = who - P_TIDSTART == sp - 1;
	else {
		// 256 means anyone can pick or see w.e
		if((sp & 0xFFFF) == 256)
			res = 1;
		else {
			res = who - P_TIDSTART == (sp & 0xFFFF) - 1;
			if(multispecial & DND_SPECIAL_RESEARCH)
				res = res && !CheckActorResearchStatus(who, sp >> 16);
		}
	}
	//printbold(d:res);
	SetResultValue(res);
}

Script "DnD Blood Rune" (void) {
	str togive = "FakeBloodPower";
	if(CheckInventory("Ability_Arcanery"))
		togive = "FakeBloodPowerBetter";
	ActivatorSound("items/bloodrun", 127);
	GiveInventory(togive, 1);
}

// Custom Powerup script
Script "DnD Player On Hit" (int power) {
	int this, temp, target, hp;
	
	this = ActivatorTID();
	
	if(CheckInventory("HateCheck")) {
		// restore activator
		SetActivator(0, AAPTR_TARGET);
		if(ActivatorTID() != this)
			GiveInventory("HateWeakness", 1);
		SetActivator(this);
	}
	// necro and lightning coil chance
	temp = GetArmorID();
	if(temp == DND_ARMOR_NECRO && !CheckInventory("NecroSpikeCooldown") && !random(0, 2)) {
		GiveInventory("NecroSpikeShooter", 1);
		GiveInventory("NecroSpikeCooldown", 1);
	}
	else if(temp == DND_ARMOR_LIGHTNINGCOIL && !CheckInventory("LightningCoilCooldown") && !random(0, 3)) {
		// 25% chance
		GiveInventory("LightningCoilShooter", 1);
		GiveInventory("LightningCoilCooldown", 1);
	}
	
	// player heal on hit check
	temp = GetPlayerAttributeValue(PlayerNumber(), INV_EX_CHANCE_HEALMISSINGONPAIN);
	if(temp) {
		// roll chance
		// upper 16 bits hold the chance
		if(random(1, 100) <= (temp >> 16)) {
			// heal for missing health
			GiveInventory("VeilHealFXSpawner", 1); // use same fx as veil for now
			ACS_NamedExecuteAlways("DnD Health Pickup", 0, ((temp & 0xFFFF) * GetMissingHealth()) / 100);
		}
	}
	
	// monster might be thief, check it
	target = GetActorProperty(0, APROP_TARGETTID);
	temp = target - DND_MONSTERTID_BEGIN;
	if(MonsterProperties[temp].trait_list[DND_THIEF]) {
		// get current weapon's ammo and steal it
		str cur_ammo = "";
		do {
			cur_ammo = GetWeaponAmmoType(GetWeaponPosFromTable(), random(0, 1));
		} while(cur_ammo == " ");
		TakeInventory(cur_ammo, CheckInventory(cur_ammo) * DND_ELITE_THIEFRATE / 100);
	}
	
	// shocker check
	if(MonsterProperties[temp].trait_list[DND_SHOCKER])
		GiveInventory("PlayerStopper", 1);
	
	// ruination check
	if(MonsterProperties[temp].trait_list[DND_RUINATION]) {
		if(!CheckInventory("RuinationStacks"))
			ACS_NamedExecuteAlways("DnD Ruination Ticker", 0);
		GiveInventory("RuinationStacks", 1);

		if(CheckInventory("RuinationStacks") == RUINATION_MAX_STACKS)
			HandleRuination(this, target);
	}

	// the curse is applied if the player is not immune, the checks are delegated to curse items
	if(MonsterProperties[temp].trait_list[DND_HEXFUSION] && random(1, 100) <= DND_HEXFUSION_CHANCE)
		ApplyRandomCurse();
		
	// check perk25 for berserker with cooldown
	if(CheckInventory("Berserker_Perk25") && !CheckInventory("Berserker_Perk25_CD")) {
		// basically make sure only one instance of this runs
		if(!CheckInventory("Berserker_DamageTimer"))
			ACS_NamedExecuteAlways("DnD Berserker Perk25", 0);
			
		SetInventory("Berserker_DamageTimer", DND_BERSERKER_DAMAGETRACKTIME);
		GiveInventory("Berserker_Perk25_CD", 1);
		if(CheckInventory("Berserker_DamageTracker") < DND_BERSERKER_PERK25_MAXSTACKS)
			GiveInventory("Berserker_DamageTracker", 1);
	}
}

Script "DnD Vampirism FX CS" (int target) CLIENTSIDE {
	GiveActorInventory(target, "DarkHealFX_Spawner", 1);
}

Script "DnD Ruination Ticker" (void) {
	int count = 0;
	while(isAlive() && CheckInventory("RuinationStacks")) {
		Delay(const:RUINATION_TIC);
		++count;
		if(!(count % TICRATE) && CheckInventory("RuinationStacks") == RUINATION_MAX_STACKS)
			break;
		if(count == RUINATION_MAX_TICS) {
			TakeInventory("RuinationStacks", 1);
			count = 0;
		}
	}
}

Script "DnD Berserker Perk25" (void) {
	while(CheckInventory("Berserker_DamageTimer")) {
		delay(const:7);
		TakeInventory("Berserker_DamageTimer", 1);
	}
	
	// heal for max hp 10% if was at full stack
	if(isAlive() && CheckInventory("Berserker_DamageTracker") == DND_BERSERKER_PERK25_MAXSTACKS) {
		ACS_NamedExecuteAlways("DnD Health Pickup", 0, GetSpawnHealth() / DND_BERSERKER_PERK25_HEALPERCENT);
	
		// fx
		Spawn("DarkHealEffectSpawner", GetActorX(0), GetActorY(0), GetActorZ(0), 0);
		LocalAmbientSound("Berserker/Heal", 127);
	}
	SetInventory("Berserker_DamageTracker", 0);
}

Script "DnD Berserker Perk50 Timer" (int this) {
	SetActivator(this);
	// will simply count these by one while we have them, per the berserker timer
	while(CheckInventory("Berserker_HitTracker")) {
		while(CheckInventory("Berserker_HitTimer")) {
			if(!isAlive()) {
				SetInventory("Berserker_HitTracker", 0);
				SetInventory("Berserker_HitTimer", 0);
				Terminate;
			}
		
			TakeInventory("Berserker_HitTimer", 1);
			delay(const:5);
		}
		TakeInventory("Berserker_Perk50_Speed", 1);
		TakeInventory("Berserker_HitTracker", 1);
		SetInventory("Berserker_HitTimer", DND_BERSERKER_PERK50_TIMER);
	}
	// get rid of no roar at end of timer
	TakeInventory("Berserker_NoRoar", 1);
	SetInventory("Berserker_HitTimer", 0);
}

Script "DnD Berserker Roar" (int this) CLIENTSIDE {
	SetActivator(this);
	
	PlaySound(0, "Berserker/Berserk", CHAN_6, 1.0);
	PlaySound(0, "Berserker/GoMad", CHAN_7, 1.0);
	GiveInventory("Berserker_ThunderFX_Spawner", 1);
	
	if(ScreenResOffsets[SCREEN_ASPECT_RATIO] == ASPECT_16_9 || ScreenResOffsets[SCREEN_ASPECT_RATIO] == ASPECT_16_10) {
		SetFont("BERSERKW");
		SetHudSize(1024, 768, 0);
		HudMessage(s:"A"; HUDMSG_FADEINOUT, 90, -1, 512.0, 384.0, 0.25, 0.3, 0.3, 0.8);
	}
	else {
		SetFont("BERSERK");
		SetHudSize(640, 480, 0);
		HudMessage(s:"A"; HUDMSG_FADEINOUT, 90, -1, 320.0, 240.0, 0.25, 0.3, 0.3, 0.8);
	}
}

// Backpack / Research script
Script 996 (int type, int id) {
    if(!type) {
		if (CheckInventory("BackpackCounter") < DND_MAX_BACKPACK) {
			// give additional ones for db save
			int add_backpack_amount = 1;
			if(GetCVar("dnd_firstbackpackold"))
				add_backpack_amount += 4;
			//Respect the max backpack amount
			SetInventory("BackpackCounter", Min(CheckInventory("BackpackCounter") + add_backpack_amount, DND_MAX_BACKPACK));

			SetAllAmmoCapacities();
			//ACS_ExecuteAlways(993, 0, 1); //Why did this call script 993?
		}
		int i,j;
		//Give base 1/20 of initial ammo on backpack pickup.
		for(i = 0; i < MAX_SLOTS - 1; ++i) //Except souls
			for(j = 0; j < MAX_AMMOTYPES_PER_SLOT && AmmoInfo[i][j].initial_capacity != -1; ++j)
				GiveInventory(AmmoInfo_Str[i][j][AMMOINFO_NAME], ((AmmoInfo[i][j].container_value / 5) + (AmmoInfo[i][j].container_value / 5) * (GetPlayerAttributeValue(PlayerNumber(), INV_AMMOGAIN_INCREASE) + (CheckInventory("Perk_Munitionist") * DND_MUNITION_GAIN))/100));
    }
    else if(type == 1) {
        // give research
        GiveResearch(id, false);
    }
}

// Dash Script
Script 997 (void) NET {
	bool soundplayed = 0;
	int input;
	int angle;
	int velX;
	int velY;
	int velZ;
	Delay(3);
	if(CheckInventory("Ability_Dash") && !CheckInventory("DashDelay") && GetActorVelZ(0) >= 0.0 && !CheckInventory("DashDisabled") && !CheckInventory("P_Frozen") && GetActorProperty(0, APROP_HEALTH) > 0) {
		for(int i = 0; i < 4; ++i) {
			input = GetPlayerInput(-1, INPUT_BUTTONS);
			//oldInput = GetPlayerInput(-1, INPUT_OLDBUTTONS);
			if(IsButtonHeld(input, settings[i][0])) {
			//if(IsButtonPressed(input, oldInput, settings[i][0])){
				angle = GetActorAngle(0) + settings[i][1];
				
				if(GetActorZ(0) - GetActorFloorZ(0) > 0) {
					velX = FixedMul(cos(angle), SD_DASHSPEED);
					velY = FixedMul(sin(angle), SD_DASHSPEED);
					velZ = -GetActorVelZ(0) + SD_DASHJUMP;
				}
				
				else {
					velX = FixedMul(cos(angle), SD_DASHSTRONG);
					velY = FixedMul(sin(angle), SD_DASHSTRONG);
					velZ = 0.0;
				}
				
				SetActorVelocity(0, velX, velY, velZ, true, false);
				if(!soundplayed) {
					ActivatorSound("Player/Dash", SD_SOUNDVOLUME);
					soundplayed = 1;
				}
				GiveInventory("DashEffect", 1);
				GiveInventory("DashDelay", 1);
			}
		}
		soundplayed = 0;
	}
}

// reload script -- rewrite sometime
Script 998 (int wepnum, int side, int extra) {
	int base, amt;
	str totake, baseammo = "Clip";
	if(!wepnum) {
		base = GetAmmoCapacity("MGClip");
		totake = "MGClip";
	}
	else if(wepnum == 1) {
		base = GetAmmoCapacity("AkimboClipLeft");
		if(!side)
			totake = "AkimboClipLeft";
		else
			totake = "AkimboClipRight";
	}
	else if(wepnum == 2) {
		base = GetAmmoCapacity("MGClip2");
		totake = "MGClip2";
	}
	else if(wepnum == 3) {
		base = GetAmmoCapacity("MGClip4");
		totake = "MGClip4";
	}
	else if(wepnum == 4) {
        if(side) {
			if(extra == -1)
				extra = CheckInventory("SpecialAmmoMode_4");
            int need = GetAmmoCapacity("RiotgunClip") - CheckInventory("RiotgunClip");
            if(need) {
				amt = CheckInventory(GetSpecialAmmoString(extra, AMMOINFO_NAME));
                if(amt >= need)
                    GiveInventory("RiotgunClip", need);
                else
                    SetInventory("RiotgunClip", amt);
            }
            Terminate;
        }
        else {
            base = GetAmmoCapacity("MGClip5");
            totake = "MGClip5";
        }
	}
	else if(wepnum == 5) {
		base = GetAmmoCapacity("AcidClip");
		baseammo = "AcidAmmo";
		totake = "AcidClip";
	}
	else if(wepnum == 6) {
		base = GetAmmoCapacity("MGClip6");
		baseammo = "FusionCell";
		totake = "MGClip6";
	}
	else if(wepnum == 7) {
		base = GetAmmoCapacity("MGClip7");
		totake = "MGClip7";
	}
	else if(wepnum == 8) {
		baseammo = "SawedoffShell";
		base = 2;
		totake = "SawedoffCounter";
	}
	
	amt = base - CheckInventory(totake);
	
	if(CheckInventory(baseammo) < base) {
		GiveInventory(totake, CheckInventory(baseammo));
		TakeInventory(baseammo, amt);
	}
	else {
		TakeInventory(baseammo, amt);
		GiveInventory(totake, amt);
	}
}

// Regeneration and other infrequent periodic checks
Script "DnD Periodic Regeneration" ENTER {
	int cur, amt, lim, pnum = PlayerNumber(), this = ActivatorTID();
	while(PlayerInGame(pnum)) {
		if(isAlive()) {
			if(CheckInventory("Ability_Regeneration") && !IsAccessoryEquipped(this, DND_ACCESSORY_GRYPHONBOOTS)) {
				cur = GetActorProperty(0, APROP_HEALTH);
				// if we got the quest, our lim is half our cap, otherwise 1/3rd the cap
				lim = GetSpawnHealth();
				if(CheckInventory("DnD_QuestReward_RegenCap"))
					lim /= 2;
				else
					lim /= 3;
				lim += GetPlayerAttributeValue(pnum, INV_REGENCAP_INCREASE);
				amt = lim * DND_REGEN_PERCENT / 100;
				amt = amt * (100 + GetPlayerAttributeValue(pnum, INV_REGENRATE)) / 100;
				
				if(!amt)
					amt = 1;
				
				// cyborg perk
				if(CheckInventory("Cyborg_Perk25"))
					amt += amt * DND_CYBORG_CYBER_MULT / DND_CYBORG_CYBER_DIV;
				
				if(!CheckInventory("RegenStopper") && cur < lim) {
					if(cur + amt < lim)
						GiveInventory("HealthBonusX", amt);
					else
						GiveInventory("HealthBonusX", lim - cur);
					GiveInventory("RegenEffect", 1);
					LocalAmbientSound("ability/regen", 127);
				}
			}
		
			if(GetArmorID() == DND_ARMOR_CYBERNETIC && !IsAccessoryEquipped(this, DND_ACCESSORY_GRYPHONBOOTS) && (cur = GetArmorAmount())) {
				lim = GetArmorCapFromID(DND_ARMOR_CYBERNETIC);
				lim += GetPlayerAttributeValue(pnum, INV_REGENCAP_INCREASE);
				amt = lim * DND_REGEN_PERCENT / 100;
				amt = amt * (100 + GetPlayerAttributeValue(pnum, INV_REGENRATE)) / 100;
				lim >>= 1; // half limit for this armor
				
				// cyborg perk
				if(CheckInventory("Cyborg_Perk25"))
					amt += amt * DND_CYBORG_CYBER_MULT / DND_CYBORG_CYBER_DIV;

				if(cur < lim && !CheckInventory("P_Damaged")) {
					AddArmorAmount(Min(amt, lim - cur));
					GiveInventory("CyberneticEffect", 1);
					LocalAmbientSound("items/armorbonus", 127);
				}
			}
		}
		Delay(const:TICRATE);
	}
}

Script "DnD Lifesteal Script" (void) {
	GiveInventory("PlayerIsLeeching", 1);

	int pnum = PlayerNumber();
	int tics = Max(1, GetLifestealRate(pnum));
	int amt, cap;
	while(IsAlive() && CheckInventory("LifeStealAmount")) {
		amt = GetLifestealLifeRecovery(pnum);
		TakeInventory("LifeStealAmount", amt);
		
		cap = CheckInventory("PlayerHealthCap");
		if(GetActorProperty(0, APROP_HEALTH) + amt < cap)
			GiveInventory("HealthBonusX", amt);
		else {
			// we reached cap, stop
			GiveInventory("HealthBonusX", cap - amt);
			break;
		}
		Delay(tics);
	}
	
	TakeInventory("PlayerIsLeeching", 1);
}

// for elites with pierce armor flag
Script "DND Pierce Check" (void) {
	int owner = GetActorProperty(0, APROP_TARGETTID);
	//TODO: Fix this
	//if(CheckFlag(owner, "PIERCEARMOR"))
	//	SetActorFlag(0, "PIERCEARMOR", 1);
}

Script "DND Riotgun Decide" (void) {
	// check riotgun mode switch clip
	str mode = "RiotgunShell";
	if(CheckInventory("SpecialAmmoMode_4") == AMMO_EXPLOSIVESHELL)
		mode = "ExplodingShell";
	else if(CheckInventory("SpecialAmmoMode_4") == AMMO_NITROGENSHELL)
		mode = "NitroShell";
	// either clip full or special ammo clip full
	if((CheckInventory("RiotgunClip") == GetAmmoCapacity("RiotgunClip") || CheckInventory("RiotgunClip") == CheckInventory(mode)) && CanSwitchMode(AMMO_TYPE_SHELL2, SPWEP_MG))
		SetInventory("RiotgunReloadModeDecide", 2); // mode switch
	else if(CheckInventory("RiotgunClip") < GetAmmoCapacity("RiotgunClip") && CheckInventory(mode) > CheckInventory("RiotgunClip"))
		SetInventory("RiotgunReloadModeDecide", 1); // reload
}

Script "DND Elite Special FX" (void) CLIENTSIDE {
	GiveInventory("EliteFXRunner", 1);
}

Script "DnD Align Elite FX" (void) CLIENTSIDE {
	SetActorProperty(0, APROP_MASS, GetActorProperty(GetActorProperty(0, APROP_TARGETTID), APROP_HEIGHT) >> 17);
}

Script 1000 (int isSoftcore) {
	int i;
	// casual mode has higher drop rates
	if(isSoftcore != 2) {
		for(i = 0; i < MAXFLAGS; ++i)
			ConsoleCommand(StrParam(s:FlagCheckList[i], s: " ", d:FlagAcceptedValues[i]));
		for(i = 0; i < MAXDNDFLAGS; ++i)
			SetCVar(DNDFlagCheckList[i], DNDFlagAcceptedValues[i]);
		// handle fixed point shit here because getcvar is stupid with them
		ConsoleCommand("sv_coop_damagefactor 1.0");
		/*SetCVar("dnd_researchdroprate", 0.0025);
		SetCVar("dnd_uniquemonster_spawnchance", 0.025);*/
	}
	if(isSoftcore < 2) {
		if(isSoftcore) {
			SetCVar("dnd_mode", 1); //Softcore
		}
		else {
			SetCVar("dnd_mode", 2); //Hardcore
		}
		ConsoleCommand("authhostname auth.zandronum.com:16666");
	}
	else if(isSoftcore < 4) {
		// softcore == 2 => casual mode, default settings
		// beginner mode, force smart monster spawner
		// 4 or 5 are simulated softcore / hardcore for singleplayer or local servers -- no database but ruleset is the same
		if(isSoftcore == 3) {
			SetCVar("dnd_allresearchesfound", 0);
			SetCVar("dnd_usesmartmonsterspawner", 1);
		}
	}
	ConsoleCommand("map map01");
}

Script "DnD Levelup Log" (int has_perk) CLIENTSIDE {
	if(has_perk)
		Log(s:"\cc", l:"DND_ANNOUNCE", s:": \c-", n:0, s:" \c[Y5]", l:"DND_GOTPERK");
	else
		Log(s:"\cc", l:"DND_ANNOUNCE", s:": \c-", n:0, s:" \c[Y5]", l:"DND_HASLEVELEDUP", s:"\cv ", d:CheckInventory("Level"), s:"\c[Y5]!");
}

Script "DND Announcer" (int num, int extra, int to) CLIENTSIDE {
	if(to)
		SetActivator(to + P_TIDSTART - 1);
	while(CheckInventory("TipBoxOpen"))
		Delay(const:35);
		
	// dont proceed if we are in scoreboard
	if(CheckInventory("DnD_IntermissionState"))
		Terminate;
		
	GiveInventory("TipBoxOpen", 1); // just in case this wasn't given before
	if(num != DND_ANNOUNCER_TRADEREQUEST)
		LocalAmbientSound("Quest/Announce", 127);
	if(num == DND_ANNOUNCER_LEGENDARYMONSTER)
		AmbientSound("LegendaryHere", 127);
	SetHudSize(640, 480, 1);
	SetFont("QUESTPOP");
	
	int hud_pos = (GetHudRight(640) << 16) - NOTIFBAK_XF / 2 + 0.4;
	if(num != DND_ANNOUNCER_LEGENDARYMONSTER) {
		HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVETOPTEXTID, CR_UNTRANSLATED, hud_pos, 72.0, 4.0, 1.0, 1.0);
		SetFont("NOTIFBAK");
		HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVEBAKID, CR_UNTRANSLATED, hud_pos, 96.0, 4.0, 1.0, 1.0);
	}
	else {
		HudMessageBold(s:"A"; HUDMSG_FADEINOUT, SURVIVETOPTEXTID, CR_UNTRANSLATED, hud_pos, 72.0, 4.0, 1.0, 1.0);
		SetFont("NOTIFBAK");
		HudMessageBold(s:"A"; HUDMSG_FADEINOUT, SURVIVEBAKID, CR_UNTRANSLATED, hud_pos, 96.0, 4.0, 1.0, 1.0);
	}
		
	SetFont("OBJFONT");
	SetHudSize(960, 600, 1);
	
	hud_pos = GetHudRight(960) - 3 * NOTIFBAK_X / 2 + 8;
	SetHudClipRect(hud_pos, 96, 225, 128, 225);
	
	hud_pos <<= 16;
	hud_pos += 0.1;
	
	if(num == DND_ANNOUNCER_QUEST)
		HudMessage(l:"DND_NEWQUEST"; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 126.1, 4.0, 1.0, 1.0);
	else if(num == DND_ANNOUNCER_ATTRIBPOINT)
		HudMessage(l:"DND_TEXT_UNSPENTPOINT", s:" ", l:"DND_TEXT_SPENDINMENU"; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 126.1, 4.0, 1.0, 1.0);
	else if(num == DND_ANNOUNCER_NEWCLASSPERK)
		HudMessage(l:"DND_TEXT_NEWPERK"; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 126.1, 4.0, 1.0, 1.0);
	else if(num == DND_ANNOUNCER_LEGENDARYMONSTER) // this one is called from the monster spawner and thus must be hudmessagebold
		HudMessageBold(l:"DND_TEXT_LEGENDARYWALKS"; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 126.1, 4.0, 1.0, 1.0);
	else if(num == DND_ANNOUNCER_RESEARCHDISCOVER)
		HudMessage(l:"DND_TEXT_DISCOVEREDRES", s:": \cd", l:GetResearchLabel(extra), s:"\c-!"; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 126.1, 4.0, 1.0, 1.0);
	else if(num == DND_ANNOUNCER_TRADEREQUEST) {
		LocalAmbientSound("TradeRequest", 127);
		HudMessage(l:"DND_TEXT_TRADEREQUEST", s:": ", n:extra + 1; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 126.1, 4.0, 1.0, 1.0);
	}
	SetHudClipRect(0, 0, 0, 0, 0);
}

Script 1002 (void) NET CLIENTSIDE {
	int qid = CheckInventory("ActiveQuestID") - 1;
	if(qid < 0 || !CheckInventory("QuestWasPicked")) {
		Log(l:"DND_TEXT_NOACTIVEQUEST");
		Terminate;
	}
	else if(CheckInventory("TipBoxOpen"))
		Terminate;
			
			
	SetHudSize(640, 480, 1);
	SetFont("QUESTPOP");
	
	int hud_pos = (GetHudRight(640) << 16) - QSTBOX2_XF / 2 + 0.4;
	GiveInventory("TipboxOpen", 1);
	LocalAmbientSound("Quest/View", 127);
	SetHudSize(640, 480, 1);
	SetFont("QSTBOX2");
	HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVEID, CR_UNTRANSLATED, hud_pos, 136.0, 4.0, 1.0, 1.0);
	
	hud_pos = (GetHudRight(960) << 16) - 3 * QSTBOX2_XF / 2 + 48.1;
	SetHudSize(960, 600, 1);
	SetFont("OBJFONT");
	HudMessage
	(
		s:"\cf", l:GetQuestLabel(qid, QUEST_NAME);
		HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 112.1, 4.0, 1.0, 1.0
	);
	// requirement
	SetHudClipRect(hud_pos >> 16, 128, 384, 64, 384);
	HudMessage
	(
		s:"\c-\c[Y5]", l:"DND_REQ", s:": \c-", l:GetQuestLabel(qid, QUEST_REQ);
		HUDMSG_FADEINOUT, UPGRADETEXTID, CR_WHITE, hud_pos, 136.1, 4.0, 1.0, 1.0
	);
	// reward
	SetHudClipRect(hud_pos >> 16, 176, 384, 64, 384);
	HudMessage
	(
		s:"\c-\cd", l:"DND_REW", s:": \c-", l:GetQuestLabel(qid, QUEST_REW);
		HUDMSG_FADEINOUT, SURVIVEICO, CR_WHITE, hud_pos, 184.1, 4.0, 1.0, 1.0
	);
	SetHudClipRect(0, 0, 0, 0, 0);
	// progress
	if(Quest_List[qid].qflag & QTYPE_TRACKABLE) {
		int progress = Clamp_Between((100 * CheckInventory(Quest_Checkers[qid])) / GetQuestProgressRequirement(qid), 0, 100);
		str color = "\cg";
		if(progress == 100)
			color = "\cd";
		else if(progress > 75)
			color = "\cf";
		else if(progress > 50)
			color = "\ck";
		else if(progress > 25)
			color = "\ci";
		HudMessage
		(
			l:"DND_PROGRESS", s:": ", s:color, d:progress, s:"%\c-";
			HUDMSG_FADEINOUT, SURVIVETOPTEXTID, CR_WHITE, hud_pos, 232.1, 4.0, 1.0, 1.0
		);
	}
	Delay(35 * 5);
	LocalAmbientSound("Quest/Close", 127);
	SetHudClipRect(0, 0, 0, 0, 0);
}

// a fancy ammo pickup script to make it easier to add new ammo types to slots
Script "DND Ammo Container Pickup" (int ctype, int basic_kind) {
	HandleAmmoContainerPickup(ctype, basic_kind);
}

Script "DND Quest Complete" (int isFail) CLIENTSIDE {
	while(CheckInventory("ShowingMenu"))
		Delay(const:35);
	int qid = CheckInventory("QuestCompletionToken") - 1;
	if(qid < 0)
		Terminate;
	while(ScreenResOffsets[0] == -1)
		Delay(const:17);
	
	int hud_pos = (GetHudRight(640) << 16) - QSTBOX_XF / 2 + 0.4;
	GiveInventory("TipBoxOpen", 1);
	SetHudSize(640, 480, 1);
	SetFont("QUESTBOX");
	HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVEID, CR_UNTRANSLATED, hud_pos, 120.0, 3.0, 1.0, 1.0);
	
	hud_pos = (GetHudRight(960) << 16) - 3 * QSTBOX_XF / 2 + 48.1;
	SetHudSize(960, 600, 1);
	SetFont("OBJFONT");
	if(!isFail) {
		LocalAmbientSound("Quest/Done", 127);
		HudMessage
		(
			s:"\cf", l:GetQuestLabel(qid, QUEST_NAME),
			s:"\c-\n\c[Y5]", l:"DND_QUESTCOMPLETE";
			HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 104.1, 3.0, 1.0, 1.0
		);
	}
	else {
		LocalAmbientSound("Quest/Fail", 127);
		HudMessage
		(
			s:"\cf", l:GetQuestLabel(qid, QUEST_NAME),
			s:"\c-\n\c[B1]", l:"DND_QUESTFAILED";
			HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 104.1, 3.0, 1.0, 1.0
		);
	}
}

// Used in Select statement of weapons, caches the weapon damage numbers this weapon can cause
Script "DND Weapon Damage Cache" (int dmg_id, int dmg, int dmg_rand, int wepid) {
	CachePlayerDamage(PlayerNumber(), dmg, wepid, dmg_id, dmg_rand);
	SetResultValue(0);
}

Script "DND Weapon Damage Retrieve" (int dmgid, int talent_type, int flags) {
	bool isSpecial = flags & DND_WDMG_ISSPECIALAMMO;
	int wepid = dmgid >> 16;
	dmgid &= 0xFFFF;
	
	// hack for crit guarantee on multi-proj attacks
	bool proj_crit = !ActivatorTID() && GetActorProperty(0, APROP_ACCURACY) == DND_CRIT_TOKEN;
	
	AdjustDamageRetrievePointers(flags);

	int pnum = PlayerNumber();
	int res = ScaleCachedDamage(wepid, pnum, dmgid, talent_type, flags, isSpecial);
	
	// special weapons checks -- these are added on top of everything else as the last thing, before crits
	// they are also dynamic and cant be cached...
	if(wepid == DND_WEAPON_LIGHTNINGGUN)
		res = res * (100 + DND_LIGHTNINGGUN_DMGPERSTACK * CheckInventory("LightningStacks")) / 100;
	else if(wepid == DND_WEAPON_DUSKBLADE)
		res = res * (100 + DND_DUSKBLADE_DMGPERSTACK * CheckInventory("SwordHitCharge")) / 100;
	
	if(PlayerCritState[pnum][DND_CRITSTATE_CONFIRMED][wepid] || proj_crit)
		res = ConfirmedCritFactor(res);
	
	SetResultValue(res);
}

Script "DnD Get Melee Range Increase" (int use_target) {
	if(use_target)
		SetActivatorToTarget(0);
	SetResultValue(CheckInventory("IATTR_MeleeRange") + GetStat(STAT_BRUT) * DND_PERK_BRUTALITY_RANGEINC);
}

// Used mainly for non-weapons (like artifacts, spells and so on)
Script "DND Player Damage Scale" (int dmg, int talent_type, int flags) {
	int temp, temp2;
	
	AdjustDamageRetrievePointers(flags);
	
	int pnum = PlayerNumber();
	bool isSpell = flags & DND_WDMG_ISSPELL;
	if(isSpell) {
		// we take id of spell from the table as input, then read its damage
		temp2 = dmg;
		dmg = SpellDamageTable[dmg].dmg;
	}
	
	dmg += MapTalentToFlatBonus(pnum, talent_type, flags);
	
	if(talent_type == TALENT_MELEE || (flags & DND_WDMG_HASSTRSCALING))
		dmg = dmg * (100 + DND_STR_GAIN * GetStrength()) / 100;
		
	if((flags & DND_WDMG_ISOCCULT) || talent_type == TALENT_OCCULT) // is occult (add demon bane bonus)
		dmg = dmg * (100 + DND_DEMONBANE_GAIN * IsAccessoryEquipped(ActivatorTID(), DND_ACCESSORY_DEMONBANE)) / 100;
		
	if(flags & DMG_WDMG_ISARTIFACT)
		dmg = dmg * (100 + DND_ARTIFACT_GAIN * CheckInventory("Ability_Arcanery")) / 100;
		
	if(flags & DMG_WDMG_NECROBULK)
		dmg = dmg * (100 + DND_NECRO_BULKSCALE * GetBulkiness()) / 100;
		
	// attribute bonus
	if((flags & DND_WDMG_ISOCCULT) || talent_type == TALENT_OCCULT || isSpell)
		dmg = dmg * (100 + DND_INT_GAIN * GetIntellect()) / 100;
	else
		dmg = dmg * (100 + DND_DEX_GAIN * GetDexterity()) / 100;
	
	temp = GetPlayerAttributeValue(pnum, INV_EX_DAMAGEPER_FLATHEALTH);
	if(temp) {
		temp = GetFlatHealthDamageFactor(temp);
		dmg = dmg * (100 + temp) / 100;
	}
	
	temp =  GetPlayerPercentDamage(pnum, -1, talent_type);
	if(temp)
		dmg = dmg * (100 + temp) / 100;
		
	// finally crit chance
	// spells will have their own crit source compared to attacks
	if(!isSpell && CheckCritChance(-1, false, -1)) {
		dmg = dmg * GetCritModifier() / 100;
		HandleHunterTalisman();
	}
	
	// final additions
	if((flags & DMG_WDMG_ISARTIFACT) && CheckInventory("DnD_QuestReward_ExtraArtiDmg"))
		dmg = dmg * (100 + DND_QUEST_ARTIBONUS) / 100;
	
	if(isSpell) {
		if(SpellDamageTable[temp2].dmg_low)
			dmg *= random(SpellDamageTable[temp2].dmg_low, SpellDamageTable[temp2].dmg_high);
	}
	
	//printbold(s:"scaled player damage ", d:dmg);
	
	SetResultValue(dmg);
}

// idk why parameters are reversed here compared to below... ugh
Script "DND Armor Pickup Check" (int amount, int armor_type) {
	if (CheckInventory("CanLoad"))
		SetResultValue(-1);
	else {
		int armor_id = GetArmorID();
		// decide if armor is higher tier if amount doesn't satisfy
		SetResultValue(
			!CheckInventory("StatbuffCounter_ForbidArmor") && 
				(
					(armor_id != -1 && GetArmorAmount() < GetArmorCapFromID(armor_id)) || 
					IsArmorTierHigher(armor_type, armor_id)
				)
		);
	}
}

Script "DND Armor Give" (int armor_type, int amount) {
	if(!CheckInventory("StatbuffCounter_ForbidArmor"))
		HandleArmorPickup(armor_type, amount, 0);
}

Script "DND Acid Rifle Bolt Stick" (int type) {
	int res = 0;
	int tracer = GetActorProperty(0, APROP_TRACERTID);
	if(!type)
		res = GetActorProperty(tracer, APROP_HEIGHT) >> 16;
	else
		res = IsActorAlive(tracer);
	SetResultValue(res);
}

Script "DND Demon Seal FX Spawn" (int tracer) CLIENTSIDE {
	Spawn("DemonSealDebuffFXSpawner", GetActorX(tracer), GetActorY(tracer), GetActorZ(tracer), 0);
}

Script "DND Demon Seal FX" (void) {
	int tracer = ActivatorTID();
	if(!CheckActorInventory(tracer, "DemonSealDamageDebuff")) {
		GiveActorInventory(tracer, "DemonSealDamageDebuff", 1);
		GiveActorInventory(tracer, "DemonSealResistDebuff", 1);
		if(isActorAlive(tracer)) {
			PlaySound(tracer, "DemonSeal/debuff", 6, 0.9, 0, 1.0);
			// loops at 4.8 seconds, zandro doesnt know how to stop looping this sound for whatever reason...
			//PlaySound(tracer, "DemonSeal/debuffloop", 7, 0.5, 0, 1.3);
		}
		while(isActorAlive(tracer) && CheckActorInventory(tracer, "DemonSealDamageDebuff")) {
			ACS_NamedExecuteAlways("DND Demon Seal FX Spawn", 0, tracer);
			Delay(1);
		}
		//StopSound(tracer, 7);
	}
}

Script "DND Desolator FX Spawn" (int tracer) CLIENTSIDE {
	Spawn("DesolatorDebuffFXSpawner", GetActorX(tracer), GetActorY(tracer), GetActorZ(tracer), 0);
}

Script "DND Desolator Debuff FX" (int tracer) {
	while(isActorAlive(tracer) && CheckActorInventory(tracer, "DesolatorStackTimer")) {
		ACS_NamedExecuteAlways("DND Desolator FX Spawn", 0, tracer);
		TakeActorInventory(tracer, "DesolatorStackTimer", 1);
		Delay(const:1);
	}
	TakeActorInventory(tracer, "DesolatorStackCounter", 99);
}

Script "DND Trail Spawner" (int actortype, int density, int target) CLIENTSIDE {
	int ptid = !target ? GetActorProperty(0, APROP_TARGETTID) : target;
	//printbold(s:GetActorClass(ptid), s: " ", s:GetActorClass(0));
	if(DnD_TrailDef[actortype].waittime)
		Delay(DnD_TrailDef[actortype].waittime);
	
    int plX; int plY;  int plZ;
    int grX; int grY;  int grZ;
    int vX;  int vY;   int vZ;
    int nX;  int nY;   int nZ;
    int bX;  int bY;   int bZ;
    int magnitude;
    int pointCount;
    int pointOffset;
	
    plX = GetActorX(0); 
	grX = GetActorX(ptid);
	
    plY = GetActorY(0);
	grY  = GetActorY(ptid);
    
	plZ = GetActorZ(0) + (GetActorProperty(0, APROP_HEIGHT) >> 1) + DnD_TrailDef[actortype].offset_z; 
	grZ  = GetActorZ(ptid) + (GetActorProperty(ptid, APROP_HEIGHT) >> 1);
	
    vX   = grX - plX;       vY   = grY - plY;       vZ   = grZ - plZ;

    magnitude = magnitudeThree(vX >> 16, vY >> 16, vZ >> 16);

    pointCount  = magnitude / density;
    pointOffset = magnitude - (pointCount * density);

	int maxdiff = DnD_TrailDef[actortype].maxdiff;
    if (magnitude != 0) {
        nX = vX / magnitude; nY = vY / magnitude; nZ = vZ / magnitude;

        int i; int j;
        for (i = 1; i < pointCount; i++) {
            j = (i * density) + pointOffset;

			bX = (nX * j) + plX;
			bY = (nY * j) + plY;
			bZ = (nZ * j) + plZ;
			
			if(maxdiff) {
				bX += (random(0, 1) ? random(-maxdiff, maxdiff) : 0);
				bY += (random(0, 1) ? random(-maxdiff, maxdiff) : 0);
				bZ += (random(0, 1) ? random(-maxdiff, maxdiff) : 0);
			}

			Spawn(DnD_TrailDef[actortype].actor, bX, bY, bZ, 0, VectorAngle(-vX, -vY) >> 8);
        }
    }
}

Script "DND Charon Trail Spawner" (int plX, int plY, int plZ, int target) CLIENTSIDE {
	int actortype = target >> 16;
	target &= 0xFFFF;
	int ptid = !target ? GetActorProperty(0, APROP_TARGETTID) : target;
	
    int grX; int grY;  int grZ;
    int vX;  int vY;   int vZ;
    int nX;  int nY;   int nZ;
    int bX;  int bY;   int bZ;
    int magnitude;
    int pointCount;
    int pointOffset;
 
	grX = GetActorX(ptid);
	grY = GetActorY(ptid);
	grZ = GetActorZ(ptid) + (GetActorProperty(ptid, APROP_HEIGHT) >> 1) + DnD_TrailDef[actortype].offset_z;
	
	plX <<= 16;
	plY <<= 16;
	plZ <<= 16;
	
    vX   = grX - plX;       vY   = grY - plY;       vZ   = grZ - plZ;

    magnitude = magnitudeThree(vX >> 16, vY >> 16, vZ >> 16);

    pointCount  = magnitude / CHARON_PARTICLE_DENSITY;
    pointOffset = magnitude - (pointCount * CHARON_PARTICLE_DENSITY);

	int maxdiff = DnD_TrailDef[actortype].maxdiff;
    if (magnitude != 0) {
        nX = vX / magnitude; nY = vY / magnitude; nZ = vZ / magnitude;

        int i; int j;
        for (i = 1; i < pointCount - 3; i++) {
            j = (i * CHARON_PARTICLE_DENSITY) + pointOffset;

			bX = (nX * j) + plX;
			bY = (nY * j) + plY;
			bZ = (nZ * j) + plZ;
			
			if(maxdiff) {
				bX += (random(0, 1) ? random(-maxdiff, maxdiff) : 0);
				bY += (random(0, 1) ? random(-maxdiff, maxdiff) : 0);
				bZ += (random(0, 1) ? random(-maxdiff, maxdiff) : 0);
			}

			Spawn(DnD_TrailDef[actortype].actor, bX, bY, bZ, 0, VectorAngle(-vX, -vY) >> 8);
        }
    }
}

Script "DnD Dark Lance Shooter" (int amt, int dist, int spd, int lvl) {
	// get direction vector
	// cos p * cos a, cos p * sin a, -sin p
	int a = GetActorAngle(0);
	int p = GetActorPitch(0);
	int vx = FixedMul(cos(p), cos(a));
	int vy = FixedMul(cos(p), sin(a));
	int vz = -sin(p);
	int pnum = PlayerNumber();
	int this = ActivatorTID();
	
	int x = GetActorX(0);
	int y = GetActorY(0);
	int z = GetActorZ(0);
	
	for(int i = 0; i < amt; ++i)
		SpawnDarkLanceProjectile(this, a, DARKLANCE_TID + pnum, x, y, z, vx, vy, vz, i * dist, spd); 
	
	// side projectiles
	if(lvl > 0) {
		SpawnDarkLanceProjectile_Side(this, a, DARKLANCE_TID + pnum, x, y, z, vx, vy, vz, 3, -16, 3, spd);
		SpawnDarkLanceProjectile_Side(this, a, DARKLANCE_TID + pnum, x, y, z, vx, vy, vz, 11, -30, 11, spd);
		SpawnDarkLanceProjectile_Side(this, a, DARKLANCE_TID + pnum, x, y, z, vx, vy, vz, 3, 16, 3, spd);
		SpawnDarkLanceProjectile_Side(this, a, DARKLANCE_TID + pnum, x, y, z, vx, vy, vz, 11, 30, 11, spd);
	}
	
	// more side projectiles
	if(lvl > 1) {
		SpawnDarkLanceProjectile_Side(this, a, DARKLANCE_TID + pnum, x, y, z, vx, vy, vz, 20, -39, 20, spd);
		SpawnDarkLanceProjectile_Side(this, a, DARKLANCE_TID + pnum, x, y, z, vx, vy, vz, 28, -45, 28, spd);
		SpawnDarkLanceProjectile_Side(this, a, DARKLANCE_TID + pnum, x, y, z, vx, vy, vz, 20, 39, 20, spd);
		SpawnDarkLanceProjectile_Side(this, a, DARKLANCE_TID + pnum, x, y, z, vx, vy, vz, 28, 45, 28, spd);
	}
	
	SetResultValue(0);
}

Script "DnD Dark Lance Aligner" (int xd, int yd, int zd, int tics) CLIENTSIDE {
	int owner = GetActorProperty(0, APROP_TARGETTID);
	
	for(int i = 0; i < tics; ++i) {
		// get direction vector from owner constantly
		int a = GetActorAngle(owner);
		int p = GetActorPitch(owner);
		int vx = FixedMul(cos(p), cos(a));
		int vy = FixedMul(cos(p), sin(a));
		int vz = -sin(p);
		
		int x = GetActorX(owner);
		int y = GetActorY(owner);
		int z = GetActorZ(owner);
				
		SetActorPosition(0, x + vx * xd + vy * yd, y + vy * xd - vx * yd, z + 32.0 + vz * zd, 0);
		Delay(const:1);
	}
	SetResultValue(0);
}

Script "DnD Lance Stack Buffer" (void) {
	SetInventory("LanceBuffer", CheckInventory("LanceStacks"));
	SetInventory("LanceStacks", 0);
	SetResultValue(0);
}

Script "DnD Dark Lance Shred" (int dmg, int owner, int stacks, int victim) {
	// first time engage
	if(!victim)
		victim = GetActorProperty(0, APROP_TRACERTID);
	
	if(isEnemyTID(victim)) {
		// start procedure --- if owner is left blank that means this is initiated the first time from us
		if(!owner)
			owner = GetActorProperty(0, APROP_TARGETTID);
			
		SetActivator(owner);
			
		// special fx script
		ACS_NamedExecuteWithResult("DnD Dark Lance Shred FX", victim, owner - P_TIDSTART);
		
		if(!stacks)
			stacks = CheckInventory("LanceBuffer");
			
		PlaySound(victim, "Darklance/Affliction", CHAN_ITEM, 1.0);
		
		bool terminated = false;
		int i;
		for(i = 0; !terminated && i < DARKLANCE_ALT_DURATION; ++i) {
			if(isActorAlive(victim))
				HandleDamageDeal(owner, victim, dmg * stacks, DND_DAMAGETYPE_OCCULT, 0, -1, -1, -1, DND_ACTORFLAG_NOPUSH | DND_ACTORFLAG_FOILINVUL);
			else
				terminated = true;
			
			Delay(const:DARKLANCE_TICKS);
		}
		
		// find nearest monster to bounce to
		if(terminated) {
			// phase out the previous victim
			ACS_NamedExecuteAlways("DnD Monster RIP", 0, victim);
			
			GiveActorInventory(owner, "DemonBlood", 1);
		
			// find new victim
			int dist = 0;
			int prev_victim = victim;
			int curr_dist = INT_MAX;
			victim = -1;
			
			for(i = DND_MONSTERTID_BEGIN; i < DnD_TID_List[DND_TID_MONSTER]; ++i) {
				if(IsActorAlive(i) && CheckFlag(i, "SHOOTABLE")) {
					dist = fdistance(prev_victim, i);
					if(dist < DARKLANCE_BOUNCE_DIST && dist < curr_dist && CheckSight(prev_victim, i, CSF_NOBLOCKALL)) {
						victim = i;
						curr_dist = dist;
					}
				}
			}
			
			// found a monster suitable for jump, so go to this one now
			if(victim != -1)
				ACS_NamedExecuteWithResult("DnD Dark Lance Shred", dmg, owner, stacks, victim);
		}
	}

	SetResultValue(0);
}

Script "DnD Dark Lance Shred FX" (int tid, int pnum) CLIENTSIDE {
	SpawnForced("DarkLanceShredder_FX", GetActorX(tid), GetActorY(tid), GetActorZ(tid), DARKLANCE_SHREDDER + pnum);
	SetActivator(DARKLANCE_SHREDDER + pnum);
	Thing_ChangeTID(0, 0);
	
	SetActorProperty(0, APROP_SCALEX, (GetActorProperty(tid, APROP_RADIUS) + 32.0) / 128);
	SetActorProperty(0, APROP_SCALEY, (GetActorProperty(tid, APROP_HEIGHT) + 32.0) / 128);
	
	int h = GetActorProperty(tid, APROP_HEIGHT);
	
	for(int i = 0; isActorAlive(tid) && i < DARKLANCE_ALT_DURATION_TICS; ++i) {
		SetActorPosition(0, GetActorX(tid), GetActorY(tid), GetActorZ(tid) + h / 2, 0);
		Delay(const:1);
	}
	
	// if dead, vanish with special fx otherwise just remove
	if(!isActorAlive(tid)) {
		SetActorState(0, "Vanish", 0);
		SpawnForced("DarkLanceConsumeFX", GetActorX(tid), GetActorY(tid), GetActorZ(tid) + h / 2, 0);
	}
	else
		Thing_Remove(0);
	
	SetResultValue(0);
}

// currently does 90 degree scan from players fov
Script "DnD Do Scan Attack" (int dmg, int damage_type, int tracer_count, int flags) {
	// scan field of view
	// check all monsters
	static dist_tid_pair_T tlist[MAXPLAYERS][DND_MAXSCANTRACER];
	
	int scan_id = tracer_count >> 16;
	tracer_count &= 0xFFFF;
	
	int scan_dist = ScanAttackData[scan_id].max_dist;
	int scan_fov = ScanAttackData[scan_id].fov;
	
	int dist = scan_dist, i, j, k, temp;
	
	int tcount = 0;
	int owner = (flags & DND_DAMAGEFLAG_SELFORIGIN) ? ActivatorTID() : GetActorProperty(0, APROP_TARGETTID);
	int pnum = owner - P_TIDSTART;
	
	// init list
	for(i = 0; i < DND_MAXSCANTRACER; ++i) {
		tlist[pnum][i].tid = 0;
		tlist[pnum][i].dist = scan_dist;
	}
	
	// face player to the originator temporarily to get projection to there
	int projection_angle = GetActorAngle(owner);
	// use angle of the ball
	if(!(flags & DND_DAMAGEFLAG_SELFORIGIN))
		projection_angle = GetActorAngle(0);
	
	// printbold(s:"starting scan from ", d:owner, s: " with dmg ", d:dmg, s: " scan id: ", d:scan_id);
	// pick tracer_count closest enemies
	for(i = DND_MONSTERTID_BEGIN; i < DnD_TID_List[DND_TID_MONSTER]; ++i) {
		if(IsActorAlive(i) && CheckFlag(i, "SHOOTABLE")) {
			dist = fdistance(owner, i);
			//printbold(s:"Checking ", s:GetActorClass(i));
			if(dist < scan_dist && MaxAngleDiff_Projection(owner, i, scan_fov, projection_angle) && CheckSight(owner, i, CSF_NOBLOCKALL)) {
				//printbold(s:"approved ", s:GetActorClass(i), s: " ", d:i);
				// insert sorted
				temp = tcount;
				// while our calc dist > alloc dist, keep going -- we add things to the end
				// if we come by a point where we are smaller, shift things
				for(j = 0; j < temp && dist > tlist[pnum][j].dist; ++j);

				// we know where to add, check if we must shift (if we should)
				if(j < temp) {
					// less, so that means we are in-between things
					// push everything for insertion
					// this is needed to move in 0 index shifts
					if(temp == DND_MAXSCANTRACER)
						--temp;
					
					for(k = temp; k > j; --k) {
						// slide data
						tlist[pnum][k].dist = tlist[pnum][k - 1].dist;
						tlist[pnum][k].tid = tlist[pnum][k - 1].tid;
					}
				}
				
				tlist[pnum][j].dist = dist;
				tlist[pnum][j].tid = i;
				
				if(tcount < tracer_count)
					++tcount;
			}
		}
	}
	
	if(tcount) {
		int actor_flags = ScanActorFlags();
		
		// damage credit
		SetActivator(owner);
		
		// re-use this as poison damage mod value if any
		scan_fov = 0;
		int extra = 0;
		int wepid = Scan_to_WeaponID(scan_id);
		if(wepid != -1) {
			scan_fov = Player_Weapon_Infos[pnum][wepid].wep_mods[WEP_MOD_POISONFORPERCENTDAMAGE].val;
			extra = Player_Weapon_Infos[pnum][wepid].wep_mods[WEP_MOD_PERCENTDAMAGE].val;
			if(scan_fov)
				flags |= DND_DAMAGEFLAG_INFLICTPOISON;
			if(extra)
				flags |= DND_DAMAGEFLAG_PERCENTHEALTH;
		}
		
		for(i = 0, j = 0; i < DND_MAXSCANTRACER; ++i) {
			if(tlist[pnum][i].tid) {
				// distance reduces damage for scans, closer = better -- gives percentage
				// curr formula: factor = 100 * ((max_scan_dist - curr_dist) / max_scan_dist)^2 -- returns a percentage
				if(flags & DND_DAMAGEFLAG_DISTANCEGIVESDAMAGE) {
					tlist[pnum][i].dist = FixedDiv((scan_dist - tlist[pnum][i].dist), scan_dist);
					tlist[pnum][i].dist = FixedMul(tlist[pnum][i].dist, tlist[pnum][i].dist);
					tlist[pnum][i].dist *= 100;
					tlist[pnum][i].dist >>= 16;
					if(!tlist[pnum][i].dist)
						tlist[pnum][i].dist = 1;
					temp = (dmg * tlist[pnum][i].dist) / 100;
				}
				else
					temp = dmg;
				
				HandleDamageDeal(owner, tlist[pnum][i].tid, temp, damage_type, flags, GetActorX(owner), GetActorY(owner), GetActorZ(owner), actor_flags, extra, scan_fov);
				SpawnForced(ScannerAttackParticles[scan_id], GetActorX(tlist[pnum][i].tid), GetActorY(tlist[pnum][i].tid), GetActorZ(tlist[pnum][i].tid) + ScanAttackData[scan_id].spawn_offZ, 0);
				
				//printbold(s:"do scan damage of ", d:temp, s: " dist: ", d:tlist[pnum][i].dist, s: " to ", s:GetActorClass(tlist[pnum][i].tid), s:" ", d:tlist[pnum][i].tid, s:" -- j = ", d:j, s: " / ", d:tcount, s: " index: ", d:i);
				// abort if we reached our tracer cap
				++j;
				if(j == tcount)
					break;
			}
		}
		//printbold(s:"complete? ", d:j, s: " vs ", d:tcount);
	}
}

Script "DND Thunderstaff Bolts" (void) {
	int dist = INT_MAX, i, j, k, temp;
	// scan all monsters for the item ThunderTarget -- that implies they are candidates having passed range check
	static dist_tid_pair_T tlist[MAXPLAYERS][DND_THUNDERSTAFF_MAXTARGETS];
	
	int owner = GetActorProperty(0, APROP_TARGETTID);
	int pnum = owner - P_TIDSTART;
	
	// init list
	for(i = 0; i < DND_THUNDERSTAFF_MAXTARGETS; ++i) {
		tlist[pnum][i].tid = 0;
		tlist[pnum][i].dist = INT_MAX;
	}
	int tcount = 0;
	int tidlim = 0;
	// pick N closest targets as a list of targets to hit
	for(i = DND_MONSTERTID_BEGIN; i < DnD_TID_List[DND_TID_MONSTER]; ++i) {
		if(CheckActorInventory(i, "ThunderTarget") && IsActorAlive(i) && CheckFlag(i, "SHOOTABLE")) {
			dist = fdistance(0, i);
			// insert sorted
			if(tcount < DND_THUNDERSTAFF_MAXTARGETS)
				temp = tcount;
			else
				temp = DND_THUNDERSTAFF_MAXTARGETS;
			// while our calc dist > alloc dist, keep going -- we add things to the end
			// if we come by a point where we are smaller, shift things
			for(j = 0; j < temp && dist > tlist[pnum][j].dist; ++j);

			// we know where to add, check if we must shift (if we should)
			if(j < temp) {
				// less, so that means we are in-between things
				// push everything for insertion
				// this is needed to move in 0 index shifts
				if(temp == DND_THUNDERSTAFF_MAXTARGETS)
					--temp;
				
				for(k = temp; k > j; --k) {
					// slide data
					tlist[pnum][k].dist = tlist[pnum][k - 1].dist;
					tlist[pnum][k].tid = tlist[pnum][k - 1].tid;
				}
			}
			
			tlist[pnum][j].dist = dist;
			tlist[pnum][j].tid = i;
			
			if(tcount < DND_THUNDERSTAFF_MAXTARGETS)
				++tcount;
		}
	}
	
	if(tcount) {
		int actor_flags = ScanActorFlags();
	
		for(i = 0; i < DND_THUNDERSTAFF_MAXTARGETS; ++i) {
			if(tlist[pnum][i].tid)
				ACS_NamedExecuteAlways("DND Trail Spawner", 0, DND_TRAILACTOR_THUNDERZAP, 16, tlist[pnum][i].tid);
		}
		
		int px = GetActorX(0);
		int py = GetActorY(0);
		int pz = GetActorZ(0);
		
		// damage credit
		SetActivatorToTarget(0);
		dist = ACS_NamedExecuteWithResult("DND Weapon Damage Retrieve", DND_DMGID_1 | (DND_WEAPON_THUNDERSTAFF << 16), TALENT_ELEMENTAL, DND_WDMG_LIGHTNINGDAMAGE);
		
		// weapon mod checks
		temp = Player_Weapon_Infos[pnum][DND_WEAPON_THUNDERSTAFF].wep_mods[WEP_MOD_PERCENTDAMAGE].val;
		j = 0;
		if(temp)
			j |= DND_DAMAGEFLAG_PERCENTHEALTH;
		
		// force pain mod
		if(
			Player_Weapon_Infos[pnum][DND_WEAPON_THUNDERSTAFF].wep_mods[WEP_MOD_FORCEPAINCHANCE].val && 
			Player_Weapon_Infos[pnum][DND_WEAPON_THUNDERSTAFF].wep_mods[WEP_MOD_FORCEPAINCHANCE].val > random(1, 100)
		) {
			actor_flags |= DND_ACTORFLAG_FORCEPAIN;
		}

		if(Player_Weapon_Infos[pnum][DND_WEAPON_THUNDERSTAFF].wep_mods[WEP_MOD_POISONFORPERCENTDAMAGE].val)
			j |= DND_DAMAGEFLAG_INFLICTPOISON;
		
		for(i = 0; i < DND_THUNDERSTAFF_MAXTARGETS; ++i) {
			if(tlist[pnum][i].tid)
				HandleDamageDeal(owner, tlist[pnum][i].tid, dist, DND_DAMAGETYPE_LIGHTNING, j, px, py, pz, actor_flags, temp, Player_Weapon_Infos[pnum][DND_WEAPON_THUNDERSTAFF].wep_mods[WEP_MOD_POISONFORPERCENTDAMAGE].val);
		}
	}
}

Script "DND ThunderStaff FX Spawn" (int target) CLIENTSIDE {
	SpawnForced("ThunderStaffLightningFX", GetActorX(target), GetActorY(target), GetActorFloorZ(target));
}

Script "DND Thunder Ring" (int radius) CLIENTSIDE {
	int tid = ActivatorTID(), i; // Owner TID
	int newtid = tid + DND_THUNDER_RING_TIDSTART + 32 * ((tid + 1) % 100);
	
	for(i = 0; i < 32; ++i)
		Thing_Remove(newtid + i);
	
	int cx, cy, cz, r_add, angadd = 0;
	int pang = GetActorAngle(tid) >> 8;
	cz = GetActorZ(tid);
	
	for(i = 0; i < 32; ++i) {
		cx = GetActorX(tid) + radius * cos(pang << 8) / 32;
		cy = GetActorY(tid) + radius * sin(pang << 8) / 32;
		pang += 8;
		Spawn("ThunderStaffRingFX", cx, cy, cz + 26.825, newtid + i, 0);
		SetActivator(newtid + i);
		SetPointer(AAPTR_TARGET, tid);
		SetActivator(tid);
	}
	Delay(const:1);
	while(CheckInventory("ThunderRangeCounter") && IsAlive() && !CheckInventory("ThunderStopRing")) {
		r_add = DND_THUNDER_RADIUSPERCOUNT * CheckInventory("ThunderRangeCounter");
		pang = 0;
		for(i = 0; i < 32; ++i) {
			pang += 8;
			if(GetActorFloorZ(newtid + i) > GetActorZ(tid))
				cz = GetActorFloorZ(newtid + i);
			cx = GetActorX(tid) + (radius + r_add) * cos((pang << 8) + angadd);
			cy = GetActorY(tid) + (radius + r_add) * sin((pang << 8) + angadd);
			SetActorPosition(newtid + i, cx, cy, cz + 26.825, 0);
		}
		angadd += 0.025;
		angadd %= 1.0;
		Delay(const:1);
	}
	for(i = 0; i < 32; ++i)
		SetActorState(newtid + i, "Fade");
}

Script "DND Thunderstaff Lightning" (void) {
	int i, this = ActivatorTID();
	int dmg = ACS_NamedExecuteWithResult("DND Weapon Damage Retrieve", DND_DMGID_2 | (DND_WEAPON_THUNDERSTAFF << 16), TALENT_ELEMENTAL, DND_WDMG_LIGHTNINGDAMAGE) << 1;
	int actor_flags = DND_ACTORFLAG_NOPUSH;
	int pnum = PlayerNumber();
	
	// force pain mod
	if(
		Player_Weapon_Infos[pnum][DND_WEAPON_THUNDERSTAFF].wep_mods[WEP_MOD_FORCEPAINCHANCE].val && 
		Player_Weapon_Infos[pnum][DND_WEAPON_THUNDERSTAFF].wep_mods[WEP_MOD_FORCEPAINCHANCE].val > random(1, 100)
	) {
		actor_flags |= DND_ACTORFLAG_FORCEPAIN;
	}
	
	int temp = Player_Weapon_Infos[pnum][DND_WEAPON_THUNDERSTAFF].wep_mods[WEP_MOD_POISONFORPERCENTDAMAGE].val;
	int extra = Player_Weapon_Infos[pnum][DND_WEAPON_THUNDERSTAFF].wep_mods[WEP_MOD_PERCENTDAMAGE].val;
	int flags = 0;
	if(temp)
		flags |= DND_DAMAGEFLAG_INFLICTPOISON;
	if(extra)
		flags |= DND_DAMAGEFLAG_PERCENTHEALTH;
	
	for(i = DND_MONSTERTID_BEGIN; i < DnD_TID_List[DND_TID_MONSTER]; ++i) {
		if(CheckActorInventory(i, "ThunderStrike") && IsActorAlive(i) && CheckFlag(i, "SHOOTABLE")) {
			ACS_NamedExecuteAlways("DND ThunderStaff FX Spawn", 0, i);
			SpawnForced("ThunderstaffExp", GetActorX(i), GetActorY(i), GetActorFloorZ(i) + 16.0, DND_THUNDERSTAFF_DAMAGERTID);
			
			HandleDamageDeal(this, i, dmg, DND_DAMAGETYPE_LIGHTNING, flags, 0, 0, 0, actor_flags, extra, temp);
			
			SetActivator(DND_THUNDERSTAFF_DAMAGERTID);
			SetPointer(AAPTR_TARGET, this);
			SetActorProperty(DND_THUNDERSTAFF_DAMAGERTID, APROP_TARGETTID, this);
			Thing_ChangeTID(DND_THUNDERSTAFF_DAMAGERTID, 0);
			SetActivator(this);
		}
	}
}

Script "DND Thunder Range" (void) {
	SetResultValue(DND_THUNDERSTAFF_BASERANGE + DND_THUNDER_RADIUSPERCOUNT * CheckInventory("ThunderRangeCounter"));
}

Script "DND HeavyGL Check" (int x, int y, int z) {
	int res = 1;
	if (!(GetActorZ(0) - GetActorFloorZ(0) > 4.0))
		res = sqrt(x*x + y*y + z*z);
	SetResultValue(res);
}

Script "DnD Gravdis Thrust" (int pull_count, int force) {
	int x = GetActorX(0);
	int y = GetActorY(0);
	int z = GetActorZ(0);
	
	int j = pull_count;
	while(j) {
		for(int i = DND_MONSTERTID_BEGIN; i < DnD_TID_List[DND_TID_MONSTER]; ++i) {
			if(CheckActorInventory(i, "GravdisDebuff") && isActorAlive(i)) {
				// get angle to face and thrust it towards this
				int fx = x - GetActorX(i);
				int fy = y - GetActorY(i);
				int mforce = force / (2 * GetActorProperty(i, APROP_MASS));
				if(mforce)
					ThrustThing(VectorAngle(fx, fy) >> 8, mforce, 1, i);
			}
		}
		Delay(const:2);
		--j;
	}
	SetResultValue(0);
}

Script "DnD Gravdis Debuff" (int base_dmg) {
	int owner = GetActorProperty(0, APROP_TARGETTID);
	int i, m_id;
		
	int dmg = ACS_NamedExecuteWithResult("DND Weapon Damage Retrieve", DND_DMGID_0 | (DND_WEAPON_GRAVDIS << 16), TALENT_BULLET, DND_WDMG_USETARGET | DND_WDMG_ISSLOT5);
	bool got_one = false;
	
	for(i = DND_MONSTERTID_BEGIN; i < DnD_TID_List[DND_TID_MONSTER]; ++i) {
		// to be affected by gravdis debuff
		if(CheckActorInventory(i, "GravdisToken") && IsActorAlive(i)) {
			TakeActorInventory(i, "GravdisToken", 1);
			// dont affect teleporting / unshootable things
			if(!CheckFlag(i, "SHOOTABLE"))
				continue;
			// this allows other people or even the same player to elevate monsters higher and keep stunning them for longer for more damage potential
			if(!CheckActorInventory(i, "GravdisDebuff"))
				ACS_NamedExecuteWithResult("DnD Gravdis Flinger", i, owner, dmg, base_dmg);
			else
				ACS_NamedExecuteWithResult("DnD Gravdis Elevate", i, dmg, base_dmg);
				
			// bosses arent as affected by this
			m_id = MonsterProperties[i - DND_MONSTERTID_BEGIN].id;
			if(!IsMonsterIdBoss(m_id))
				SetActorInventory(i, "GravdisDebuff", GRAVDIS_DELAY_TIME);
			else
				SetActorInventory(i, "GravdisDebuff", GRAVDIS_DELAY_TIME / 5);
			SetActorState(i, "GravdisFling", 0);
			PlaySound(i, "Gravdis/Grab", 7, 1.0);
			got_one = true;
		}
	}
	
	if(got_one)
		GiveActorInventory(owner, "GravdisCanAlt", 1);

	SetResultValue(0);
}

Script "DnD Gravdis Flinger" (int victim, int dmg_source, int damage, int base_dmg) {
	int m = Clamp_Between(GetActorProperty(victim, APROP_MASS) / (4 * damage / base_dmg), 16, 4096);
	bool was_flying = CheckFlag(victim, "NOGRAVITY");
	
	GiveActorInventory(victim, "AllowFlight", 1);
	if(was_flying)
		GiveActorInventory(victim, "TakeFloat", 1);
	
	for(int i = 0; i < HALF_TICRATE; ++i) {
		SetActorVelocity(victim, 0, 0, GRAVDIS_FLING_FACTOR * cos((0.25 / (HALF_TICRATE - 1)) * i) / m, true, false);
		Delay(const:1);
	}
	
	SetActorVelocity(victim, 0, 0, 0, false, false);
	
	// damage portion of gravdis
	// wait for the effect
	while(CheckActorInventory(victim, "GravdisDebuff")) {
		TakeActorInventory(victim, "GravdisDebuff", 1);
		
		if(CheckActorInventory(dmg_source, "GravdisDunk")) {
			PlaySound(victim, "Gravdis/TimeOut", 7, 1.0);
			ACS_NamedExecuteWithResult("DnD Gravdis FX Spawner", victim, 0);
			Delay(const:7);
			SetActorInventory(victim, "GravdisDebuff", 0);
			break;
		}
		
		if(CheckActorInventory(victim, "GravdisDebuff") == 1) {
			PlaySound(victim, "Gravdis/TimeOut", 7, 1.0);
			ACS_NamedExecuteWithResult("DnD Gravdis FX Spawner", victim, 0);
		}
		Delay(const:7);
	}
	
	// pull down
	int height = GetActorZ(victim) - GetActorFloorZ(victim);
	SetActorVelocity(victim, 0, 0, -height / 2, false, false);
	
	// while actor is above ground, wait
	// no change for 2 tics can imply the unit landed somewhere and is no longer moving
	int prev_z;
	bool landed = false;
	do {
		prev_z = GetActorZ(victim);
		Delay(const:2);
		landed = prev_z == GetActorZ(victim) || prev_z - GetActorFloorZ(victim) <= 4.0;
	} while(!landed);
	
	PlaySound(victim, "Gravdis/Drop", 6, 1.0);
	
	if(!was_flying)
		GiveActorInventory(victim, "TakeFlight", 1);
	else {
		GiveActorInventory(victim, "AllowFloat", 1);
		// flying monsters need the line below, they dont move up or down otherwise for some reason
		SetActorVelocity(victim, 0, 0, 1, true, false);
	}
	
	// apply the damage
	int height_factor = (GRAVDIS_HEIGHT_FACTOR * height / GRAVDIS_HEIGHTADD_PER) >> 16;
	SetActivator(dmg_source);
	HandleImpactDamage(dmg_source, victim, damage * (100 + height_factor) / 100, DND_DAMAGETYPE_PHYSICAL, DND_DAMAGEFLAG_FOILINVUL, DND_WEAPON_GRAVDIS);
	ACS_NamedExecuteWithResult("DnD Gravdis FX Spawner", victim, 1);
	
	SetResultValue(0);
}

Script "DnD Gravdis FX Spawner" (int id, int which) CLIENTSIDE {
	switch(which) {
		case 0:
			GiveActorInventory(id, "GravdisPullFX_Spawner", 1);
		break;
		case 1:
			GiveActorInventory(id, "GravdisLandFX_Spawner", 1);
		break;
	}
}

Script "DnD Gravdis Hit Fx" (int r) CLIENTSIDE {
	int p = 0;
	int x = GetActorX(0);
	int y = GetActorY(0);
	int z = GetActorZ(0);
	
	for(int i = 0; i < GRAVDIS_CIRCLE_PARTICLES; ++i) {
		p = 1.0 / (GRAVDIS_CIRCLE_PARTICLES - 1) * i;
		SpawnForced("GravdisBorderParticle", x + r * cos(p), y + r * sin(p), z, 0);
	}
}

// This script is used just to stack the elevation portion from multiple sources, but whoever initially triggered the first one will get all credit
Script "DnD Gravdis Elevate" (int victim, int damage, int base_dmg) {
	int m = Clamp_Between(GetActorProperty(victim, APROP_MASS) / (4 * damage / base_dmg), 16, 4096);
	
	GiveActorInventory(victim, "AllowFlight", 1);
	
	for(int i = 0; i < HALF_TICRATE; ++i) {
		SetActorVelocity(victim, 0, 0, GRAVDIS_FLING_FACTOR * cos((0.25 / (HALF_TICRATE - 1)) * i) / m, true, false);
		Delay(const:1);
	}
	
	SetActorVelocity(victim, 0, 0, 0, false, false);
	
	SetResultValue(0);
}

Script "DnD Toggle NoPain" (void) {
	// only take away this if the monster initially did not have it, some monsters have this and we dont want to deprive it of that flag
	if(!MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[DND_NOPAIN])
		GiveInventory("TakeNoPain", 1);
}

Script "DND Orb Use Message" (int affluence) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	Delay(5);
	HandleOrbUseMessage(CheckInventory("OrbUseType") - 1, CheckInventory("OrbResult"), affluence);
}

Script "DND Orb Use Message (Server)" (void) {
	ACS_NamedExecuteAlways("DND Orb Use Message", 0, GetAffluenceBonus());
}

Script "DND Orb Use" (int orbtype, int extra, int extra2) {
	int pnum = PlayerNumber();
	HandleOrbUse(pnum, orbtype, extra, extra2);
	LocalAmbientSound("Items/OrbUse", 127);
	ACS_NamedExecuteAlways("DND Orb Use Message", 0, GetAffluenceBonus());
	ACS_NamedExecuteAlways("DnD Force Damage Cache Recalculation", 0, pnum);
	Delay(const:2);
	if(orbtype != DND_ORB_AFFLUENCE)
		SetInventory("AffluenceCounter", 0);
}

Script "DnD Timed Monster" (int time, int isPet) {
	int cnt = 0;
	while(cnt++ != time)
		Delay(const:35);
	if(!isPet)
		SetActorState(0, "Remove");
	else
		Thing_Damage(0, GetActorProperty(0, APROP_HEALTH) + 1);
}

Script "DnD Overheat Reduction" (int index, int rate) {
	int d = (rate & 0xFFFF0000) >> 16;
	rate &= 0x0000FFFF;
	// prevent multiple copies, also dont keep this busy if we got no overheat bonus
	if(!IsSet(PlayerRunsOverheat[PlayerNumber()], index) && !CheckInventory("DnD_QuestReward_GodSlayerBonus")) {
		PlayerRunsOverheat[PlayerNumber()] = SetBit(PlayerRunsOverheat[PlayerNumber()], index);
		while(CheckInventory(WeaponOverheatItems[index])) {
			if(CheckInventory("DnD_OverheatCanReduce"))
				TakeInventory(WeaponOverheatItems[index], rate);
			Delay(d);
		}
		PlayerRunsOverheat[PlayerNumber()] = ClearBit(PlayerRunsOverheat[PlayerNumber()], index);
	}
}

Script "DND Hardcore Timer" (void) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	SetFont("BIGFONT");
	SetHudSize(640, 480, 0);
	int lim = Clamp_Between(GetCVar("dnd_loadtime"), DND_HARDCORE_LOADTIME, 100) << 1;
	for(int i = 0; i < lim && PlayerInGame(PlayerNumber()) && CheckInventory("CanLoad"); ++i) {
		if (CheckInventory("PlayerIsLoggedIn"))
			HudMessage(l:"DND_TEXT_YOUHAVE", s:" \cd", d:lim / 2 - i / 2, s:"\c- ", l:"DND_TEXT_LOADCHARWARNING"; HUDMSG_PLAIN, DND_HARDCORE_SCREENID, CR_RED, 320.4, 240.0, 0);
		else
			HudMessage(l:"DND_TEXT_YOUHAVE", s:" \cd", d:lim / 2 - i / 2, s:"\c- ", l:"DND_TEXT_LOADLOGINWARNING"; HUDMSG_PLAIN, DND_HARDCORE_SCREENID, CR_RED, 320.4, 240.0, 0);

		Delay(const:TICRATE / 2);
	}
}

Script "DND Wait For Other Players Message" (int players_not_ready) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	SetFont("BIGFONT");
	SetHudSize(640, 480, 0);
	if (players_not_ready == 1)
		HudMessage(l:"DND_TEXT_WAITINGFOR", s:" \cd", d:players_not_ready, s:"\c- ", l:"DND_TEXT_PLAYERTOLOAD"; HUDMSG_PLAIN, DND_HARDCORE_SCREENID, CR_RED, 320.4, 240.0, 0);
	else
		HudMessage(l:"DND_TEXT_WAITINGFOR", s:" \cd", d:players_not_ready, s:"\c- ", l:"DND_TEXT_PLAYERSTOLOAD"; HUDMSG_PLAIN, DND_HARDCORE_SCREENID, CR_RED, 320.4, 240.0, 0);
}

Script "DND Hardcore Monster Message" (void) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	Delay(const:1);
	SetFont("BIGFONT");
	SetHudSize(640, 480, 0);
	HudMessage(l:"DND_TEXT_LOADINGMONS"; HUDMSG_PLAIN, DND_HARDCORE_SCREENID, CR_RED, 320.4, 240.0, 0);
	Delay(const:17 * (DND_MAX_MONSTERDELAY + 2)); // Add 3 seconds to it to allow player script to finish first.
	HudMessage(s:""; HUDMSG_PLAIN, DND_HARDCORE_SCREENID, CR_RED, 320.0, 240.0, 1);
}

// skip wait for load on this guy
Script 1004 (void) NET {
	int pnum = PlayerNumber();
	if (PlayerInGame(pnum) && CheckInventory("CanLoad"))
	{
		if (PlayerIsLoggedIn(pnum))
		{
			if (ACS_NamedExecuteWithResult("DnD Load Character Check", pnum, 0) == 11) //DND_CHARLOADED
				ACS_ExecuteAlways(1001,0,0);
			else if (ACS_NamedExecuteWithResult("DnD Create Character Check", pnum, 0) == 1) //DND_LOGIN_CREATECHAROK
				ACS_ExecuteAlways(1003,0,0);
		}
		else {
			SetInventory("CanLoad", 0);
			PlayerCanLoad[pnum] = 0;
		}
	}
}

// receive user settings from client => server
Script "DnD User CVAR Status Receive" (int bits) NET {
	int tid = ActivatorTID();
	SetActorInventory(tid, "DashDisabled", bits & 1);
}

Script "DnD Drop Orb" (void) {
	SpawnOrbForAll(1);
}

Script "DnD Play Local Item Drop Sound" (int who, int droptype) CLIENTSIDE {
	if(ConsolePlayerNumber() != who)
		Terminate;
	switch(droptype) {
		case DND_ITEM_CHARM:
			PlaySound(0, "Items/CharmDrop", 4);
		break;
		case DND_ITEM_ORB:
			PlaySound(0, "Items/OrbDrop", 5);
		break;
		case DND_ITEM_TOKEN:
			Playsound(0, "Items/TokenDrop", 6);
		break;
	}
}

Script "DnD Chest Opened" (int ctype) {
	HandleChestDrops(ctype);
}

Script "DnD Check Special GameMode" (void) {
	SetResultValue(HardcoreSet);
}

Script "DnD Talisman Mark Timer" (int counter) {
	GiveInventory("HunterTalismanMarkBool", 1);
	for(int i = 0; i < counter && isAlive(); ++i)
		Delay(35);
	TakeInventory("HunterTalismanMarkBool", 1);
}

Script "DnD Talisman Mark" (void) CLIENTSIDE {
	int this = ActivatorTID();
	Spawn("HunterTalismanFX", GetActorX(0), GetActorY(0), GetActorZ(0) + 48.0, DND_TALISMAN_MARK);
	SetActivator(DND_TALISMAN_MARK);
	SetPointer(AAPTR_TARGET, this);
	SetActorProperty(0, APROP_TARGETTID, this);
	Thing_ChangeTID(DND_TALISMAN_MARK, 0);
}

Script "DnD Chest Dropping Item" (int chance_penalty) {
	while(GetGameModeState() != GAMESTATE_INPROGRESS)
		Delay(const:TICRATE);
	// additional delay for the map difficulty calculator
	Delay(const:TICRATE);
	HandleChestSpawn(chance_penalty);
}

Script "DnD Give Research" (int sp) {
	SetActivator((sp & 0xFFFF) + P_TIDSTART);
	GiveInventory("ResearchSoundPlayer", 1);
	ACS_NamedExecuteAlways("DnD Message Logger", 0, 2, sp, 1);
	GiveResearch(sp >> 16, false);
}

Script "DnD Give Research - Regular" (int res_id, int fancy) {
	if(CheckResearchStatus(res_id) == RES_NA) {
		GiveInventory("ResearchSoundPlayer", 1);
		GiveResearch(res_id, fancy);
	}
}

Script "DnD Orb Message" (int id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	Log(s:StrParam(s:"\cc", l:"DND_PICKUP_ORB", s:": \c[Y5]", l:GetInventoryTag(id + ORBS_BEGIN), s:"!\c-"));
}

Script "DnD Elixir Message" (int id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	ActivatorSound("Items/ElixirPick", 127);
	Log(s:StrParam(s:"\cc", l:"DND_PICKUP_ELIXIR", s:": \c[Y5]", l:GetInventoryTag(id + ELIXIR_BEGIN), s:"!\c-"));
}

Script "DnD Token Message" (int id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	ActivatorSound("Items/TokenPick", 127);
	Log(s:StrParam(s:"\cc", l:"DND_PICKUP_TOKEN", s:": \c[Y5]", l:GetInventoryTag(id + TOKEN_BEGIN), s:"!\c-"));
}

Script "DnD Stacked Item Pickup" (int sp, int type) {
	if((sp & 0xFFFF) == 255)
		SetActivatorToTarget(0);
	else
		SetActivator((sp & 0xFFFF) + P_TIDSTART);
	if(type == DND_STACKEDITEM_ORB) {
		ACS_NamedExecuteAlways("DnD Orb Message", 0, Inventories_On_Field[sp >> 16].item_subtype);
		GiveInventory("OrbSoundPlayer", 1);
	}
	else if(type == DND_STACKEDITEM_CHESTKEY) {
		ACS_NamedExecuteAlways("DnD Chestkey Message", 0, Inventories_On_Field[sp >> 16].item_subtype);
		GiveInventory("ChestkeySoundPlayer", 1);
	}
	else if(type == DND_STACKEDITEM_ELIXIR) {
		ACS_NamedExecuteAlways("DnD Elixir Message", 0, Inventories_On_Field[sp >> 16].item_subtype);
		GiveInventory("ElixirSoundPlayer", 1);
	}
	else if(type == DND_STACKEDITEM_TOKEN) {
		ACS_NamedExecuteAlways("DnD Token Message", 0, Inventories_On_Field[sp >> 16].item_subtype);
		GiveInventory("TokenSoundPlayer", 1);
	}
	HandleStackedPickup(sp >> 16);
}

Script "DnD Drop Research" (void) {
	// this guarantees the activator is the player that opened it
	SetActivatorToTarget(0);
	SpawnResearch(ActivatorTID() - P_TIDSTART);
}

// From HardDoom v83
Script "DnD Footstep Sound" ENTER CLIENTSIDE {
	int DelayTime, StepVolume, x;
	int pnum = PlayerNumber();
	while(PlayerInGame(pnum)) {
		Delay(const:1);
		x = min(GetPVelocity(), 9);
		DelayTime = 16 - GetPVelocity() / 2;
		StepVolume = 7 * x;
		if(GetActorZ(0) - GetActorFloorZ(0) == 0)
			ActivatorSound(DefStepSound, StepVolume);
		Delay(DelayTime);
	}
}

Script "DnD Weapon Can Switch Mode" (int ammo_category, int weptype) {
	// prevent switching while in menu
	SetResultValue(!CheckInventory("ShowingMenu") && CanSwitchMode(ammo_category, weptype));
}

Script "DnD Get Target" (void) {
	SetActivatorToTarget(0);
	SetResultValue(ActivatorTID());
}

Script "DnD Get Target of Target" (void) {
	SetActivatorToTarget(0);
	SetActivatorToTarget(0);
	SetResultValue(ActivatorTID());
}

Script "DnD Get Master of Target" (void) {
	SetActivatorToTarget(0);
	SetResultValue(GetActorProperty(0, APROP_MASTERTID));
}

Script "target test" (void) {
	printbold(s:"target test before: ", s:GetActorClass(GetActorProperty(0, APROP_TARGETTID)), s:" ", d:GetActorProperty(0, APROP_TARGETTID));
	SetActivator(0, AAPTR_TARGET);
	printbold(s:"target test mid: ", s:GetActorClass(GetActorProperty(0, APROP_TARGETTID)), s:" ", d:GetActorProperty(0, APROP_TARGETTID));
	SetActivator(0, AAPTR_TARGET);
	printbold(s:"target test after: ", s:GetActorClass(0), s:" ", d:ActivatorTID());
}

Script "DnD Target Fix" (void) {
	// if none assigned
	if(!GetActorProperty(0, APROP_TARGETTID)) {
		int tid = ACS_NamedExecuteWithResult("DnD Get Target of Target");
		SetActorProperty(0, APROP_TARGETTID, tid);
		SetPointer(AAPTR_TARGET, tid);	
	}
	SetResultValue(0);
}

Script "DnD Player Pain Sound" (void) CLIENTSIDE {
	int ptype = CheckInventory("DnD_Character");
	// special pain sound range handling for hobo, punisher and marine
	if(ptype >= 2 && ptype <= 4 || ptype == 6)
		HandlePlayerPainSound(ptype);
}

Script "DnD Research Fancy Message" (int res_id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	Log(s:"\cc", l:"DND_PICKUP_RESEARCH", s:":\c[Y5] ", l:GetResearchLabel(res_id), s:"!");
	LocalAmbientSound("items/research", 127);
	ACS_NamedExecuteAlways("DND Announcer", 0, DND_ANNOUNCER_RESEARCHDISCOVER, res_id);
}

Script "DnD Is Demon" (void) {
	SetActivator(0, AAPTR_TRACER);
	SetResultValue(ActivatorTID() && IsDemon());
}

Script "DnD Is Demon - Self" (void) {
	SetResultValue(ActivatorTID() && IsDemon());
}

Script "DnD Give Ammo" (int slot, int ammotype, int amount) {
	GiveAmmo(amount, slot, ammotype);
}

Script "DnD Give Ammo To Target" (int slot, int ammotype, int amount) {
	SetActivatorToTarget(0);
	GiveAmmo(amount, slot, ammotype);
}

Script "DnD Emerald Death" (void) {
	int this = ActivatorTID();
	SetActivatorToTarget(0);
	int target = ActivatorTID();
	if(CheckInventory("NetherCheck"))
		Spawn("EmeraldDeathActor_FullDMG", GetActorX(this), GetActorY(this), GetActorZ(this) + GetActorProperty(this, APROP_HEIGHT) / 2, target + DND_EMERALD_TIDADD);
	else
		Spawn("EmeraldDeathActor", GetActorX(this), GetActorY(this), GetActorZ(this) + GetActorProperty(this, APROP_HEIGHT) / 2, target + DND_EMERALD_TIDADD);
	SetActivator(target + DND_EMERALD_TIDADD);
	SetPointer(AAPTR_TARGET, target);
	Thing_ChangeTID(0, 0);
}

Script "DnD Charm Message" (int id, int type) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	if(type > UNIQUE_BEGIN) {
		type = (type >> UNIQUE_BITS) - 1;
		Log(s:StrParam(s:"\cc", l:"DND_PICKUP_CHARM", s:": \c[Y5]", l:GetUniqueItemName(type), s:"!\c-"));
	}
	else
		Log(s:StrParam(s:"\cc", l:"DND_PICKUP_CHARM", s:": \c[Y5]", l:GetCharmTypeName(id), s:"!\c-"));
}

Script "DnD Charm Pickup" (int sp) {
	if((sp & 0xFFFF) == 255)
		SetActivatorToTarget(0);
	else
		SetActivator((sp & 0xFFFF) + P_TIDSTART);
	ACS_NamedExecuteAlways("DnD Charm Message", 0, Inventories_On_Field[sp >> 16].item_subtype, Inventories_On_Field[sp >> 16].item_type);
	GiveInventory("CharmSoundPlayer", 1);
	HandleCharmPickup(sp >> 16);
}

// if we have enough space and we pressed use
Script "DnD Player Has Spot For Item" (int sp) {
	if (GetGameModeState() == GAMESTATE_INPROGRESS) {
		if((sp & 0xFFFF) == 255)
			SetActivatorToTarget(0);
		else
			SetActivator((sp & 0xFFFF) + P_TIDSTART);
		//if (!CheckInventory("CanLoad")) { //BUG: This check is needed to prevent grabbing items before loading char, but had to comment because of extreme lag.
			int pnum = PlayerNumber();
			bool spot = false;
			if(Inventories_On_Field[sp >> 16].item_stack)
				spot = GetFreeSpotForItemWithStack(sp >> 16, pnum, DND_SYNC_ITEMSOURCE_FIELD) != -1;
			else
				spot = GetFreeSpotForItem(sp >> 16, pnum, DND_SYNC_ITEMSOURCE_FIELD) != -1;
			bool res = CheckInventory("DnD_PressedUse") && !CheckInventory("DnD_WaitNextItemPick");
			if(res)
				GiveInventory("DnD_WaitNextItemPick", 1);
			
			if(!spot && res) {
				// clientside warning sound and text
				ACS_NamedExecuteAlways("DnD Inventory Full CS", 0, pnum);
			}
			SetResultValue(res && spot);
		//}
	}
	else
		SetResultValue(false);
}

Script "DnD Inventory Full CS" (int pnum) CLIENTSIDE {
	if(ConsolePlayerNumber() != pnum)
		Terminate;
	LocalAmbientSound("RPG/MenuError", 127);
	Log(s:"\cg", l:"DND_TEXT_NOTIFICATION", s:": \c[Y5]", l:"DND_TEXT_INVENTORYFULL", s:"!");
}

// Player picks up item
Script "DnD Preview Item" (int sp, int target) CLIENTSIDE {
	if((sp & 0xFFFF) == 255) {
		SetActivatorToTarget(0);
		if(!ActivatorTID())
			SetActivator(target);
	}
	else
		SetActivator((sp & 0xFFFF) + P_TIDSTART);
		
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	int field_index = sp >> 16;
	DrawInventoryInfo_Field(PlayerNumber(), field_index, DND_SYNC_ITEMSOURCE_FIELD, 16.0, false);
}

Script "DnD Chestkey Message" (int id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	Log(s:StrParam(s:"\cc", l:"DND_PICKUP_BONUS", s:": \c[Y5]", l:GetInventoryTag(id + CHESTKEY_BEGIN), s:"!\c-"));
}

Script "DnD Try Open Chestkey" (int keytype) {
	int res = -1;
	if ((GetGameModeState() == GAMESTATE_INPROGRESS) && (!CheckActorInventory(GetActorProperty(0, APROP_TARGETTID), "CanLoad"))) {
		res = CheckPlayerInventoryList(GetActorProperty(0, APROP_TARGETTID) - P_TIDSTART, DND_ITEM_CHESTKEY, keytype);
		if(res != -1) {
			SetActivatorToTarget(0);
			UsePlayerItem(PlayerNumber(), res);
		}
	}
	SetResultValue(res != -1);
}

Script "DnD Pellet Count" (int base, int flags) {
	if(flags & DND_WDMG_USETARGET)
		SetactivatorToTarget(0);
	int pnum = PlayerNumber();
	int res = 100 + GetPlayerAttributeValue(pnum, INV_PELLET_INCREASE);
	
	if(CheckInventory("Hobo_Perk50"))
		res += DND_HOBO_SHOTGUNPELLETBONUS;
		
	// dummy crit call here to obtain crit status item
	//HandleWeaponCrit(0, CheckInventory("DnD_WeaponID"), pnum, 0, false);
	//PlayerCritState[pnum][DND_CRITSTATE_NOCALC] = true;
	
	SetResultValue(res * base / 100); 
}

Script "DnD Explosion Radius Retrieve" (int flags) {
	if(flags & DND_WDMG_USETARGET)
		SetactivatorToTarget(0);
	else if(flags & DND_WDMG_USEMASTER) {
		if(flags & DND_WDMG_SETMASTER) // this is a hack
			SetPointer(AAPTR_TARGET, GetActorProperty(0, APROP_MASTERTID));
		SetActivator(GetActorProperty(0, APROP_MASTERTID));
	}
	else if(flags & DND_WDMG_USETARGETSMASTER) {
		SetActivator(ACS_NamedExecuteWithResult("DnD Get Master of Target"));
	}
	SetResultValue(GetPlayerAttributeValue(PlayerNumber(), INV_EXPLOSION_RADIUS));
}

// after 16th bit there can be extra info
// never put AMMO_CLIP as 16 bit onwards
Script "DnD Ammo Gain Chance" (int slot, int ammo, int amount) {
	bool isSpecial = false;
	int extra = -1;
	if(random(1, 100) <= GetPlayerAttributeValue(PlayerNumber(), INV_AMMOGAIN_CHANCE)) {
		if(slot == DND_AMMOSLOT_MAGAZINE)
			GiveInventory(ClipAmmoTypes[ammo], amount);
		else if(slot == DND_AMMOSLOT_SPECIAL) {
			GiveInventory(SpecialAmmoInfo_Str[ammo][AMMOINFO_NAME], amount);
			isSpecial = true;
			extra = ammo;
		}
		else if(slot == DND_AMMOSLOT_TEMPORARY) {
			GiveInventory(TemporaryWeaponData[ammo][TEMPWEP_AMMO], amount);
			if(ammo == DND_TEMPWEP_SOULRENDER)
				GiveInventory("BladeCharge", 100);
		}
		else
			GiveInventory(AmmoInfo_Str[slot][ammo][AMMOINFO_NAME], amount);
	}
	
	// ammo gain triggering means we made an attack
	ACS_NamedExecuteWithResult("DnD On Attack", isSpecial, extra);
}

Script "DnD Charon Stack Gain Chance" (void) {
	if(random(1, 100) <= GetPlayerAttributeValue(PlayerNumber(), INV_AMMOGAIN_CHANCE))
		GiveInventory("CharonStacks", 1);
	
	// ammo gain triggering means we made an attack
	ACS_NamedExecuteWithResult("DnD On Attack", 0, -1);
}

// in here because dnd_mons.bcs can't access values of the variables used below
Script "DnD Warmaster Rage" (void) {
	while(!CheckInventory("WarmasterActive"))
		Delay(const:17);
	int i, tidlim, dist;
	while(CheckInventory("WarmasterActive")) {
		bool found = false;
		// try to see if there's at least one monster that is closest to this
		for(i = DND_MONSTERTID_BEGIN; i < DnD_TID_List[DND_TID_MONSTER] && !found; ++i) {
			if(IsActorAlive(i)) {
				dist = fdistance(0, i);
				// no self find
				if(dist >= 2.0 && dist <= WARMASTER_DIST)
					found = true;
			}
		}
		
		if(found)
			GiveInventory("WarmasterRage", 1);
		else
			TakeInventory("WarmasterRage", 1);
		Delay(const:TICRATE);
	}
}

Script "DnD Get Aspect For Inventory View" (void) CLIENTSIDE {
	SetResultValue(ScreenResOffsets[2]);
}

Script "DnD Elixir Use Message" (int eid) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	LocalAmbientSound("Items/ElixirPick", 127);
	Log(l:GetInventoryText(eid + ELIXIR_BEGIN));
}

Script "DnD Elixir Use" (int eid) {
	ACS_NamedExecuteAlways("DnD Elixir Use Message", 0, eid);
	ACS_NamedExecuteAlways("DnD Force Damage Cache Recalculation", 0, PlayerNumber());
	HandleElixirUse(eid);
}

Script "DnD DeathRay Marker TID" (void) {
	Thing_ChangeTID(0, GetActorProperty(0, APROP_TARGETTID) + DEATHRAY_MARKER_TID_ADD);
}

Script "DnD DeathRay Laser Aim" (int adj) {
	int target = GetActorProperty(0, APROP_TARGETTID) + DEATHRAY_MARKER_TID_ADD;
	if(!ThingCount(T_NONE, target))
		terminate;
	int xdiff = GetActorX(target) - GetActorX(0);
	int ydiff = GetActorY(target) - GetActorY(0);
	SetActorProperty(0, APROP_HEALTH, target);
	SetActorProperty(0, APROP_MASS, (360 * VectorAngle(xdiff, ydiff)) >> 16);
	SetActorPitch(0, VectorPitch(0, target, xdiff, ydiff, adj));
}

Script "DnD Deathray Laser Trail" (int density, int target) CLIENTSIDE {
	int oX = GetActorX(0);
	int oY = GetActorY(0);
	int oZ = GetActorZ(0);

    int grX; int grY;  int grZ;
    int vX;  int vY;   int vZ;
    int nX;  int nY;   int nZ;
    int bX;  int bY;   int bZ;
    int magnitude;
    int pointCount;
    int pointOffset;
	
    grX = GetActorX(target);
    grY = GetActorY(target);
    grZ = GetActorZ(target);
	
    vX   = grX - oX;
	vY   = grY - oY;
	vZ   = grZ - oZ;
	
    magnitude = magnitudeThree(vX >> 16, vY >> 16, vZ >> 16);
    pointCount  = magnitude / density;
    pointOffset = magnitude - (pointCount * density);

    if (magnitude != 0) {
        nX = vX / magnitude; nY = vY / magnitude; nZ = vZ / magnitude;

        int i; int j;
        for (i = 1; i < pointCount; i++) {
            j = (i * density) + pointOffset;
            bX = (nX * j) + oX;
            bY = (nY * j) + oY;
            bZ = (nZ * j) + oZ;

            Spawn("DeathRayLaserTrail", bX, bY, bZ);
        }
    }
}

Script "DnD Force Sync Player Bonuses" (void) {
	Delay(TICRATE * 5);
	if(CheckInventory("DnD_SyncMe"))
		SyncAllClientsideVariables(PlayerNumber());
}

Script "DnD Force Damage Cache Recalculation" (int pnum) {
	ForcePlayerDamageCaching(pnum);
}

Script "DnD Pet Monster Scale" (int petid, int trait1, int trait2) {
	int master = GetActorProperty(0, APROP_MASTERTID);

	GivePetTID(master);
	
	int base, add, level, temp, this = ActivatorTID();
	int m_id = this - DND_PETTID_BEGIN;
	base = GetActorProperty(0, APROP_HEALTH);
	
	add = 0, level = CheckActorInventory(master, "Level");
	if(level > 1) {
		add = (base * Clamp_Between(GetCVar("dnd_monster_hpscalepercent"), 1, 100)) / 100;
		if(level > 75)
			temp = DND_AFTER75_INCREMENT;
		else if(level > 50)
			temp = DND_AFTER50_INCREMENT;
		else
			temp = 1;
		// we are in boost range for hp
		if(temp != 1) {
			if(add > 100) {
				add /= 100;
				add *= 100 + temp;
			}
			else {
				add *= 100 + temp;
				add /= 100;
			}
		}
		add += SKILL_ZOMBIE_HP_PER_INT * GetActorIntellect(master);
			
		// first overflow check
		if(add < (INT_MAX - base) / (level - 1))
			add *= level - 1;
		else
			add = INT_MAX - base;
	}
	SetActorProperty(0, APROP_HEALTH, base + add);
	ScaleMonsterMass(level);
	PetMonsterProperties[m_id].id = petid;
	PetMonsterProperties[m_id].basehp = base;
	PetMonsterProperties[m_id].maxhp = base + add;
	PetMonsterProperties[m_id].level = level;
	PetMonsterProperties[m_id].trait_list[DND_PET] = true;
	
	// find a better way to transfer these
	if(trait1 != -1)
		PetMonsterProperties[m_id].trait_list[trait1] = true;
	if(trait2 != -1)
		PetMonsterProperties[m_id].trait_list[trait2] = true;
	
	ACS_NamedExecuteWithResult(
		"DnD Sync Pet Monster Trait CS", 
		this, 
		GetPetMonsterTraits(m_id, 0),
		GetPetMonsterTraits(m_id, 1),
		GetPetMonsterTraits(m_id, 2)
	);
}

Script "DnD Master Skill Info" (int skill_id) {
	int res = 0;
	int master = GetActorProperty(0, APROP_MASTERTID);
	switch(skill_id) {
		case SKILLINFO_ZOMBIEPETTIMER:
			res = SKILL_ZOMBIE_DURATION + GetActorIntellect(master) / ZOMBIE_INT_TIMER_FACTOR;
		break;
	}
	SetResultValue(res);
}

Script "DND Pet Monster Damage Scale" (int base, int rnd, int flags) {
	if(flags & 1) // target
		SetactivatorToTarget(0);
	int this = ActivatorTID();
	int master = GetActorProperty(0, APROP_MASTERTID);
	int res = 1.0 + Clamp_Between(PetMonsterProperties[this - DND_PETTID_BEGIN].level, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 1, 100);
	if(PetMonsterProperties[this - DND_PETTID_BEGIN].level > 50)
		res = FixedMul(res, 1.0 + DND_AFTER50_INCREMENT_DAMAGE);
	if(flags & DND_WDMG_ISRIPPER)
		res >>= 1;
	res += GetPetDamageFactor(base, master);
	// we don't need monster id from here onwards
	base &= 0xFFFF;
	// apply the monster's base damage first
	res *= base;
	res >>= 16;
	// now get player damage bonus stuff included
	SetActivator(master);
	int pnum = PlayerNumber();
	res += MapTalentToFlatBonus(pnum, TALENT_OCCULT, flags);
	res = res * (100 + DND_DEMONBANE_GAIN * IsAccessoryEquipped(ActivatorTID(), DND_ACCESSORY_DEMONBANE)) / 100;
	// talent bonus
	res = res * (100 + DND_INT_GAIN * GetIntellect()) / 100;
	int temp = GetPlayerAttributeValue(pnum, INV_EX_DAMAGEPER_FLATHEALTH);
	if(temp) {
		temp = GetFlatHealthDamageFactor(temp);
		res = res * (100 + temp) / 100;
	}
		
	temp =  GetDataFromOrbBonus(pnum, OBI_DAMAGETYPE, TALENT_OCCULT) + 
			GetPlayerAttributeValue(pnum, INV_DAMAGEPERCENT_INCREASE) +
			MapTalentToPercentBonus(pnum, TALENT_OCCULT) +
			Player_Elixir_Bonuses[pnum].damage_type_bonus[TALENT_OCCULT];
	if(temp)
		res = res * (100 + temp) / 100;
		
	// finally crit chance
	if(CheckCritChance(-1, false, -1)) {
		res = res * GetCritModifier() / 100;
		HandleHunterTalisman();
	}
	res *= random(rnd & 0xFFFF, rnd >> 16);
		
	//printbold(d:res);
	SetResultValue(res);
}

Script "DnD On Summon Death Check" (int monsterID) {
	switch(monsterID) {
		case MONSTER_PET_ZOMBIE:
			SetActivator(0, AAPTR_MASTER);
			TakeInventory("SummonedZombiePets", 1);
			TakeInventory("PetCounter", 1);
		break;
	}
}

Script "DnD On Pet Summon" (void) {
	// check for damage shared buff
	/*if(CheckInventory("StatbuffCounter_PainSharedWithPets")) {
		// a bit of delay to register the pet summoning
		Delay(const:10);
		if(CheckInventory("PetCounter"))
			GiveInventory(StrParam(s:"PetDamageReduction_", d:CheckInventory("PetCounter")), 1);
	}*/
}

Script "DnD Pet Distance Move" (void) {
	int master = GetActorProperty(0, APROP_MASTERTID), dx, dy, dz;
	while(IsAlive()) {
		if(!CheckInventory("MovePetCooldown")) {
			dx = GetActorX(0) - GetActorX(master);
			dy = GetActorY(0) - GetActorY(master);
			dz = GetActorZ(0) - GetActorZ(master);
			if(fdistance_delta(dx, dy, dz) > DND_PET_MOVEDIST) {
				GiveInventory("MovePetCooldown", 1);
				Thing_Move(0, master, 1);
				SetActorAngle(0, GetActorAngle(master));
				GiveInventory("PetTargetClear", 1);
			}
		}
		Delay(const:TICRATE);
	}
}

Script "DnD Give Soul Ammo" (int amt) {
	GiveAmmo(amt, DND_AMMOSLOT_SOULS, 0);
}

// called whenever player makes an attack, melee weapons or weapon attacks that use no ammo need to call this explicitly
// reason is this is embedded in ammo gain chance script for ease
Script "DnD On Attack" (int isSpecial, int extra) {
	// elemental bulwark check
	if(CheckInventory("IATTR_ChanceToCastElementalSpell") >= random(1, 100) && !CheckInventory("RandomElementalSpellCooldown")) {
		GiveInventory("RandomElementalSpellCooldown", 1);
		CastRandomElementalSpell();
	}
	
	// roll a crit for this attack, and every projectile etc. to come out of it will use this pre-calculated crit chance here
	int wepid = CheckInventory("DnD_WeaponID");
	CheckCritChance(wepid, isSpecial, extra);
	
	// do the quest checks for slot guns being used
	DoSlotWeaponQuestChecks(wepid);
	
	SetResultValue(0);
}

// This doesn't trigger when a monster is continuously attacking, their stuff is manually added unfortunately
Script "DnD On Monster Attack" (void) {
	int m_id = ActivatorTID() - DND_MONSTERTID_BEGIN;
	if(MonsterProperties[m_id].trait_list[DND_MARKOFCHAOS]) {
		// check monster size category -- small, medium or big
		int size = GetMonsterSizeType(MonsterProperties[m_id].id);
		switch(size) {
			case DND_MONSTERSIZE_SMALL:
				GiveInventory("Monster_Chaos_Check", 1);
			break;
			case DND_MONSTERSIZE_MEDIUM:
				GiveInventory("Monster_Chaos_Check_Medium", 1);
			break;
			case DND_MONSTERSIZE_BIG:
				GiveInventory("Monster_Chaos_Check_Big", 1);
			break;
		}
	}
}

Script "DnD Face Tracer" (void) {
	int target = GetActorProperty(0, APROP_TRACERTID);
	int xdiff = GetActorX(target) - GetActorX(0);
	int ydiff = GetActorY(target) - GetActorY(0);
	SetActorProperty(0, APROP_SCORE, (360 * VectorAngle(xdiff, ydiff)) >> 16);
	SetActorPitch(0, VectorPitch(0, target, xdiff, ydiff, 8.0));
}

Script "DnD Class Select" (void) NET CLIENTSIDE {
	// close the previous menu
	ConsoleCommand("closemenu");

	int cpnum = ConsolePlayerNumber();
	
	// don't allow duplicates to be run
	if(GetUserCVar(cpnum, "dnd_onclassmenu"))
		Terminate;
	
	int ctype = GetUserCVar(cpnum, "dnd_playerclass");
	
	SetUserCVar(cpnum, "dnd_classmenu_button", 0);
	SetUserCVar(cpnum, "dnd_onclassmenu", true);
	
	ACS_NamedExecuteAlways("DnD Class Select Screen", 0);
	ACS_NamedExecuteAlways("DnD Class Select Info", 0, ctype);
	ACS_NamedExecuteAlways("DnD Class Select Animated", 0);
	
	int bpress, obpress, dir = 0;
	while(PlayerIsSpectator(cpnum)) {
		bpress = GetPlayerInput(-1, INPUT_BUTTONS);
		obpress = GetPlayerInput(-1, INPUT_OLDBUTTONS);

		// left move
		if(isButtonPressed(bpress, obpress, settings[1][0])) {
			dir = -1;
			ACS_NamedExecuteAlways("DnD Class Select Arrow Press", 0, DND_CLASSMENU_LEFTBUTTON_BIT);
		}
		if(isButtonPressed(bpress, obpress, settings[3][0])) {
			dir = 1;
			ACS_NamedExecuteAlways("DnD Class Select Arrow Press", 0, DND_CLASSMENU_RIGHTBUTTON_BIT);
		}
		if(isButtonPressed(bpress, obpress, BT_USE | BT_ATTACK)) {
			// terminate this, we made our choice
			LocalAmbientSound("RPG/MenuChoose", 127);
			SetUserCVar(cpnum, "dnd_playerclass", ctype);
			ConsoleCommand(StrParam(s:"menu_joinclassidx ", d:ctype));
			ConsoleCommand("menu_joingamewithclass");
			break;
		}
		if(isButtonPressed(bpress, obpress, BT_ALTATTACK)) {
			// clean this, we can exit
			LocalAmbientSound("RPG/MenuClose", 127);
			break;
		}
		
		if(dir != 0) {
			LocalAmbientSound("RPG/MenuMove", 127);
			ctype += dir;
			
			if(ctype < 0)
				ctype = MAXPLAYERCLASSES - 1;
			else if(ctype > MAXPLAYERCLASSES - 1)
				ctype = 0;
			
			// update
			ACS_NamedExecuteAlways("DnD Class Select Info", 0, ctype);
		}
		
		// reset
		dir = 0;
		Delay(const:1);
	}
	SetUserCVar(cpnum, "dnd_onclassmenu", false);
	ACS_NamedExecuteAlways("DnD Class Select Cleanup", 0);
}

Script "DnD Class Select Arrow Press" (int mode) CLIENTSIDE {
	int cpnum = ConsolePlayerNumber();
	int bn = GetUserCVar(cpnum, "dnd_classmenu_button");
	if(bn & mode)
		Terminate;
	bn |= mode;
	SetUserCVar(cpnum, "dnd_classmenu_button", bn);
}

Script "DnD Class Select Screen" (void) CLIENTSIDE {
	int cpnum = ConsolePlayerNumber();
	
	SetHUDSize(600, 450, 1);
	SetFont("BIGFONT");
	HudMessage(s:"\cj", l:"CLASS_SELECT"; HUDMSG_PLAIN, DND_CLASSMENU_SELECTID, -1, 300.0, 80.0, 0.0);
	
	SetHUDSize(320, 240, 1);
	setFont("DNDCHRSL");
	HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_BACKGROUND, -1, 160.0, 120.0, 0.0);
}

Script "DnD Class Select Animated" (int doDelay) CLIENTSIDE {
	int cpnum = ConsolePlayerNumber();
	bool larr_inc = false, rarr_inc = false;
	int larr_timer = 0, rarr_timer = 0;
	int select_alpha = 0;
	
	while(GetUserCVar(cpnum, "dnd_onclassmenu")) {
		// handle button press detection
		if(GetUserCVar(cpnum, "dnd_classmenu_button") & DND_CLASSMENU_LEFTBUTTON_BIT) {
			larr_timer = 0;
			larr_inc = true;
			SetUserCVar(cpnum, "dnd_classmenu_button", GetUserCVar(cpnum, "dnd_classmenu_button") ^ DND_CLASSMENU_LEFTBUTTON_BIT);
		}
		if(GetUserCVar(cpnum, "dnd_classmenu_button") & DND_CLASSMENU_RIGHTBUTTON_BIT) {
			rarr_timer = 0;
			rarr_inc = true;
			SetUserCVar(cpnum, "dnd_classmenu_button", GetUserCVar(cpnum, "dnd_classmenu_button") ^ DND_CLASSMENU_RIGHTBUTTON_BIT);
		}
	
		SetHudSize(320, 240, 1);
		
		// display arrows
		if(larr_inc)
			SetFont("CHSLARR2");
		else
			SetFont("CHSLARR1");
		HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_CLASSCURSOR_LEFTID, -1, 34.0, 66.0, 0.0);
		
		if(rarr_inc)
			SetFont("CHSRARR2");
		else
			SetFont("CHSRARR1");
		HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_CLASSCURSOR_RIGHTID, -1, 284.0, 66.0, 0.0);
		
		SetHudSize(600, 450, 1);
		SetFont("SMALLFONT");
		
		// display press w.e keys text
		HudMessage(
			s:"\c[L7]", l:"CLASS_PRESS", s:" \ci", k:"+use", s:" \c[L7]", l:"DND_OR", s:" \ci", k:"+attack", s: " \c[L7]", l:"CLASS_TOSELECT", s:"!",
			s:"\n\c[L7]", l:"CLASS_PRESS", s:" \ci", k:"+altattack", s:" \c[L7]", l:"CLASS_TOCLOSE", s:"!";
			HUDMSG_PLAIN | HUDMSG_ALPHA, DND_CLASSMENU_BOTTOMTEXTID, -1, 300.4, 368.1, 0.0, abs(sin(select_alpha * 1.0 / 360))
		);
		
		Delay(const:1);
		
		// alpha increment
		select_alpha = (select_alpha + 4) % 360;

		// button timers
		if(larr_inc) {
			larr_timer++;
			if(larr_timer >= DND_CLASSMENU_BUTTON_DELAY) {
				larr_timer = 0;
				larr_inc = false;
			}
		}
		
		if(rarr_inc) {
			rarr_timer++;
			if(rarr_timer >= DND_CLASSMENU_BUTTON_DELAY) {
				rarr_timer = 0;
				rarr_inc = false;
			}
		}
	}
}

Script "DnD Class Select Info" (int ctype) CLIENTSIDE {
	str cprefix = StrParam(s:"CLASS", d:ctype);

	SetHUDSize(600, 450, 1);
	SetFont("SMALLFONT");
	SetHudClipRect(100, 84, 384, 384, 336);
	
	HudMessage(s:"\c[J7]", l:GetClassLabel(cprefix, DND_CLASS_LABEL_NAME); HUDMSG_PLAIN, DND_CLASSMENU_CLASSID, -1, 300.4, 96.1, 0.0);
	HudMessage(s:"\cj", l:GetClassLabel(cprefix, DND_CLASS_LABEL_TEXT); HUDMSG_PLAIN, DND_CLASSMENU_CLASSEXPID, -1, 128.1, 184.1, 0.0);
	
	// perks
	HudMessage(s:"+ L5: ",  l:GetClassLabel(cprefix, DND_CLASS_LABEL_PERK1); HUDMSG_PLAIN, DND_CLASSMENU_CLASSPERK5ID, CR_GREEN, 128.1, 248.1, 0.0);
	HudMessage(s:"+ L25: ", l:GetClassLabel(cprefix, DND_CLASS_LABEL_PERK2); HUDMSG_PLAIN, DND_CLASSMENU_CLASSPERK25ID, CR_ORANGE, 128.1, 288.1, 0.0);
	HudMessage(s:"+ L50: ", l:GetClassLabel(cprefix, DND_CLASS_LABEL_PERK3); HUDMSG_PLAIN, DND_CLASSMENU_CLASSPERK50ID, CR_RED, 128.1, 328.1, 0.0);
	
	SetHudClipRect(0, 0, 0, 0, 0);
	
	// show the class images -- offsets aligned
	SetFont(StrParam(l:GetClassLabel(cprefix, DND_CLASS_LABEL_MUGSHOT)));
	if(ctype == DND_PLAYER_BERSERKER)
		HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_MUGIMG, -1, 300.0, 112.1, 0.0);
	else if(ctype == DND_PLAYER_MARINE)
		HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_MUGIMG, -1, 296.0, 112.1, 0.0);
	else if(ctype == DND_PLAYER_WANDERER)
		HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_MUGIMG, -1, 292.0, 116.1, 0.0);
	else
		HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_MUGIMG, -1, 288.0, 112.1, 0.0);
	SetFont(StrParam(l:GetClassLabel(cprefix, DND_CLASS_LABEL_LEFTIMG)));
	HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_LEFTIMG, -1, 80.4, 208.1, 0.0);
	SetFont(StrParam(l:GetClassLabel(cprefix, DND_CLASS_LABEL_RIGHTIMG)));
	HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_RIGHTIMG, -1, 512.4, 208.1, 0.0);
	
	// prev and next class images
	cprefix = StrParam(s:"CLASS", d:(ctype - 1 < 0) ? MAXPLAYERCLASSES - 1 : ctype - 1);
	SetFont(StrParam(l:GetClassLabel(cprefix, DND_CLASS_LABEL_LEFTIMG)));
	HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_PREVCLASS_IMGID, -1, 112.4, 96.1, 0.0);
	
	cprefix = StrParam(s:"CLASS", d:(ctype + 1 > MAXPLAYERCLASSES - 1) ? 0 : ctype + 1);
	SetFont(StrParam(l:GetClassLabel(cprefix, DND_CLASS_LABEL_RIGHTIMG)));
	HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_NEXTCLASS_IMGID, -1, 480.4, 96.1, 0.0);
}

Script "DnD Class Select Cleanup" (void) CLIENTSIDE {
	HudMessage(s:""; HUDMSG_PLAIN, DND_CLASSMENU_BACKGROUND, -1, 0, 0, 1.0);
	for(int i = 0; i < DND_CLASSMENU_IDCOUNT; ++i)
		HudMessage(s:""; HUDMSG_PLAIN, DND_CLASSMENU_SELECTID + i, -1, 0, 0, 1.0);
}

Script "DnD Doomguy Soul Pickup" (int val) {
	val = Clamp_Between(val / DND_DOOMGUY_HEALDIV, 1, DND_DOOMGUY_MAXHEAL);
	// setactivatortotarget is SHIT
	SetActivator(0, AAPTR_TARGET);
	ACS_NamedExecuteAlways("DnD Health Pickup", 0, val, 0, 0);
}

Script "DnD Init Shared Translation" (void) {
	//TODO: Fix this
	//Thing_SetTranslation(0, TRANSLATION_ICE);
	Delay(const:17);
	Thing_SetTranslation(0, DND_NO_TRANSLATION);
}

Script "DnD Disable Pickup" (int tid) {
	Thing_SetSpecial(tid, 0, 0, 0, 0);
	//TODO: Fix this
	//Thing_SetTranslation(tid, TRANSLATION_ICE);
	Delay(const:SHARED_ITEM_ACTIVITY_DELAY);
	// these are hardcoded into the engine, won't ever change prob.
	Thing_SetSpecial(tid, 226, DND_SHARED_ITEM_SCRIPT, 0, tid);
	Thing_SetTranslation(tid, DND_NO_TRANSLATION);
}

Script "DnD Budget Giver" (int amt) {
	GiveBudget(amt);
}

Script "DnD Punisher Perk50 Display" (int reset) CLIENTSIDE {
	if(PlayerNumber() != ConsolePlayerNumber() || !isPlayerClass(DND_PLAYER_PUNISHER))
		Terminate;
	Delay(const:5);
	int tmp = 0;
	if(CheckInventory("Punisher_Perk50")) {
		SetFont("OBJFONT");
		SetHudSize(900, 600, 1);
		int x = (GetHudRight(900) << 16) - 5.8;
		if(CheckInventory("Punisher_Perk50_Counter") >= DND_PUNISHER_PERK3_KILLCOUNT) {
			if(!reset)
				HudMessage(s:"\c[I7]", f:ftrunc(100 * (DND_PUNISHER_DMGINCF * (CheckInventory("Punisher_Perk50_Counter") / DND_PUNISHER_PERK3_KILLCOUNT))), s:"%\c- more damage"; HUDMSG_PLAIN, PUNISHERPERKID1, -1, x, 450.0, 0.0);
			else // clear because we died
				HudMessage(s:""; HUDMSG_PLAIN, PUNISHERPERKID1, -1, x, 450.0, 0.0);
		}
		tmp = DND_PUNISHER_PERK3_KILLCOUNT - CheckInventory("Punisher_Perk50_Counter") % DND_PUNISHER_PERK3_KILLCOUNT;
		HudMessage(l:"DND_KILL", s:" \c[I7]", d:tmp, s:"\c- ", l:"DND_FORBUFF"; HUDMSG_PLAIN, PUNISHERPERKID2, -1, x, 480.0, 0.0);
	}
}

Script 1006 (int pnum) NET CLIENTSIDE {
	if(PlayerInGame(pnum)) {
		int tid = pnum + P_TIDSTART;
		int this = ActivatorTID();
		int i, j, temp, itype, cnt, val;
		
		Log(s:"\n================================\n====== ", l:"DND_PLAYERLOOKUP", s:" ======\n================================\n");
		SetActivator(tid);
		Log(s:"\cd", l:"DND_PLAYER", s:": \c-", n:pnum + 1, s:"\n\cd", l:"DND_STAT18", s:": \c-", d:CheckInventory("Level"));
		Log(s:"\cd", l:"DND_CLASS", s:": \c-", s:"\c[J7]", l:GetClassLabel(StrParam(s:"CLASS", d:CheckInventory("DnD_Character") - 1), DND_CLASS_LABEL_NAME));
		Log(s:"\cd", l:"IATTR_T0", s:": \c-", d:GetActorProperty(0, APROP_HEALTH), s: " / ", d:GetSpawnHealth());
		Log(s:"\cd", l:"IATTR_T1", s:": \c-", d:GetArmorAmount(), s: " / ", d:GetArmorCap(true));
		
		Log(s:"\n--------------------------------\n------- ", l:"DND_STATALLOCATION", s:" -------\n--------------------------------\n");
		Log(s:"\c[Y5]", l:"DND_STAT1", s:": \c-", d:GetStrength(), s:"\n\c[Y5]", l:"DND_STAT2", s:": \c-", d:GetDexterity(), s:"\n\c[Y5]", l:"DND_STAT3", s:": \c-", d:GetBulkiness());
		Log(s:"\c[Y5]", l:"DND_STAT4", s:": \c-", d:GetCharisma(), s:"\n\c[Y5]", l:"DND_STAT5", s:": \c-", d:GetVitality(), s:"\n\c[Y5]", l:"DND_STAT6", s:": \c-", d:GetIntellect());
		
		Log(s:"\n--------------------------------\n------- ", l:"DND_PERKALLOCATION", s:" -------\n--------------------------------\n");
		for(i = 0; i < DND_MAX_PERKS; ++i)
			Log(s:"\c[Y5]", l:GetStatLabel(DND_PERK_BEGIN + i), s:": \c-", d:GetStat(DND_PERK_BEGIN + i));
		
		Log(s:"\n--------------------------------\n------- ", l:"DND_MENU_ACCESSORIES", s:" -------\n--------------------------------\n");
		for(j = 0, i = 0; i < MAX_ACCESSORY && j < 2; ++i) {
			if(IsAccessoryEquipped(0, 1 << i)) {
				Log(s:"\c[Y5]", l:"DND_ACCESSORY", s:" ", d:(j + 1), s:": \c[C5]", s:AccessoryInfo[i][ACCESSORY_TAG]);
				++j;
			}
		}
		if(!j)
			Log(s:"\c[Y5]", l:"DND_ACCESSORY", s:" 1: \cuN/A\n\c[Y5]", l:"DND_ACCESSORY", s:" 2: \cuN/A");
		else if(j == 1)
			Log(s:"\c[Y5]", l:"DND_ACCESSORY", s:" 2: \cuN/A");
			
		Log(s:"\n--------------------------------\n------- ", l:"DND_WEPSOWNED", s:" -------\n--------------------------------\n");
		for(i = 0; i < MAXWEPS; ++i)
			if(CheckInventory(Weapons_Data[i][WEAPON_NAME]))
				Log(s:"\cd* \c[Y5]", l:GetWeaponTag(i), s:" - \cj", l:"DND_MENU_SLOT", s:" ", d:GetGameSlotOfWeapon(i));
				
		Log(s:"\n--------------------------------\n------- ", l:"DND_MENU_HEAD_CHARMS", s:" -------\n--------------------------------\n");
		for(i = 0; i < MAX_CHARMS_EQUIPPABLE; ++i) {
			itype = Charms_Used[pnum][i].item_type;
			if(itype != DND_ITEM_NULL) {
				if(itype == DND_ITEM_CHARM) {
					temp = GetItemSyncValue(pnum, DND_SYNC_ITEMLEVEL, i, -1, DND_SYNC_ITEMSOURCE_CHARMUSED) / CHARM_ATTRIBLEVEL_SEPERATOR;
					Log(s:Charm_Strings[temp][CHARMSTR_COLORCODE], l:Charm_Strings[temp][CHARMSTR_TIERTAG], s: " ", l:GetCharmTypeName(GetItemSyncValue(pnum, DND_SYNC_ITEMSUBTYPE, i, -1, DND_SYNC_ITEMSOURCE_CHARMUSED)), s:" ", l:"DND_ITEM_CHARM");
					temp = GetItemSyncValue(pnum, DND_SYNC_ITEMSATTRIBCOUNT, i, -1, DND_SYNC_ITEMSOURCE_CHARMUSED);
					for(j = 0; j < temp; ++j)
						Log(s:"    ", s:GetItemAttributeText(GetItemSyncValue(pnum, DND_SYNC_ITEMATTRIBUTES_ID, i, j, DND_SYNC_ITEMSOURCE_CHARMUSED), GetItemSyncValue(pnum, DND_SYNC_ITEMATTRIBUTES_VAL, i, j, DND_SYNC_ITEMSOURCE_CHARMUSED)));
				}
				else if(itype > UNIQUE_BEGIN) {
					temp = itype & 0xFFFF;
					itype >>= UNIQUE_BITS;
					--itype;
					// itype holds unique position, temp is the actual item type
					Log(s:"\c[A1]", l:GetUniqueItemName(itype), s:"\c- - \c[D1]", l:"DND_ITEM_UNIQUE", s:" ", l:GetCharmTypeName(GetItemSyncValue(pnum, DND_SYNC_ITEMSUBTYPE, i, -1, DND_SYNC_ITEMSOURCE_CHARMUSED)), s:" ", l:"DND_ITEM_CHARM");
					cnt = GetItemSyncValue(pnum, DND_SYNC_ITEMSATTRIBCOUNT, i, -1, DND_SYNC_ITEMSOURCE_CHARMUSED);
					// itype will count the skipped properties (the helper attributes)
					itype = 0;
					for(j = 0; j < cnt; ++j) {
						temp = GetItemSyncValue(pnum, DND_SYNC_ITEMATTRIBUTES_ID, i, j, DND_SYNC_ITEMSOURCE_CHARMUSED);
						val = GetItemSyncValue(pnum, DND_SYNC_ITEMATTRIBUTES_VAL, i, j, DND_SYNC_ITEMSOURCE_CHARMUSED);
						if(val > 0) {
							// dont show this, skip to next attribute's detail
							if(temp == INV_EX_CHANCE) {
								++j;
								++itype;
								Log(s:"    ", s:GetItemAttributeText(GetItemSyncValue(pnum, DND_SYNC_ITEMATTRIBUTES_ID, i, j, DND_SYNC_ITEMSOURCE_CHARMUSED), val, GetItemSyncValue(pnum, DND_SYNC_ITEMATTRIBUTES_VAL, i, j, DND_SYNC_ITEMSOURCE_CHARMUSED)));
							}
							else
								Log(s:"    ", s:GetItemAttributeText(temp, val, 0));
						}
						else if(!val) {
							// unique item doesn't have numeric attribute to show
							Log(s:"    ", s:GetItemAttributeText(temp, val, 0));
						}
						else
							Log(s:"    - ", s:GetItemAttributeText(temp, val, 0));
					}
				}
			}
			else
				Log(s:"\cuN/A");
		}
		
		SetActivator(this);
	}
	else
		Log(s:"\cg", l:"DND_MENU_ERROR", s:": \cj", l:"DND_PLAYERNOTPLAYING", s:"!");
}

Script "DnD Heal Monster Direct" (int amount, int isPercent) {
	int mid = ActivatorTID() - DND_MONSTERTID_BEGIN;
	if(!isPercent)
		HealMonster(mid, amount);
	else
		HealMonster(mid, MonsterProperties[mid].maxhp * isPercent / 100);
}

Script "DnD Monster Heal Potency" (int base) {
	int this = ActivatorTID() - DND_MONSTERTID_BEGIN;
	int factor = Clamp_Between(MonsterProperties[this].level, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 1, 100);
	
	if(MonsterProperties[this].trait_list[DND_VITAL])
		factor <<= 1;
	
	base = base * (100 + factor) / 100;
	
	SetResultValue(base);
}

Script "DnD Monster Health Regen Script" (int style, int amount, int period) {
	// how many periods will be waited for this to end?
	int duration = style >> 16;
	int mid = ActivatorTID() - DND_MONSTERTID_BEGIN;
	style &= 0xFFFF;
	if(style == DND_MHR_DURATION) {
		while(duration) {
			if(!CheckInventory("MonsterRegenPause")) {
				HealMonster(mid, amount);
				--duration;
			}
			Delay(period);
		}
	}
	else if(style == DND_MHR_PERIODIC) {
		while(isAlive()) {
			if(!CheckInventory("MonsterRegenPause"))
				HealMonster(mid, amount);
			Delay(period);
		}
	}
}

// Needs to be here as it loops through monster tid variable which is changed through this part
Script "DnD Tcherno Corpse Explode" (void) {
	for(int i = DND_MONSTERTID_BEGIN; i < DnD_TID_List[DND_TID_MONSTER]; ++i) {
		if(!isActorAlive(i) && fdistance(0, i) <= DREAMER_CORPSEEXPLOSION_DIST) {
			GiveActorInventory(i, "TchernoCorpseExploder", 1);
			ACS_NamedExecuteAlways("DnD Tcherno Corpse Explode Gib Giver", 0, i);
		}
	}
}

Script "DnD Tcherno Corpse Explode Gib Giver" (int i) CLIENTSIDE {
	Delay(const:TICRATE);
	GiveActorInventory(i, "TchernoCorpseExploder_Gibber", 1);
}

Script "DnD Item Linger Check" (int sp) {
	int counter = 0;
	sp >>= 16;
	while(counter < DND_ITEM_LINGER_TIME) {
		++counter;
		Delay(const:TICRATE);
		// if this is picked up, terminate early
		if(Inventories_On_Field[sp].item_type == DND_ITEM_NULL)
			Terminate;
	}
	// not picked until now, remove it
	RemoveItemFromWorld(sp);
	Thing_Remove(0);
}

// this is also no longer in use
/*Script "DnD Store Projectile Owner" (int isPet) {
	int target = !isPet ? GetActorProperty(0, APROP_TARGETTID) : ACS_NamedExecuteWithResult("DnD Get Master of Target");
	SetActorProperty(0, APROP_SCORE, target);
	
	// hack for crit store on burst fire projectiles
	if(CheckActorInventory(target, "DnD_CritToken"))
		SetActorProperty(0, APROP_ACCURACY, DND_CRIT_TOKEN);

	SetResultValue(0);
*/

Script "DnD Projectile Checks" (int isPet) {
	int owner = !isPet ? GetActorProperty(0, APROP_TARGETTID) : ACS_NamedExecuteWithResult("DnD Get Master of Target");
	// store owner
	SetActorProperty(0, APROP_SCORE, owner);
	
	// hack for crit store on burst fire projectiles
	if(CheckActorInventory(owner, "DnD_CritToken"))
		SetActorProperty(0, APROP_ACCURACY, DND_CRIT_TOKEN);
	
	if(CheckActorInventory(owner, "NetherCheck"))
		GiveInventory("ApplyNetherMaskBuff", 1);

	if
	(
		CheckActorInventory(owner, "Marine_Perk50") || 
		CheckActorInventory(owner, "StatbuffCounter_HomingDontReflect") && (CheckFlag(0, "SEEKERMISSILE") || CheckFlag(0, "SCREENSEEKER"))
	)
	{
		GiveInventory("ApplyNoReflect", 1);
	}
	
	if(CheckActorInventory(owner, "StatbuffCounter_ExplosiveResistIgnore"))
		GiveInventory("ApplyForceRadiusDMG", 1);
		
	SetResultValue(0);
}

Script "DnD Rejuvenation" (void) {
	int id = ActivatorTID() - DND_MONSTERTID_BEGIN;
	
	// 5% every second
	int hp_per = MonsterProperties[id].maxhp / 20;
	if(!hp_per)
		hp_per = 1;
	
	while(isAlive()) {
		Delay(const:TICRATE);
		
		// ignite effects prevent rejuvenation
		if(!CheckInventory("DnD_IgniteTimer") && GetActorProperty(0, APROP_HEALTH) != MonsterProperties[id].maxhp) {
			if(GetActorProperty(0, APROP_HEALTH) < MonsterProperties[id].maxhp - hp_per)
				SetActorProperty(0, APROP_HEALTH, GetActorProperty(0, APROP_HEALTH) + hp_per);
			else
				SetActorProperty(0, APROP_HEALTH, MonsterProperties[id].maxhp);
				
			ACS_NamedExecuteAlways("DnD Rejuvenation FX CS", 0);
		}
	}
}

Script "DnD Repel" (void) {
	// player R = 16.0
	int r = GetActorProperty(0, APROP_RADIUS) + 16.0;
	int p_tid;
	
	while(true) {
		Delay(const:REPEL_REFRESH_RATE);
		
		if(!isAlive())
			break;

		// check all players to see if they are close to us
		for(int i = 0; i < MAXPLAYERS; ++i) {
			p_tid = i + P_TIDSTART;
			if(PlayerInGame(i) && isActorAlive(p_tid)) {
				// 16.0 is player radius
				if(AproxDistance(GetActorX(p_tid) - GetActorX(0), GetActorY(p_tid) - GetActorY(0)) <= REPEL_DISTANCE + r && CheckSight(p_tid, 0, CSF_NOBLOCKALL)) {
					GiveInventory("RepelPulse", 1);
					ACS_NamedExecuteAlways("DnD Repel FX", 0);
					// repel will make it wait twice its duration for a total of 6 seconds
					Delay(const:REPEL_COOLDOWN);
					break;
				}
			}
		}
	}
}

Script "DnD Cripple" (void) {
	int r = GetActorProperty(0, APROP_RADIUS) + 16.0;
	int p_tid;
	
	while(isAlive()) {
		Delay(const:CRIPPLE_REFRESH_RATE);

		// check all players to see if they are close to us
		for(int i = 0; i < MAXPLAYERS; ++i) {
			p_tid = i + P_TIDSTART;
			if(PlayerInGame(i) && isActorAlive(p_tid)) {
				// 16.0 is player radius
				if(AproxDistance(GetActorX(p_tid) - GetActorX(0), GetActorY(p_tid) - GetActorY(0)) <= CRIPPLE_DISTANCE + r && CheckSight(p_tid, 0, CSF_NOBLOCKALL))
					GiveActorInventory(p_tid, "CrippleSlower", 1);
			}
		}
	}
}

Script "DnD Repel FX" (void) CLIENTSIDE {
	GiveInventory("RepelPulseFXSpawner", 1);
}

Script "DnD Rejuvenation FX CS" (void) CLIENTSIDE {
	GiveInventory("RejuvenationFX_Spawner", 1);
}

Script "DnD Berserker Perk5 Check" (void) {
	// berserker perk5 fail-safe checks for super weapons
	if(CheckInventory("Berserker_Perk5")) {
		for(int i = DND_WEAPON_BFG32768; i <= DND_WEAPON_SOULREAVER; ++i) {
			if(CheckInventory(Weapons_Data[i][WEAPON_NAME])) {
				TakeInventory(Weapons_Data[i][WEAPON_NAME], 1);
				TakeInventory("H_WeaponSlot7", 1);
				break;
			}
		}
	}
}

Script "DnD Berserker Perk5 Check (Melee)" (void) {
	// berserker perk5 fail-safe checks for class change from berserker to any other
	// do not include luxury weapons as part of this
	bool has_melee = false;
	if(!CheckInventory("Berserker_Perk5")) {
		for(int i = DND_WEAPON_DOUBLECHAINSAW; i <= LAST_SLOT0_NONLUXURYWEAPON; ++i) {
			if(CheckInventory(Weapons_Data[i][WEAPON_NAME])) {
				// basically, if we had a melee weapon found, and we find more afterwards, we will take all subsequent ones away
				if(has_melee) {
					TakeInventory(Weapons_Data[i][WEAPON_NAME], 1);
					TakeInventory("H_WeaponSlot1", 1);
					GiveInventory(Weapons_Data[DND_WEAPON_CHAINSAW][WEAPON_NAME], 1);
				}
				
				has_melee = true;
			}
		}
	}
}

Script "DnD Hurt Actor" (int hurter, int victim, int dmg) {
	SetActivator(hurter);
	Thing_Damage2(victim, dmg, "Normal");
}

Script "Dnd Pickup Setup" (void) {
	GivePickupTID();
}

Script "DnD Player WeaponPower Check" (int wepid, int power) {
	SetResultValue(HasWeaponPower(PlayerNumber(), wepid, power));
}

Script "DnD Get Player WeaponID" (void) {
	SetResultValue(GetWeaponPosFromTable());
}

Script "DnD Bloodfiend Heal" (void) {
	SetActivatorToTarget(0);
	
	// 1% heal per pellet hitting
	ACS_NamedExecuteAlways("DnD Health Pickup", 0, GetSpawnHealth() / 100);
}

Script "DnD Kanji Detect" (void) {
	SetActivator(0, AAPTR_TARGET);
	GiveInventory("DnD_Boolean", 1);
	SetResultValue(0);
}

Script "DnD Kanji Explosion" (int x, int y, int z) {
	x <<= 16;
	y <<= 16;
	z <<= 16;
	SetActivator(0, AAPTR_TARGET);
	
	int owner = ActivatorTID();
	int tid = KANJI_TRAPEXP_TID + PlayerNumber();
	
	SpawnForced("DemonSealExplosion", x, y, z, tid);
	SetActivator(tid);
	Thing_ChangeTID(0, 0);
	SetActorProperty(0, APROP_TARGETTID, owner);
	SetPointer(AAPTR_TARGET, owner);
	
	SetResultValue(0);
}

Script "DnD Create Kanji Trap" (void) {
	int a = GetActorAngle(0);
	int p = GetActorPitch(0);
	int tid = KANJI_TRAP_TID + PlayerNumber();
	int owner = ActivatorTID();
	
	SpawnForced("DemonSealTrap", GetActorX(0), GetActorY(0), GetActorZ(0), tid);
	SetActivator(tid);
	Thing_ChangeTID(0, 0);
	SetActorProperty(0, APROP_TARGETTID, owner);
	SetPointer(AAPTR_TARGET, owner);
	SetActorVelocity(0, FixedMul(64 * cos(a), cos(p)), FixedMul(64 * sin(a), cos(p)), -64 * sin(p), 0, 0);
	
	SetResultValue(0);
}

Script "DnD Remove Actor - CS" (void) CLIENTSIDE {
	SetActorState(0, "Remove", 0);
	SetResultValue(0);
}

// this is called by projectiles only
Script "DnD Update Melee ReactionTime" (int base) {
	int owner = GetActorProperty(0, APROP_TARGETTID);
	if(IsPlayer(owner))
		SetActorProperty(0, APROP_REACTIONTIME, base * (100 + CheckActorInventory(owner, "IATTR_MeleeRange") + GetActorStat(owner, STAT_BRUT) * DND_PERK_BRUTALITY_RANGEINC) / 100);
	SetResultValue(0);
}

Script "DnD Ammo Token Pickup" (void) {
	// get random owned weapon of player and give ammo to it
	int id = 0;
	do {
		id = PickRandomOwnedWeaponID();
	} while(!StrCmp(Weapons_Data[id][WEAPON_AMMO1], " "));
	
	// give 10% ammo on this weapon -- soulrender has weapon condition as ammo1 so dont give if it is 
	str ammo;
	int cap;
	
	if(id != DND_WEAPON_SOULRENDER) {
		ammo = Weapons_Data[id][WEAPON_AMMO1];
		cap = GetAmmoCapacity(ammo);
		GiveInventory(ammo, cap / 10);
	}

	ammo = Weapons_Data[id][WEAPON_AMMO2];
	if(ammo != " ") {
		cap = GetAmmoCapacity(ammo);
		GiveInventory(ammo, cap / 10);
	}
	
	ACS_NamedExecuteAlways("DnD Ammo Token Message", 0, id);
}

Script "DnD Ammo Token Message" (int wepid) CLIENTSIDE {
	Log(s:"\ccAmmo pickup   : \c[Y5]+10% to ", l:GetWeaponTag(wepid));
}

Script 1007 (void) NET CLIENTSIDE {
	SetCVar("dnd_detailedmods", !GetCVar("dnd_detailedmods"));
	
	// so the toggle is changed on the menu if you press it while in help page for some reason... you are weird if you do this!
	GiveInventory("DnD_RefreshPane", 1);
}

Script 69 (void) NET {
	SetInventory("Level", 98);
	SetInventory("Exp", GetExpLimit() / 2);
	SetInventory("LevelExpCap", GetExpLimit());
	CalculateExpRatio();
}

Script 70 (void) NET {
	GiveInventory("Exp", 200000);
	GiveInventory("LevelUpChecker", 1);
	CalculateExpRatio();
}

Script "Print Loc" (void) {
	printbold(f:GetActorX(0), s: " ", f:GetActorY(0), s: " ", f:GetActorZ(0));
	SetResultValue(0);
}

Script 68 (int x) NET {
	if(x < MAX_RESEARCHES)
		GiveResearch(x, true);
	else if(x == 32768) {
		SpawnSpecificOrbForAll(DND_ORB_ASSIMILATION, 1);
		SpawnSpecificOrbForAll(DND_ORB_PHANTASMAL, 1);
		SpawnSpecificOrbForAll(DND_ORB_SCULPTING, 4);
	}
	else if(x == 420) {
		SpawnCharm(0, true);
		SpawnOrb(0, true);
		//SpawnSpecificOrbForAll(DND_ORB_FORTITUDE, 50);
	}
	else {
		int c = CreateItemSpot();
		int i;
		i = random(UITEM_ELEMENTALBULWARK, UITEM_PAINMASTER);
		ConstructUniqueOnField(c, i, DND_ITEM_CHARM, 0);
		SpawnDrop("UniqueCharmDrop", 16.0, 16, 1, c);
	}
}

// experiment to check how evenly distributed the random attributes are
/*Script "Experiment" ENTER {
	int i;
	static int attr_bins[NORMAL_ATTRIBUTE_COUNT];
	for(i = 0; i < NORMAL_ATTRIBUTE_COUNT; ++i)
		attr_bins[i] = 0;
	
	for(i = 0; i < 10000; ++i)
		++attr_bins[random(FIRST_INV_ATTRIBUTE, LAST_INV_ATTRIBUTE * 100 + 99) / 100];
		
	for(i = 0; i < NORMAL_ATTRIBUTE_COUNT; ++i)
		Log(s:"attr ", d:i, s:": ", d:attr_bins[i]);
}*/