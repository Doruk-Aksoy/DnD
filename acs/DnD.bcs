#library "DND"
#include "zcommon.h"
#nocompact

#include "DnD_MonsterData.h"
#include "DnD_Shared.h"
#include "DnD_Orbs.h"
#include "DnD.h"
#include "DnD_Prompts.h"

#define DND_LOOTBOX_ORBDROPCHANCE 0.25
#define DND_LOOTBOX_TOKENDROPCHANCE 0.15
#define DND_LOOTBOX_CHESTKEYDROPCHANCE 0.1
#define DND_LOOTBOX_ARMORDROPCHANCE 0.5

// this is here for convenience, tracks if a legendary monster was spawned
bool MadeLegendary = 0;

Script "DnD SBAR" (void) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;

	int item, itemcomp;
	str ammo, ammoalt;
	int wepid;

	// wait till character is setup properly
	while(!CheckInventory("DnD_Character"))
		Delay(const:1);
	
	while(IsAlive()) {
		if(!CheckInventory("ShowingMenu")) {
			if(GetCVar("dnd_killspree"))
				GiveInventory("KillSpreeOn", 1);
			itemcomp = GetSpawnHealth();
			item = GetActorProperty(0, APROP_HEALTH);
			SetInventory("P_HealthCap", itemcomp);
			if(item > itemcomp) {
				SetInventory("HPOverAmount", item - itemcomp);
				GiveInventory("HPOver100", 1);
				TakeInventory("HPNormal", 1);
				TakeInventory("HPBelow50", 1);
				TakeInventory("HPBelow25", 1);
			}
			else if(item > (itemcomp >> 1) - 1) {
				SetInventory("HPOverAmount", 0);
				TakeInventory("HPOver100", 1);
				GiveInventory("HPNormal", 1);
				TakeInventory("HPBelow50", 1);
				TakeInventory("HPBelow25", 1);
			}
			else if(item > (itemcomp >> 2) - 1) {
				SetInventory("HPOverAmount", 0);
				TakeInventory("HPOver100", 1);
				TakeInventory("HPNormal", 1);
				GiveInventory("HPBelow50", 1);
				TakeInventory("HPBelow25", 1);
			}
			else {
				SetInventory("HPOverAmount", 0);
				TakeInventory("HPOver100", 1);
				TakeInventory("HPNormal", 1);
				TakeInventory("HPBelow50", 1);
				GiveInventory("HPBelow25", 1);
			}
			
			item = CheckInventory("EShieldAmount");
			itemcomp = GetAmmoCapacity("EShieldAmountVisual");
			if(item > itemcomp) {
				// can happen with armor bonuses -- up to maximum of x2 of cap (only fully reached with ubersphere)
				SetAmmoCapacity("ARMOverAmount", itemcomp * 2);
				SetInventory("ARMOverAmount", item - itemcomp);
				GiveInventory("ARMOver100", 1);
				TakeInventory("ARMNormal", 1);
				TakeInventory("ARMBelow50", 1);
				TakeInventory("ARMBelow25", 1);
			}
			else if(item >= itemcomp >> 1) {
				SetInventory("ARMOverAmount", 0);
				SetAmmoCapacity("ARMOverAmount", itemcomp);
				TakeInventory("ARMOver100", 1);
				GiveInventory("ARMNormal", 1);
				TakeInventory("ARMBelow50", 1);
				TakeInventory("ARMBelow25", 1);
			}
			else if(item >= itemcomp >> 2) {
				SetInventory("ARMOverAmount", 0);
				SetAmmoCapacity("ARMOverAmount", itemcomp);
				TakeInventory("ARMOver100", 1);
				TakeInventory("ARMNormal", 1);
				GiveInventory("ARMBelow50", 1);
				TakeInventory("ARMBelow25", 1);
			}
			else {
				SetInventory("ARMOverAmount", 0);
				SetAmmoCapacity("ARMOverAmount", itemcomp);
				TakeInventory("ARMOver100", 1);
				TakeInventory("ARMNormal", 1);
				TakeInventory("ARMBelow50", 1);
				GiveInventory("ARMBelow25", 1);
			}
				
			if(((Timer() * 98) / (100 * TICRATE)) < GetLevelInfo(LEVELINFO_PAR_TIME))
				GiveInventory("H_UnderPar", 1);
			else
				TakeInventory("H_UnderPar", 1);

			if(GetLevelInfo(LEVELINFO_KILLED_MONSTERS) == GetLevelInfo(LEVELINFO_TOTAL_MONSTERS))
				GiveInventory("H_KillsAchieved", 1);
			else
				TakeInventory("H_KillsAchieved", 1);

			if(GetLevelInfo(LEVELINFO_FOUND_ITEMS) == GetLevelInfo(LEVELINFO_TOTAL_ITEMS))
				GiveInventory("H_ItemsAchieved", 1);
			else
				TakeInventory("H_ItemsAchieved", 1);

			if(GetLevelInfo(LEVELINFO_FOUND_SECRETS) == GetLevelInfo(LEVELINFO_TOTAL_SECRETS))
				GiveInventory("H_SecretsAchieved", 1);
			else
				TakeInventory("H_SecretsAchieved", 1);
				
			if(GetCVar("sv_infiniteammo"))
				GiveInventory("H_InfiniteAmmo", 1);
			else
				TakeInventory("H_InfiniteAmmo", 1);
			
			// primary ammo
			wepid = CheckInventory("DnD_WeaponID");
			ammo = GetWeaponAmmoType(wepid, 0);
			if(ammo != "") { // if uses ammo
				itemcomp = GetAmmoCapacity(ammo);
				item = CheckInventory(ammo);
				if(item > (itemcomp + 1) / 2 || itemcomp == 1) {
					GiveInventory("H_PrimaryGreen", 1);
					TakeInventory("H_PrimaryYellow", 1);
					TakeInventory("H_PrimaryRed", 1);
				}
				else if(item > Max(itemcomp / 4, 1)) {
					TakeInventory("H_PrimaryGreen", 1);
					GiveInventory("H_PrimaryYellow", 1);
					TakeInventory("H_PrimaryRed", 1);	
				}
				else {
					TakeInventory("H_PrimaryGreen", 1);
					TakeInventory("H_PrimaryYellow", 1);
					GiveInventory("H_PrimaryRed", 1);		
				}
			}
			
			// secondary ammo
			ammoalt = GetWeaponAmmoType(wepid, 1);
			if(ammoalt != "" && ammo != ammoalt) { // if uses altammo and is not same as normal ammo
				itemcomp = GetAmmoCapacity(ammoalt);
				item = CheckInventory(ammoalt);
				if(item > (itemcomp + 1) / 2 || itemcomp == 1) {
					GiveInventory("H_SecondaryGreen", 1);
					TakeInventory("H_SecondaryYellow", 1);
					TakeInventory("H_SecondaryRed", 1);
				}
				else if(item > Max(itemcomp / 4, 1)) {
					TakeInventory("H_SecondaryGreen", 1);
					GiveInventory("H_SecondaryYellow", 1);
					TakeInventory("H_SecondaryRed", 1);	
				}
				else {
					TakeInventory("H_SecondaryGreen", 1);
					TakeInventory("H_SecondaryYellow", 1);
					GiveInventory("H_SecondaryRed", 1);		
				}
			}
		}
		Delay(const:5);
	}
	
	// if we are dead update these to fix the "dead but still green numbers" bug
	SetInventory("HPOverAmount", 0);
	TakeInventory("HPOver100", 1);
	TakeInventory("HPNormal", 1);
	TakeInventory("HPBelow50", 1);
	GiveInventory("HPBelow25", 1);
}

Script "DnD Clientside Open" OPEN CLIENTSIDE {
	bool buttons = false;
	bool wepdrop = false;
	
	SetUserCVar(ConsolePlayerNumber(), "dnd_onclassmenu", false);
	
	while(true) {
		if(GameType() != GAME_SINGLE_PLAYER) {
			if(!GetCVar("compat_clientssendfullbuttoninfo"))
				Log(l:"DND_WARN_COMPATBUTTONS");
			else
				buttons = true;
			if(GetCVar("sv_weapondrop"))
				Log(l:"DND_WARN_WEAPONDROP");
			else
				wepdrop = true;
				
			if(wepdrop && buttons)
				break;
		}
		else
			break;
		Delay(const:TICRATE);
	}
}

Script "DnD On Map Load" OPEN {
	// when it increments in createitem func, it'll be forced to be 0
	PointerIndexTable[PTR_FREEITEMWORLD] = MAX_INVENTORIES_ON_FIELD;

	//Log(d:DND_TEMP_PROJTID);
	//Log(d:DRAUGR_TEMP_FX);
	
	// empty translation
	CreateTranslation(DND_NO_TRANSLATION);
	CreateTranslation(DND_CRIT_TRANSLATION, 160:160=175:175);
	CreateTranslation(DND_RESIST_TRANSLATION, 160:160=82:82);
	CreateTranslation(DND_EXECUTE_TRANSLATION, 0:255=%[0.00,0.00,0.00]:[1.62,1.12,0.43]);
	
	// init vars
	ResetSharedVariables();
	ResetPlayerInformationLevel();
	
	// check for players that are spectating, reset their playerloaded variable (fixes bug where people can leave during intermission and cant load character until they spec again)
	int i;
	for(i = 0; i < MAXPLAYERS; ++i) {
		if(PlayerIsSpectator(i) == INTER_PSTATE_SPECTATING)
			PlayerLoaded[i] = false;
	}
	
	// wait just in case for the level to really begin
	while(GetGameModeState() != GAMESTATE_INPROGRESS)
		Delay(const:TICRATE);

	// reset used TIDs
	i = 0;
	Delay(const:7);
	//Log(s:"check start cond ", d:UsedMonsterTIDs[i], s: " ", d:DND_MONSTERTID_BEGIN);
	while(UsedMonsterTIDs[i] >= DND_MONSTERTID_BEGIN) {
		//Log(s:"clear id ", d:i);
		UsedMonsterTIDs[i] = 0;
		++i;
	}

	CreateMonsterTranslationTables();

	SetupEliteModWeights();

	SetupComplete(SETUP_STATE1, SETUP_CLEANINGMONSTERTIDS);

	if(!IsSetupComplete(SETUP_STATE1, SETUP_GLOBALCONSTANTSETUPS)) {
		Build_Constants();
		//Alloc_BuffTable();
		SetupComplete(SETUP_STATE1, SETUP_GLOBALCONSTANTSETUPS);
	}

	CalculateMapDifficulty();
	UpdateLevelChestLimit();

	// wait while total level is not initialized
	while(!PlayerInformationInLevel[PLAYERLEVELINFO_LEVEL])
		Delay(const:TICRATE);

	Delay(const:TICRATE);
	if (GetLevelInfo(LEVELINFO_LEVELNUM) != 99) //Prevents quests from firing on VR map (Lexicon) - compendium hubmap can't be detected this way unfortunately.
		PickQuest();

	SetupCVarTracking();

	// commented out for now!
#ifdef ISDEBUGBUILD
	while(!IsSetupComplete(SETUP_STATE1, SETUP_PLAYERINFO_MINMAXLEVELS))
		Delay(const:TICRATE);

	NPC_Setup();
#endif
}

Script "DnD Map Beaten Reward Text" (int budget) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;

	//Log(s:"cs budget: ", d:budget);
	
	Log(s:"\cfMAP CLEARED! Gained \cd", d:budget, s:"k\cf budget!");
	SetResultValue(0);
}

Script "DND Check Hardcore Softcore" OPEN {
	int cv;
	while(true) {
		cv = GetCVar("dnd_mode");
		if((cv >= DND_MODE_SOFTCORE) && (GameType() != GAME_SINGLE_PLAYER) && CheckHardcoreSettings()) {
			if(cv == DND_MODE_HARDCORE)
				SetupComplete(SETUP_STATE1, SETUP_HARDCORE);
			else
				SetupComplete(SETUP_STATE1, SETUP_SOFTCORE);
		}
		else {
			SetupUndo(SETUP_STATE1, SETUP_HARDCORE);
			SetupUndo(SETUP_STATE1, SETUP_SOFTCORE);
		}
		Delay(const:105);
	}
}

// Basically shut the menu down
Script "DnD On Death" DEATH {
	int i, pnum = PlayerNumber();
	int temp;
	PlayerDied[pnum] += 1;
	
	// put this at the beginning to prevent the rare last second lvl 1 char auto-load bug.
	if(GetCVar("Survival")) {
		if(CheckInventory("CurrentLives"))
			TakeInventory("CurrentLives", 1);
		else {
			// if player was in middle of saving, don't accidently interfere if player leaves early
			// save accumulated stats when player leaves
			// things saved are in DnD_Activity.h
			i = GetCVar("dnd_mode");
			if(i == DND_MODE_HARDCORE) {
				if(PlayerIsLoggedIn(pnum) && GetGameModeState() >= GAMESTATE_INPROGRESS) {
					temp = CheckInventory("DnD_CharacterID");
					--PlayerActivities[pnum].vote_skips;

					BeginDBTransaction();

					// reduce to not increment from joining
					SetDBEntry(GetCharField(DND_DB_VOTESKIPS, temp), GetPlayerAccountName(pnum), PlayerActivities[pnum].vote_skips);
					WipeoutPlayerData(pnum, temp);
					PlayerLoaded[pnum] = 0;

					EndDBTransaction();

					ResetPlayerActivities(pnum, false);
				}
				// reset on death
				ResetHardcoreStuff(pnum);
			}
			else if(i == DND_MODE_SOFTCORE) {
				// decrease player gained exp
				int exp = GetPlayerExp(pnum);
				int lvl = GetLevel();
				UpdateActivity(pnum, DND_ACTIVITY_EXP, Clamp_Between(exp - LevelCurve[lvl - 1] / 5, 0, INT_MAX), 0);

				// reduce to not increment from joining
				--PlayerActivities[pnum].vote_skips;

				HandlePlayerDataSave(pnum, false, i);
			}
			else
				ResetHardcoreStuff(pnum);
				
			PlayerDatabaseState[pnum][PLAYER_SAVESTATE] = false;
			PlayerDatabaseState[pnum][PLAYER_TRANSFERSTATE] = false;
			PlayerCanLoad[pnum] = 0;
			
			// no more lives left reset this array completely
			ResetPlayerModList(pnum);
				
			// no lives left, make sure the boss bar script keeps running for them (if there's a boss)
			ACS_NamedExecuteWithResult("DnD Unique Boss Bar Draw SpecOnly", DungeonBossData[BOSSDATA_TID], 1);
		}
		
		CheckEOL(false, i);
	}
	
	UnmarkPlayerAsExited(pnum);
	GiveInventory("DnD_PDead", 1);
	SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
	TakeInventory("P_Frozen", 1);
	StatListOpened[pnum] = 0;
	SetInventory("ShowingMenu", 0);
	SetInventory("MenuOption", 5);
	SetInventory("MenuPosX", 0);
	SetInventory("MadeChoice", 0);
	SetInventory("DnD_PopupId", 0);
	TakeInventory("EShieldCharging", 1);
	TakeInventory("EShieldChargeNow", 1);
	SetInventory("Punisher_Perk50_Counter", 0); // reset earned bonuses on death
	SetInventory("Hobo_ShotgunFrenzyTimer", 0);
	SetInventory("Marine_DamageReduction_Timer", 0);
	SetInventory("Marine_Perk50_Cooldown", 0);
	SetInventory("Berserker_Perk60_HitCounter", 0);
	
	TakeInventory("DnD_ShowPopup", 1);
	TakeInventory("DnD_ShowSellPopup", 1);
	TakeInventory("DnD_SellConfirm", 1);
	//SetInventory("MenuPosY", 5);
	ACS_NamedExecuteAlways("DND Menu Cleanup", 0, pnum);
	BreakTradesBetween(pnum);
	
	// Precious Life check
	if(active_quest_id == QUEST_NODYING) {
		// fail for all players in the game
		for(i = 0; i < MAXPLAYERS; ++i)
			if(PlayerInGame(i) && isActorAlive(i + P_TIDSTART))
				FailQuest(i + P_TIDSTART);
		active_quest_id = -1; // completely remove this quest from everyone now
	}
	
	Thing_ChangeTID(0, 0);
	
	// we moved this to HandlePlayerDataSave and above
	//if(PlayerLoaded[pnum] && !GetPlayerLivesLeft(pnum))
	//	PlayerLoaded[pnum] = 0;

	Delay(const:5);
}

Script "DnD Portable Kit Script" (void) {
	int healthcap = GetSpawnHealth();
	int bonus = GetHealingBonuses(PlayerNumber());
	int amt = healthcap / 100;
	amt = amt * (100 + bonus) / 100;
	while(GetActorProperty(0, APROP_HEALTH) < healthcap && CheckInventory("StoredMedkit")) {
		TakeInventory("StoredMedkit", 1);
		GiveInventory("HealthBonusX", amt);
		GiveInventory("DnD_MasterHealerQuest_HealAmount", amt);
	}
}

// Health Kits Script (Used by Portable Medikits as well, ported here)
Script "DnD Health Pickup" (int amt, int isSpecial, int useTarget) {
	HandleHealthPickup(amt, isSpecial, useTarget);
}

Script "DnD Can Pick Health Item" (int type) {
	if (CheckInventory("CanLoad"))
		SetResultValue(-1);
	else
		SetResultValue(CanPickHealthItem(type));
}
// Health kits end here

Script "DnD Critical Input Handler" ENTER {
	int pnum = PlayerNumber();
    while(PlayerInGame(pnum)) {
		if(GetPlayerInput(-1, INPUT_BUTTONS) & BT_USE)
			GiveInventory("DnD_PressedUse", 1);
		
        SetInventory("MedkitItem", CheckInventory("StoredMedKit"));
        TakeInventory("FadeIntensity", 1);
		
		// had enough of armor fucking up
		/*if(!GetArmorAmount())
			SetInventory("DnD_ArmorType", 0);*/
		
        Delay(const:1);

		// we can flash again now
		PlayerScriptsCheck[DND_SCRIPT_BLEND][pnum] = true;
    }
}

Script "DnD Weapon Input Handler" (int wepid) {
	bool temp = false;
	int pnum = PlayerNumber();

	// prevents bug related to map change + Select state of weapons, causing multiple scripts to run many times
	if(IsSetupComplete(SETUP_STATE1, SETUP_PLAYERDATAFINISHED))
		Terminate;

	//printbold(s:"run input handler for ", d:wepid);
	switch(wepid) {
		case DND_WEAPON_HELLSMAW:
			while(PlayerInGame(pnum) && CheckInventory("DnD_WeaponID") == wepid) {
				// additional hack for the slayer/hells maw weapon's dynamic fire modes	
				if(!CheckInventory("ShowingMenu")) {
					// shit hacks to prevent some bug...
					if(temp) {
						GiveInventory("HellsMawSynthActive", 1);
						GiveInventory("SynthFireFix", 1);
						temp = false;
					}
					
					if(CheckInventory("HellsMawSynthActive")) {
						if(GetPlayerInput(-1, INPUT_BUTTONS) & BT_ATTACK) 
							GiveInventory("HellsMawSynthFireLeft", 1);
						else 
							TakeInventory("HellsMawSynthFireLeft", 1);
						
						if (GetPlayerInput(-1, INPUT_BUTTONS) & BT_ALTATTACK) 
							GiveInventory("HellsMawSynthFireRight", 1);
						else 
							TakeInventory("HellsMawSynthFireRight", 1);
							
						if(isAlive() && (CheckInventory("HellsMawFiringRight") || CheckInventory("HellsMawFiringLeft")))
							SetActorState(0, "Melee");
					}
				}
				else if(!temp) {
					temp = true;
					TakeInventory("HellsMawSynthActive", 1);
				}
				Delay(const:1);
			}
			TakeInventory("HellsMawSynthFireLeft", 1);
			TakeInventory("HellsMawSynthFireRight", 1);
		break;
		case DND_WEAPON_SLAYER:
			while(PlayerInGame(pnum) && CheckInventory("DnD_WeaponID") == wepid) {
				if(!CheckInventory("ShowingMenu") && (GetPlayerInput(-1, INPUT_BUTTONS) & BT_ALTATTACK) && !CheckInventory("SlayerTimer"))
					GiveInventory("SlayerBack", 1);
				Delay(const:1);
			}
		break;
		case DND_WEAPON_HADES:
			while(PlayerInGame(pnum) && CheckInventory("DnD_WeaponID") == wepid) {
				if(!CheckInventory("ShowingMenu") && (GetPlayerInput(-1, INPUT_BUTTONS) & BT_ALTATTACK) && CheckInventory("HadesBurstFired") && !CheckInventory("HadesBurstTimer")) {
					GiveInventory("MakeHadesBurst", 1);
					GiveInventory("HadesBurstCooldown", 1);
					TakeInventory("HadesBurstFired", 1);
				}
				Delay(const:1);
			}
		break;
		case DND_WEAPON_TORPEDOLAUNCHER:
			while(PlayerInGame(pnum) && CheckInventory("DnD_WeaponID") == wepid) {
				if(!CheckInventory("ShowingMenu") && (GetPlayerInput(-1, INPUT_BUTTONS) & BT_ALTATTACK) && !CheckInventory("TorpedoTimer")) {
					GiveInventory("TorpedoBoomSignal", 1);
					GiveInventory("TorpedoTimer", 1);
					ActivatorSound("Torpedo/Beep", 108);
				}
				Delay(const:1);
			}
		break;
		case DND_WEAPON_VOIDCANNON:
			while(PlayerInGame(pnum) && CheckInventory("DnD_WeaponID") == wepid) {
				if(!CheckInventory("ShowingMenu") && (GetPlayerInput(-1, INPUT_BUTTONS) & BT_ALTATTACK))
					GiveInventory("VoidDetonation", 1);
				Delay(const:1);
			}
		break;
	}
}

// blend scripts, for some reason they seem to be running twice...
Script "DnD Get Pain Alpha" (void) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber()) {
		SetResultValue(0);
		Terminate;
	}

	int dmg_received = CheckInventory("DnD_DamageFade");
	if(GetHelmID() == HELMS_SYNTHMETAL)
		dmg_received /= DND_SYNTHMASK_EFFECT;
		
	// max 75% alpha on really hard hits
	// we get the relative weight of this damage compared to our health cap
	int cap = CheckInventory("PlayerHealthCap");
	if(!cap)
		cap = GetSpawnHealth();
	// return min 10% of alpha at any damage regardless, it looks too weak to notice otherwise
	dmg_received = Min(DND_PAINBLEND_MAXALPHA, 25 + dmg_received * 100 / cap);
	
	SetResultValue(dmg_received);
}

Script "DnD Get Pain Tics" (void) CLIENTSIDE {
	int dmg_received = CheckInventory("DnD_DamageFade");
	if(GetHelmID() == HELMS_SYNTHMETAL)
		dmg_received /= DND_SYNTHMASK_EFFECT;
		
	// dont go too overboard with this, cap it
	int cap = CheckInventory("PlayerHealthCap");
	if(!cap)
		cap = GetSpawnHealth();
	
	dmg_received = Clamp_Between(dmg_received * DND_PAINBLEND_MAXTICS / cap, DND_PAINBLEND_MINTICS, DND_PAINBLEND_MAXTICS);

	SetResultValue(dmg_received);
}

// made this clientside as its easier on server for load
Script "DnD Blend Start" (int blend_id) CLIENTSIDE {
	switch(blend_id) {
		case PAINBLEND_RED:
			GiveInventory("PainBlend_Red", 1);
		break;
		case PAINBLEND_GREEN:
			GiveInventory("PainBlend_Green", 1);
		break;
		case PAINBLEND_DARKSLATEGRAY:
			GiveInventory("PainBlend_DarkSlateGray", 1);
		break;
		case PAINBLEND_MIDNIGHTBLUE:
			GiveInventory("PainBlend_MidnightBlue", 1);
		break;		
		case PAINBLEND_DARKSLATEBLUE:
			GiveInventory("PainBlend_DarkSlateBlue", 1);
		break;
		case PAINBLEND_ORANGE:
			GiveInventory("PainBlend_Orange", 1);
		break;
		case PAINBLEND_LIGHTGREEN:
			GiveInventory("PainBlend_LightGreen", 1);
		break;
		case PAINBLEND_DARKGOLDENROD:
			GiveInventory("PainBlend_DarkGoldenRod", 1);
		break;
		case PAINBLEND_LIGHTBLUE:
			GiveInventory("PainBlend_LightBlue", 1);
		break;
		case PAINBLEND_LIGHTSLATEBLUE:
			GiveInventory("PainBlend_LightSlateBlue", 1);
		break;
		case PAINBLEND_MEDIUMPURPLE:
			GiveInventory("PainBlend_MediumPurple", 1);
		break;
		case PAINBLEND_BLUE:
			GiveInventory("PainBlend_Blue", 1);
		break;
		case PAINBLEND_GRAY:
			GiveInventory("PainBlend_Gray", 1);
		break;
	}
	SetResultValue(0);
}

Script "DnD Hit Blend" (int blend_id) {
	// temporary fix to hit blends causing blinds to end
	if(CheckInventory("IsBlinded"))
		Terminate;

	int pnum = PlayerNumber();
	
	// player got hurt, but wait till we get OK for next tic to have accumulated the damage
	while(!PlayerScriptsCheck[DND_SCRIPT_BLEND][pnum])
		Delay(const:1);
	
	int amt = PlayerScriptsCheck[DND_SCRIPT_DAMAGETAKENTIC][pnum];
	if(!amt)
		Terminate;
		
	// and since blend scripts run twice, this had to be done... pass along the accumulated data and overwrite for next use
	SetInventory("DnD_DamageFade", amt);
	PlayerScriptsCheck[DND_SCRIPT_DAMAGETAKENTIC][pnum] = 0;
	
	PlayerScriptsCheck[DND_SCRIPT_BLEND][pnum] = false;
	
	ACS_NamedExecuteWithResult("DnD Blend Start", blend_id);

	SetResultValue(0);
}

Script "DnD Synth Mask Acquired" (void) {
	int res = GetHelmID() == HELMS_SYNTHMETAL ? DND_SYNTHMASK_EFFECT : 1;
	SetResultValue(res);
}

Script "DND Killing Spree End" (int spree, int mult, int reward) CLIENTSIDE {
	LocalAmbientsound("KillStreak/Show", 127);
	SetHudSize(480, 360, 0);
	str temp = "KILLST";
	for(int i = 0; i < 4; ++i) {
		SetFont(StrParam(s:temp, d:i + 1));
		HudMessage(s:"A"; HUDMSG_FADEOUT, DND_SPREE_BLOODID, CR_WHITE, 220.4, 324.0, 3.0, 1.0);		
		Delay(3);
	}
	SetFont("MONFONT");
	HudMessage(s:"\ci", l:GetSpreeText(mult), s:"!\c- \cix", s:GetFixedRepresentation(mult * DND_SPREE_BASE_F, false), s:"\c- ", l:"DND_TEXT_BONUS", s:"!"; HUDMSG_FADEINOUT, DND_SPREE_TEXT1ID, CR_WHITE, 240.4, 320.0, 2.0, 1.0, 1.0);
	HudMessage(l:"DND_TEXT_GAINEDEXTRA", s:" \cf", d:reward, s: "\c- ", l:"DND_STAT16", s:"!"; HUDMSG_FADEINOUT, DND_SPREE_TEXT2ID, CR_WHITE, 240.4, 328.0, 2.0, 1.0, 1.0);
}

Script "DnD Killing Spree Timer" (void) {
	while(CheckInventory("DnD_SpreeTimer")) {
		TakeInventory("DnD_SpreeTimer", 1);
		Delay(const:1);
	}
	// countdown over, reset spree xp and handle spree stuff
	TakeInventory("DnD_SpreeCountdownRunning", 1);

	if(CheckInventory("DnD_MultikillCounter")) {
		while(CheckInventory("DnD_SpreeTimer"))
			Delay(const:1);
		if(CheckInventory("DnD_MultikillCounter") >= DND_SPREE_TRIGGER && isAlive()) {
			int spree = CheckInventory("DnD_MultiKillCounter") + 1, mult = 0, reward = 0, temp;
			SetInventory("DnD_MultiKillCounter", 0);
			// shows kill spree result on hud
			// for every 10 enemy killed in spree, add a 0.25 multiplier
			// base multiplication factor is 0.25
			mult = Clamp_Between(spree / DND_SPREE_PER, 1, MAX_SPREE_MULT); // how many .25 to add
			int prev_mult = mult;
			
			temp = CheckInventory("SpreeXP") / DND_SPREE_BASE;
			if(!temp)
				temp = 1;
			
			while(mult) {
				// no overflow
				if(reward < INT_MAX - temp)
					reward += temp;
				--mult;
			}
			if(IsQuestComplete(0, QUEST_10SPREES))
				reward += reward * DND_QUEST_BERSERK_SPREEBONUS / 100;
			ACS_NamedExecuteAlways("DND Killing Spree End", 0, spree, prev_mult, reward);
			GiveExp(reward, true);
			
			// check 10 kill spree quest
			if(active_quest_id == QUEST_10SPREES && !IsQuestComplete(0, QUEST_10SPREES)) {
				GiveInventory("DnD_BerserkQuest_SpreeCounter", 1);
				if(CheckInventory("DnD_BerserkQuest_SpreeCounter") >= DND_QUEST_BERSERK_SPREEREQ)
					CompleteQuest(ActivatorTID(), QUEST_10SPREES);
			}
			
			// punisher perk 2 -- -2 means was at least merciless
			temp = spree / DND_SPREE_PER;
			if(HasClassPerk_Fast("Punisher", 2) && temp >= 2) {
				temp = DND_PUNISHER_SPREERECOVER + DND_PUNISHER_SPREEPERBONUS * (temp - 2);
				if(temp > 100)
					temp = 100; // don't give more than 100% of caps
				
				ACS_NamedExecuteAlways("DnD Health Pickup", 0, temp);
			}
		}
		else {
			SetInventory("DnD_MultikillCounter", 0);
			SetInventory("SpreeXP", 0);
		}
		
		// spree ended
		TakeInventory("Punisher_Perk5_MoveSpeed", 1);
	}
	SetInventory("DnD_SpreeTimer", 0);
}

Script "DND On Revive" (void) {
	SetInventory("DnD_AilmentToken", 0);
	TakeInventory("Mo_Died", 1);
	TakeInventory("MonsterKilledByPlayer", 1);
	TakeInventory("Doomguy_CanExecute", 1);
	TakeInventory("Doomguy_ChangedColor", 1);
	//Mob that gets revived don't call Monster Scale script. Make sure some of its effects get reapplied here.
	int this = ActivatorTID();
	int id = this - DND_MONSTERTID_BEGIN;
	if (MonsterProperties[id].maxhp) { // This could be skipped if all mobs have their Monster Scaling.
		SetEliteFlag(DND_REVIVED, true); // Add "Revived" trait to mob. Also gives "Mo_Revived" item.
		// Reapply the elite FX.
		if (MonsterProperties[id].isElite)
			ACS_NamedExecuteAlways("DND Spawn Attachment", 0, this);
		//Log(s:"Monster id: ",d:MonsterProperties[id].id,s:", (After Respawn) Mob spawn hp:", d:GetActorProperty(0, APROP_SpawnHealth), s:", Mob hp:", d:GetActorProperty(0, APROP_Health), s:", Mob realhp",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp);
		//Mob revives with "APROP_SpawnHealth" HP. Make sure it respawns with the right max hp.
		int maxhp = MonsterProperties[id].maxhp;
		int dmg = GetActorProperty(0, APROP_SpawnHealth) - GetActorProperty(0, APROP_Health);
		SetActorProperty(0, APROP_HEALTH, maxhp);
		Clamp_Between(dmg, 0, maxhp + 1);
		Thing_Damage2(this, dmg, "None");
		//Mob might actually be dead by this point.
		if (GetActorProperty(0, APROP_Health) > maxhp) //In the rare case the mob keeps the very high hp
			Thing_Damage2(this, GetActorProperty(0, APROP_Health) + 1, "None"); //Just kill it

		HandleSpecialTraits(this, MonsterProperties[id].id, true);
	}
	//Log(s:"(Really After Respawn) Mob spawn hp:", d:GetActorProperty(0, APROP_SpawnHealth), s:", Mob hp:", d:GetActorProperty(0, APROP_Health));
	ACS_NamedExecuteAlways("DnD On Revive CS", 0);

	// check if we are revived by a player now, set it up and stuff if so
	int temp = GetActorProperty(this, APROP_MASTERTID);
	if(IsPlayer(temp)) {
		int pnum = temp - P_TIDSTART;
		// set player related stuff here
		GiveActorInventory(temp, "PetCounter", 1);
		//printbold(s:"give pet counter total: ", d:CheckActorInventory(temp, "PetCounter"));

		SpawnForced("EnemyResSoul", GetActorX(0), GetActorY(0), GetActorZ(0) + GetActorProperty(0, APROP_HEIGHT) / 4);
		PlaySound(0, "Sickle/GhostRes", CHAN_5, 1.0);

		int lifetime = DND_SICKLE_RESTIME_BASE + GetIntellectEffect(pnum, 1, DND_SICKLE_RESTIME_FACTOR);

		ACS_NamedExecuteWithResult("DnD Sync Hack Immediate", GetActorX(0), GetActorY(0), GetActorZ(0));

		// timer and follow setups
		ACS_NamedExecuteWithResult("DnD Timed Monster", lifetime, 1);
		ACS_NamedExecuteAlways("DND Spawn Attachment", 0, this, DND_ATTACHMENT_PETICON);
		// don't give this, they are solid and block the player
		ACS_NamedExecuteAlways("DnD Pet Distance Move", 0);
	}

	// check if they were blocking and clear if they were
	if(HasTrait(id, DND_ISBLOCKING))
		ACS_NamedExecuteWithResult("DnD Monster Trait Take", DND_ISBLOCKING, -1, -1, -1);

	GiveInventory("DnD_MonsterSetupDone", 1);
}

Script "DnD On Revive CS" (void) CLIENTSIDE {
	TakeInventory("Mo_Died", 1);
}

// Make sure clients are aware too
Script "DND On Kill CS" KILL CLIENTSIDE {
	GiveInventory("Mo_Died", 1);
	DisposeAttachments(ActivatorTID() - DND_MONSTERTID_BEGIN);
}

Script "DnD On Kill Forced CS" (void) CLIENTSIDE {
	GiveInventory("Mo_Died", 1);
	DisposeAttachments(ActivatorTID() - DND_MONSTERTID_BEGIN);
}

// accepts similar flags to explosion actors
Script "DnD Scale Non Weapon Damage" (int damage, int damage_type, int flags) {
	if(damage) {
		int owner = GetActorProperty(0, APROP_TARGETTID);
		
		// apply base damage bonuses that weapons normally get here
		//printbold(d:damage, s: " became => ", d:ApplyNonWeaponBaseDamageBonus(owner, damage, damage_type, flags));
		SetResultValue(ApplyNonWeaponBaseDamageBonus(owner, damage, damage_type, flags));
	}
}

/*Script "DnD Check Elite Clear" (void) CLIENTSIDE {
	SetActivatorToTarget(0);
	//printbold(d:ActivatorTID(), s: " ", s:GetActorClass(0));
	SetResultValue(!ActivatorTID() || CheckInventory("Mo_Died") || GetActorProperty(0, APROP_HEALTH) <= 0);
}*/

// Used for exp and credit calculations
Script "DND On Kill" KILL {
	int this = ActivatorTID();
	int m_id = this - DND_MONSTERTID_BEGIN;
	
	// pet check -- pets dont have anything going for them beyond here
	if(IsPet(this) || GetGamemodeState() != GAMESTATE_INPROGRESS) {
		Thing_ChangeTID(this, 0);
		Terminate;
	}

	// put here to fix lingering blind fx bug
	if(IsBlindCastingMonster(MonsterProperties[m_id].id))
		ACS_NamedExecuteWithResult("DnD Monster Blind Cancel CS");

	MonsterProperties[m_id].isIdle = false;
	
	GiveInventory("Mo_Died", 1);
	TakeInventory("DnD_CullSuccess", 1);

	if(CheckInventory("Doomguy_ChangedColor")) {
		TakeInventory("Doomguy_ChangedColor", 1);
		ACS_NamedExecuteWithResult("DnD Doomguy Execute Translation", this, 1, MonsterProperties[m_id].id);
	}
	
	int target = GetActorProperty(0, APROP_TARGETTID), temp;

	if(HasTrait(m_id, DND_ENSHROUDED))
		ACS_NamedExecuteAlways("DnD Aura Giver CS", 0, DND_ENSHROUDED, 1);

	// don't continue if monster is revived or summoned
	if(HasTrait(m_id, DND_SUMMONED) || HasTrait(m_id, DND_REVIVED)) {
		// regular pets get eliminated by the top if statement, so player summoned ones should deduce pet counter
		temp = GetActorProperty(this, APROP_MASTERTID);
		if(IsPlayer(temp)) {
			TakeActorInventory(temp, "PetCounter", 1);
			//printbold(s:"take pet total: ", d:CheckActorInventory(temp, "PetCounter"));
		}
		else
			HandleDoomguyExecute(target, this);

		Terminate;
	}
	
	// check if this was a pet to give kill credit to the owner
	temp = GetActorProperty(target, APROP_MASTERTID);
	if(IsPlayer(temp) && CheckFlag(target, "FRIENDLY"))
		target = temp;

	bool killerWasntPlayer = !CheckInventory("MonsterKilledByPlayer");
	TakeInventory("MonsterKilledByPlayer", 1);

	MonsterProperties[this - DND_MONSTERTID_BEGIN].killer_tid = target;
	
	// if this was a unique boss monster, since its dead now we can clear it to clients
	if(isUniqueBossMonster(m_id)) {
		DungeonBossData[BOSSDATA_TID] = 0;
		ACS_NamedExecuteWithResult("DnD Register Unique Boss", 0);
	}
	
	// only work if you can determine target as a player and if the player is alive
	// if player has no level data don't process anything as it's somehow bad state to work with
	if(!IsActorAlive(target) || !GetActorLevel(target))
		Terminate;
		
	// if theres cooldown item, reduce by a second here
	TakeActorInventory(target, "Marine_Perk50_Cooldown", TICRATE);

	HandleDoomguyExecute(target, this);

	// remove freeze and chill timers
	SetInventory("DnD_ChillStacks", 0);
	SetInventory("DnD_FreezeTimer", 0);

	ACS_NamedExecuteAlways("DnD Monster Death Effects", 0, this, m_id);
		
	if(MonsterProperties[m_id].trait_list[DND_MARKOFCHAOS]) {
		--NPC_States[DND_NPC_DARKWANDERER].offer_progress;
		// adds 5 seconds for killing it to the timer
		NPC_States[DND_NPC_DARKWANDERER].time += 5 * (1 + GetMonsterSizeType(MonsterProperties[m_id].id));
	}
	else if(MonsterProperties[m_id].trait_list[DND_MARKOFASMODEUS])
		--NPC_States[DND_NPC_DARKWANDERER].offer_progress;

	if(NPC_States[DND_NPC_DARKWANDERER].n_state == NPC_STATE_VOTE_ACCEPT && NPC_States[DND_NPC_DARKWANDERER].offer > NPC_OFFER_NA) {
		// 20% chance to add 1, 4 or 7 seconds depending on monster size
		NPC_States[DND_NPC_DARKWANDERER].time += !random(0, 4) * (1 + 3 * GetMonsterSizeType(MonsterProperties[m_id].id));
	}
	
	if(IsUniqueMonster(MonsterProperties[m_id].id))
		HandleUniqueDeath(target, MonsterProperties[m_id].id, MonsterProperties[m_id].level);

	// if nodrop is on don't bother with here
	if(!MonsterProperties[m_id].trait_list[DND_NODROPS]) {
		if(!killerWasntPlayer)
			HandleCreditExp_Regular(this, target, m_id);
		else if(!CurrentLevelData[LEVELDATA_WISDOMMASTERED] && !CurrentLevelData[LEVELDATA_GREEDMASTERED]) {
			HandleCreditExp_MasteryCheck(this, target, m_id);
			Terminate;
		}
	}
	
	// set activator back to the monster
	SetActivator(this);

	HandleNPCChallenges(this, m_id);
	
	// 25% chance to explode
	if(!random(0, 3) && HasActorClassPerk_Fast(target, "Wanderer", 4))
		ACS_NamedExecuteAlways("DnD Wanderer Explosions", 0, this, target);
		
	if(CheckInventory("DnD_OverloadTimer") && !CheckInventory("DnD_OverloadLockTime") && !GetPlayerAttributeValue(target - P_TIDSTART, INV_INC_ALLOVERLOAD)) {
		GiveInventory("DnD_OverloadZapGiver", 1);
		ACS_NamedExecuteAlways("DnD Monster Overload Zap", 0, this, target);
	}
	SetInventory("DnD_OverloadTimer", 0);

	int is_demon = IsDemon();

	// Demon Bane check
	if(is_demon) {
		if(active_quest_id == QUEST_KILL10BOSSES) {
			GiveActorInventory(target, "DnD_BossKillQuest_Counter", 1);
			if(!IsQuestComplete(target, QUEST_KILL10BOSSES) && CheckActorInventory(target, "DnD_BossKillQuest_Counter") == DND_QUEST_BOSSKILLER_REQ)
				CompleteQuest(target, QUEST_KILL10BOSSES);
		}

		if(GetPlayerAttributeValue(target - P_TIDSTART, INV_EX_DEMONBARRIERS)) {
			GiveActorInventory(target, "DaemonicBarrier", 1);
			if(!CheckActorInventory(target, "DaemonicBarrierTimer"))
				ACS_NamedExecuteAlways("DnD Demon Barrier Timeout", 0, target);
			GiveActorInventory(target, "DaemonicBarrierTimer", 1);
		}
	}
	
	// Elite Slayer check
	if(active_quest_id == QUEST_KILL20ELITES && killerWasntPlayer) {
		GiveActorInventory(target, "DnD_EliteKillQuest_Counter", 1);
		if(!IsQuestComplete(target, QUEST_KILL20ELITES) && CheckActorInventory(target, "DnD_EliteKillQuest_Counter") == DND_QUEST_ELITEKILLER_REQ)
			CompleteQuest(target, QUEST_KILL20ELITES);
	}
	
	// Legendary Kill Item
	int i;
	if(isLegendaryMonster(MonsterProperties[m_id].id)) {
		for(i = 0; i < MAXPLAYERS; ++i) {
			if(PlayerInGame(i) && IsActorAlive(i + P_TIDSTART)) {
				UpdateLegendaryKill(i, MonsterProperties[m_id].id - LEGENDARY_START);
				
				//if(active_quest_id - DND_LEGQUEST_START == MonsterProperties[m_id].id - LEGENDARY_START)
				//	CompleteQuest(i + P_TIDSTART, active_quest_id);
			}
		}

		// spawn guaranteed rewards
		SpawnOrbForAll(1);

		i = random(0, 1.0);
		if(i < SILVERCHEST_DROPWEIGHT)
			SpawnDropAtActor(this, "DNDSilverChest", 0, 0, 0, 0);
		else if(i < GOLDCHEST_DROPWEIGHT)
			SpawnDropAtActor(this, "DNDGoldChest", 0, 0, 0, 0);
		else
			SpawnDropAtActor(this, "DNDBronzeChest", 0, 0, 0, 0);

		SpawnCharmForAll(MonsterProperties[m_id].rarity_boost);
	}

	// crusader helm check
	if(IsMagicOrUndead() && (is_demon = GetPlayerAttributeValue(target - P_TIDSTART, INV_IMP_RECOVERESONUNDEADKILL)) && (temp = GetPlayerEnergyShieldCap(target - P_TIDSTART))) {
		i = temp * is_demon / 100;
		if(i < 1)
			i = 1;

		if(CheckActorInventory(target, "EShieldAmount") < temp - i)
			AddActorEnergyShield(target, i);
		else
			SetActorEnergyShield(target, temp);
	}
	
	// if marked by talisman
	i = CheckInventory("HunterTalismanMarkBool");
	SetInventory("HunterTalismanMarkBool", 0);
	
	if(isZombie())
		GiveActorInventory(target, "DnD_ShotUndead", 1);
	
	// required delay for transition from specific death state labels
	Delay(const:1);
	
	// if this isn't a dungeon boss --- we have special parameters that they themselves should call that can't be done from here!
	if(!isUniqueBossMonster(m_id))
		HandleLootDrops(this, target, MonsterProperties[m_id].isElite);
	
	// check zombie summon
	if(!IsLostSoul() && !IsRobotic()) {
		temp = GetPlayerAttributeValue(target - P_TIDSTART, INV_EX_CHANCE_ONDEATH_RAISEZOMBIE);
		if(CanActorHaveMorePets(target) && CheckActorInventory(target, "SummonedZombiePets") < MAX_SUMMON_ZOMBIECOUNT && temp >= random(1, 100)) {
			// raise zombie
			HandleZombieRaiseOnDeath(target);
		}
	}
	
	// chaos marked monsters are removed on death, no ressing
	if
	(
		CheckUniquePropertyOnPlayer(target - P_TIDSTART, PUP_SLAINENEMIESRIP) || 
		HasClassPerk_Fast("Doomguy", 5) ||
		GetPlayerAttributeValue(target - P_TIDSTART, INV_INC_ENEMYRIPCHANCE) <= random(1, 100) ||
		MonsterProperties[m_id].trait_list[DND_MARKOFCHAOS]
	)
		ACS_NamedExecuteAlways("DnD Monster RIP", 0);
	
	// from here on out we are the player
	SetActivator(target);
	
	// keep the kill tally
	IncrementPlayerLifetimeKills();
	
	is_demon = CheckInventory("Punisher_Perk50_Tiers");
	if(HasClassPerk_Fast("Punisher", 3) && is_demon < DND_MAX_PUNISHER_PERK50_TIERS) {
		// in killing spree
		if((CheckInventory("DnD_MultiKillCounter") + 1) / DND_SPREE_PER >= 1)
			GiveInventory("Punisher_Perk50_Counter", (GetPunisherTierKillBonus(m_id) * DND_PUNISHER_PERK50_KSPREEBONUS_MULT / DND_PUNISHER_PERK50_KSPREEBONUS_DIV));
		else
			GiveInventory("Punisher_Perk50_Counter", GetPunisherTierKillBonus(m_id));

		temp = GetPunisherTier();
		if(temp < DND_MAX_PUNISHER_PERK50_TIERS) {
			// tier up!
			if(is_demon < temp) {
				is_demon = FixedMul(DND_PUNISHER_PERK50_DAMAGEFACTOR, FixedDiv(fpow(1.0 + DND_PUNISHER_PERK50_BONUS_PER_TIER, temp) - 1.0, DND_PUNISHER_PERK50_BONUS_PER_TIER));
				SetInventory("Punisher_Perk50_DamageBonus", is_demon);
				SetInventory("Punisher_Perk50_Tiers", temp);
			}
			SetInventory("Punisher_Perk50_NextReq", GetPunisherTierRequirement(temp));
		}
	}
	
	if(CheckInventory("Hobo_ShotgunFrenzyTimer") && HasClassPerk_Fast("Hobo", 5))
		GiveInventory("Hobo_ShotgunFrenzyTimer", TICRATE + DND_HOBO_PERK50_RARITYBONUS * DND_MWEIGHT_COMMON / MonsterProperties[m_id].rarity);
	
	// research track
	/*if(IsBossTID(this) && CheckResearchStatus(RES_IMP1) == RES_NA) {
		GiveInventory("Research_Body_Im_1_Tracker", 1);
		if(CheckInventory("Research_Body_Im_1_Tracker") == GetAmmoCapacity("Research_Body_Im_1_Tracker")) {
			GiveResearch(RES_IMP1, true);
			// take these off so they don't take netid
			TakeInventory("Research_Body_Im_1_Tracker", 65535);
		}
	}*/
	
	if(IsMonsterIdDemon(m_id) && CheckResearchStatus(RES_SLOT3UPG3) == RES_NA) {
		GiveInventory("Research_Slot3Upgrade3_Tracker", 1);
		if(CheckInventory("Research_Slot3Upgrade3_Tracker") == GetAmmoCapacity("Research_Slot3Upgrade3_Tracker")) {
			GiveResearch(RES_SLOT3UPG3, true);
			// take these off so they don't take netid
			TakeInventory("Research_Slot3Upgrade3_Tracker", 65535);
		}
	}
	
	// Kill spree
	if(GetCVar("dnd_killspree"))
		ActivateKillingSpree();
		
	// Hunter Talisman Heal
	if(i) {
		GiveInventory("HunterTalismanHealFXSpawner", 1);
		ACS_NamedExecuteAlways("DnD Health Pickup", 0, GetSpawnHealth() / DND_HUNTERTALISMAN_HEALFACTOR);
	}

	i = GetPlayerAttributeValue(target - P_TIDSTART, INV_EX_REFILLAMMOONMELEEKILL);
	if(i && IsUsingMeleeWeapon())
		GiveOwnedWeaponsAmmo(i);
	
	temp = GetPlayerAttributeValue(PlayerNumber(), INV_EX_ONKILL_HEALMISSING);
	if(temp) {
		i = GetMissingHealth();
		temp = (i * temp) / 100;

		// if player is missing some health, but our factor was 0, make it 1
		if(!temp && i)
			temp = 1;
		
		if(temp) {
			Spawn("DarkHealEffectSpawner", GetActorX(0), GetActorY(0), GetActorZ(0), 0);
			ACS_NamedExecuteAlways("DnD Health Pickup", 0, temp);
		}
	}
}

Script "DnD Monster Death Effects" (int this, int m_id) {
	Delay(const:1);

	if(CheckInventory("DnD_DeathEffectBlock"))
		Terminate;

	if(MonsterProperties[m_id].trait_list[DND_NUCLEAR])
		ACS_NamedExecuteAlways("DnD Monster Nuclear Explosion", 0, this);
	
	if(MonsterProperties[m_id].trait_list[DND_REBIRTH]) {
		GiveInventory("DnD_RebirthItem", 1);
		MonsterProperties[m_id].trait_list[DND_REBIRTH] = false;
	}
	
	if(MonsterProperties[m_id].trait_list[DND_SUBORDINATE])
		HandleSubordinateSpawn(this, m_id);

	if(MonsterProperties[m_id].trait_list[DND_PHANTASM])
		Spawn("Phantasm", GetActorX(0), GetActorY(0), GetActorZ(0), 0);
}

Script "DnD Monster RIP" (int tid) {
	GiveActorInventory(tid, "DnD_EnemySlatedForRemoval", 1);
	Delay(const:RIP_MONSTER_FADE_DELAY);
	SetActorProperty(tid, APROP_RENDERSTYLE, STYLE_Translucent);
	int a = GetActorProperty(tid, APROP_ALPHA);
	for(int i = 1; i < RIP_FADE_TIMER; ++i) {
		SetActorProperty(tid, APROP_ALPHA, a - (i * 1.0) / RIP_FADE_TIMER);
		Delay(const:1);
	}
	Thing_Remove(tid);
}

Script "DnD Demon Barrier Timeout" (int p_tid) {
	SetActivator(p_tid);
	while(isAlive() && CheckInventory("DaemonicBarrierTimer"))
		Delay(const:HALF_TICRATE);
	SetInventory("DaemonicBarrier", 0);
}

Script "DND Show Kill Digits" (int tid, int exp, int credit) CLIENTSIDE {
	// spectators shouldn't see this
	// for some reason exp and credit can be 0, no idea how, but this fixes it
	SetResultValue(0);
	if(ConsolePlayerNumber() != PlayerNumber() || !PlayerInGame(ConsolePlayerNumber()) || (!exp && !credit))
		Terminate;
	GiveActorInventory(tid, "DnD_Exp_Counter", exp);
	GiveActorInventory(tid, "DnD_Credit_Counter", credit);
	GiveActorInventory(tid, "DnD_ExpCredit_Timer", 1);
	
	// check if we can truly terminate early, if we can, extend timer
	if(PlayerScriptsCheck[DND_SCRIPT_EXPTRACKER][ConsolePlayerNumber()]) {
		// refresh duration if we're already running one
		if(CheckActorInventory(tid, "DnD_ExpCredit_Timer"))
			GiveActorInventory(tid, "DnD_ExpCredit_Timer", 1);
		Terminate;
	}
	
	PlayerScriptsCheck[DND_SCRIPT_EXPTRACKER][ConsolePlayerNumber()] = true;
	while(CheckActorInventory(tid, "DnD_ExpCredit_Timer"))
		Delay(const:2);
	if((CheckActorInventory(tid, "DnD_Exp_Counter") || CheckActorInventory(tid, "DnD_Credit_Counter")) && !CheckActorInventory(tid, "DnD_IntermissionState"))
		Log(s:"\ccGains pickup  : \c[Y5]", d:CheckActorInventory(tid, "DnD_Exp_Counter"), s:" exp and ", d:CheckActorInventory(tid, "DnD_Credit_Counter"), s:" credits.");
	SetActorInventory(tid, "DnD_Exp_Counter", 0);
	SetActorInventory(tid, "DnD_Credit_Counter", 0);
	PlayerScriptsCheck[DND_SCRIPT_EXPTRACKER][ConsolePlayerNumber()] = false;
}

// Stat Reset
Script 832 (void) {
	int statpts = Calculate_Stats();
	int perkpts = Calculate_Perks();
	int pnum = PlayerNumber();
	StatListOpened[pnum] = 0;
	
	// don't use set here, it removes unallocated pts
	GiveInventory("AttributePoint", statpts);
	GiveInventory("PerkPoint", perkpts);
	
	// update activity for the taken stats! Fixes leftover stats bug
	int i;
	for(i = DND_ATTRIB_BEGIN; i <= DND_ATTRIB_END; ++i)
		TakeStat(i, GetPerk(i));
		
	// for perks now
	for(i = DND_PERK_BEGIN; i <= DND_PERK_END; ++i)
		TakeStat(i, GetPerk(i));

	UpdateEnergyShieldVisual(GetPlayerEnergyShieldCap(pnum));
		
	// not sure why this is here but it was before so I'll keep it for now
	SetAmmoCapacity("StoredMedkit", DND_BASE_HEALTH);
			
	// update health to new cap if higher
	int temp = GetSpawnHealth();
	if(GetActorProperty(0, APROP_HEALTH) > temp)
		SetActorProperty(0, APROP_HEALTH, temp);
	
	// update activities for unspent attrib and perk points
	UpdateActivity(pnum, DND_ACTIVITY_ATTRIBUTEPOINT, statpts, 0);
	UpdateActivity(pnum, DND_ACTIVITY_PERKPOINT, perkpts, 0);

	CalculateUnity(pnum);
}

// Weapon pickup checks, bulkiness armor check and agamotto check
Script "DnD Periodic Checks" ENTER {
	int temp;
	int pnum = PlayerNumber();
	while(PlayerInGame(pnum) && !PlayerIsSpectator(pnum)) {
		while(isAlive()) {
			// Agamotto check
			if(CheckInventory("AgamottoCheck")) {
				int input = GetPlayerInput(-1, INPUT_BUTTONS);
				if((input & (BT_FORWARD | BT_BACK | BT_MOVELEFT | BT_MOVERIGHT)) || abs(GetActorVelX(0)) > 1.0 || abs(GetActorVelY(0)) > 1.0 || abs(GetActorVelZ(0)) > 1.0) {
					if(!CheckInventory("AgamottoDefense")) {
						GiveInventory("AgamottoDefense", 1);
						TakeInventory("AgamottoOffense", 1);
					}
				}
				else if(!CheckInventory("AgamottoOffense")) {
					TakeInventory("AgamottoDefense", 1);
					GiveInventory("AgamottoOffense", 1);
				}
			}
			else {
				TakeInventory("AgamottoDefense", 1);
				TakeInventory("AgamottoOffense", 1);
			}
			
			// Sigil Check
			if(CheckInventory("SigilCheck")) {
				// give item only if there is no sigil powerup currently on player
				if(HasNoSigilPower()) {
					switch(CheckInventory("SigilCheck")) {
						case 1: // fire
							GiveInventory("ElementPower_Fire", 1);
						break;
						case 2:
							GiveInventory("ElementPower_Ice", 1);
						break;
						case 3:
							GiveInventory("ElementPower_Lightning", 1);
						break;
						case 4:
							GiveInventory("ElementPower_Earth", 1);
						break;
					}
					SetInventory("SigilCheck", (CheckInventory("SigilCheck") % 4) + 1);
				}
			}
			
			// for cautious quest
			/*if(active_quest_id == QUEST_HPOVER50 && GetActorProperty(0, APROP_HEALTH) < GetSpawnHealth())
				GiveInventory("DnD_HealthLess50", 1);

			if(active_quest_id == QUEST_SPEND25K && CheckInventory("DnD_MoneySpentQuest") >= DND_QUEST_MONEYMAKERREQ && !IsQuestComplete(ActivatorTID(), QUEST_SPEND25K))
				CompleteQuest(ActivatorTID(), QUEST_SPEND25K);*/
			
			// this used to be 7, but I reduced frequency, hopefully nothing was too dependent on this
			Delay(const:10);
		}
		Delay(const:HALF_TICRATE);
	}
}

// 894 is for database save

// Special Interaction script with NPCs
Script 895 (int val, int this) {
	if(!CheckInventory("ShowingMenu") && !CheckInventory("NPC_Trigger_Cooldown")) {
		GiveInventory("NPC_Trigger_Cooldown", 1);
		switch(val) {
			case 0:
				// dark wanderer engage script
				if(!CheckInventory("ShowingPrompt")) {
					// open
					SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
					GiveInventory("P_Frozen", 1);
					GiveInventory("ShowingPrompt", 1);
					LocalAmbientSound("RPG/MenuOpen", 127);
					
					// setup
					ClearPlayerInput(PlayerNumber(), true);
					
					bool first_time = false;
					// the inventory check makes sure you see greeting text even if you dont partake
					if((!HasMetNPC(DND_NPC_DARKWANDERER) || CheckInventory("DarkWandererFirstTime"))) {
						GiveInventory("DarkWandererFirstTime", 1);
						first_time = true;
					}
					else {
						// we met before, roll a specific dialog id that remains for the map
						SetInventory("ReceivedDialogID", NPC_States[DND_NPC_DARKWANDERER].dialog);
					}
					
					FaceActor(this, ActivatorTID());

					ACS_NamedExecuteAlways("DnD Prompt Dark Wanderer", 0, first_time, NPC_States[DND_NPC_DARKWANDERER].offer, NPC_States[DND_NPC_DARKWANDERER].n_state);
					
					MarkNPCMet(DND_NPC_DARKWANDERER);
				}
				else {
					// close
					ClosePrompt();
				}
			break;
		}
	}
}

Script 896 (void) {
	int check = 0;
	for(int i = 0; i < MAXTEMPWEPS; ++i)
		if(CheckInventory(TemporaryWeaponData[i][TEMPWEP_NAME])) {
			check = 1;
			break;
		}
	SetResultValue(!check);
}

Script 897 (void) {
	int i = random(0, MAXTEMPWEPS - 1);
	GiveInventory(TemporaryWeaponData[i][TEMPWEP_AMMO], 999);
	GiveInventory(TemporaryWeaponData[i][TEMPWEP_NAME], 1);
	// sawedoff has clip
	if(!i)
		GiveInventory("SawedoffCounter", 2);
		
	SetWeapon(TemporaryWeaponData[i][TEMPWEP_NAME]);
	LocalAmbientSound("weapons/pickup", 127);
}

Script 898 (int msg) CLIENTSIDE {
	if(PlayerNumber() != ConsolePlayerNumber()) 
		Terminate;
	if(msg)
		Log(l:"DND_TEXT_TIPBOXON");
	else
		Log(l:"DND_TEXT_TIPBOXOFF");
}

Script 899 (int tips) NET CLIENTSIDE {
	if(GetCVar("dnd_weapontips")) {
		SetCVar("dnd_weapontips", 0);
		ACS_ExecuteAlways(898, 0, 0);
	}
	else {
		SetCVar("dnd_weapontips", 1);
		ACS_ExecuteAlways(898, 0, 1);
	}
}

// 900 is in the menu.c

Script 902 (int forceset, int id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	int i = CheckInventory("AmmoChangeMessage");
	if(forceset)
		i = id;
	if(!CheckInventory("NoAmmoMessage")) {
		SetFont("DBIGFONT");
		HudMessage(l:"DND_TEXT_NOWUSING", s:" ", s:GetSpecialAmmoTag(i), s:"!"; HUDMSG_PLAIN | HUDMSG_LOG, DND_SPECIALAMMO_TEXTID, CR_WHITE, 0.5, 0.9, 2.0);
		// hack: update ammo table to trick hud
		int pos = GetCurrentWeaponID();
		Weapons_Data[pos].ammo_name1 = GetSpecialAmmoString(i, AMMOINFO_NAME);
	}
}

// Current weapon tip
Script 903 (void) NET CLIENTSIDE {
	DoWeaponTip(GetCurrentWeaponID());
}

Script "DnD Weapon Tip Trigger" (int wepid, int targetToUse) CLIENTSIDE {
	if(targetToUse)
		SetActivator(targetToUse);
		
	if(GetCVar("dnd_weapontips"))
		Terminate;
	DoWeaponTip(wepid);
}

// 904 is used by the menu

// temporary drops
Script 905 (int mode) NET {
	if(!mode) {
		int pos = GetCurrentWeaponID();
		int curweap = pos - TEMPBEGIN; // to put it in range of the temporary weapons
		int amt;
		// valid range, no drop spam and not able to while firing and has ammo to spare
		// gross hax, fix later
		if(curweap >= 0 && curweap < MAXTEMPWEPS && !CheckInventory("DropItemCooldown") && CheckInventory("TempWeaponReady")) {
			amt = CheckInventory(TemporaryWeaponData[curweap][TEMPWEP_AMMO]);
			
			// put the clip in there as ammo
			if(pos == DND_WEAPON_SAWEDOFF) {
				amt += CheckInventory("SawedoffCounter");
				SetInventory("SawedoffCounter", 0);
			}
			
			if(amt) {
				int temptid = ActivatorTID() + DND_TEMPORARY_TIDADD;
				GiveInventory("DropItemCooldown", 1);
				// the dropped versions have _D suffix
				SpawnForced(StrParam(s:TemporaryWeaponData[curweap][TEMPWEP_DROP], s:"_D"), GetActorX(0) + cos(GetActorAngle(0)), GetActorY(0) + sin(GetActorAngle(0)), GetActorZ(0) + 32, temptid);
				SetActorProperty(temptid, APROP_MASS, amt);
				ThrustThing(GetActorAngle(0) >> 8, 16, 0, temptid);
				ThrustThingZ(temptid, 8, 0, 0);
				Thing_ChangeTID(temptid, 0); // clear tid to prevent stupid shit
				GiveInventory("ForceWeaponRemove", 1);
				CleanTempAmmo();
			}
		}
	}
}

// 906 to 914 reserved
script "DnD Aspect Ratio Check ENTER" ENTER CLIENTSIDE {
	SetupScreenOffsets();
	delay(const:105);
	restart;
}

script "DnD Aspect Ratio Check RESPAWN" RESPAWN CLIENTSIDE {
	SetupScreenOffsets();
	delay(const:105);
	restart;
}

// For each ammo category, use a multiple of 10 to store values
Script 917 (int ammo_category, int weptype) {
    // if a change did occur
	if(HasSpecialAmmoForWeapon(ammo_category) != SpecialAmmoRanges[ammo_category][0]) {
		SetSpecialAmmoMode(ammo_category, weptype);
		if(ammo_category == AMMO_TYPE_SHELL || ammo_category == AMMO_TYPE_HEAVYSHELLS)
			SetInventory(Weapons_Data[GetCurrentWeaponID()].ammo_name2, 0);
		ACS_NamedExecuteAlways("DnD Force Damage Cache Recalculation", 0, PlayerNumber());
		ActivatorSound("AmmoType/Switch", 127);
		Delay(const:4);
	}
	else
		GiveInventory("NoAmmoMessage", 1);
	SetInventory("AmmoChangeMessage", 0);
}

// type = 0, check stat, type = 1, check accessory
// refactor later
Script 918 (int type, int acc, int notarget) {
	int res = 0;
	
	if(!type) { 
		if(!acc) // get strength
			res = CheckInventory("PSTAT_Strength");
	}
	else if(type == 1) { // check for accessory
		int tid = ActivatorTID();
		if(!notarget)
			tid = GetActorProperty(0, APROP_TARGETTID);
		
		if(IsAccessoryEquipped(tid, acc))
			res = 1;
	}
	else if(type == 2) { // check for abilities
		if(notarget)
			SetActivator(0, AAPTR_TARGET);
		switch(acc) {
			case 0:
				if(CheckInventory("Ability_Reloader"))
					res = 1;
			break;
			case 1:
				if(CheckInventory("Ability_Arcanery"))
					res = 1;
			break;
		}
	}
	else if(type == 3) { // talents
		Log(s:"ERROR: USING OBSOLETE SCRIPT 918 with type 3");
	}
	else if(type == 4) { // dexterity
		Log(s:"ERROR: USING OBSOLETE SCRIPT 918 with type 4");
	}
	else if(type == 5) { // bulkiness
		Log(s:"ERROR: USING OBSOLETE SCRIPT 918 with type 5");
	}
	else if(type == 6) { // gunslinger
		Log(s:"ERROR: USING OBSOLETE SCRIPT 918 with type 6");
	}
	else if(type == 7) { // boomsticks
		Log(s:"ERROR: USING OBSOLETE SCRIPT 918 with type 7");
	}
	else if(type == 8) { // super weapons
		Log(s:"ERROR: USING OBSOLETE SCRIPT 918 with type 8");
	}
	else if(type == 9)
		res = GetActorProperty(0, APROP_TARGETTID);
	SetResultValue(res);
}

Script 919 (void) NET CLIENTSIDE {
	if(!GetCVar("dnd_nofx")) {
		SetFont("NSMOLFNT");
		HudMessage(l:"DND_TEXT_SFXOFF"; HUDMSG_FADEINOUT | HUDMSG_LOG, 1, CR_WHITE, 0.5, 0.24, 1.2, 0.5, 0.35);
		SetCVar("dnd_nofx", 1);
	}
	else {
		SetFont("NSMOLFNT");
		HudMessage(l:"DND_TEXT_SFXON"; HUDMSG_FADEINOUT | HUDMSG_LOG, 1, CR_GOLD, 0.5, 0.24, 1.2, 0.5, 0.35);
		SetCVar("dnd_nofx", 0);
	}
	Delay(const:5);
}

Script "DND Special FX Handle" OPEN CLIENTSIDE {
	int pnum = ConsolePlayerNumber(); // interesting detail here: open script normally has no activator, but client runs this as soon as they connect so this value matters, not playernumber
	while(PlayerInGame(pnum) || PlayerIsSpectator(pnum)) {
		if(GetCVar("dnd_nofx"))
			Thing_Remove(SPECIAL_FX_TID);
		Delay(const:1);
	}
}

// Added because the above script doesn't work for SP case
Script "DnD Special FX Handle - SP" ENTER CLIENTSIDE {
	if(GameType() != GAME_SINGLE_PLAYER)
		Terminate;
	while(true) {
		if(GetCVar("dnd_nofx"))
			Thing_Remove(SPECIAL_FX_TID);
		Delay(const:1);
	}
}

Script "DnD Remove Check Special" (int sp, int extra) CLIENTSIDE {
	// remove if spectator
	if(!PlayerInGame(ConsolePlayerNumber()))
		Thing_Remove(0);
	else if(!extra) {
		if(ConsolePlayerNumber() != sp - 1)
			Thing_Remove(0);
	}
	else if(extra == DND_SPECIAL_RESEARCH) {
		// research remove depends on if the guy has this research
		// no player check in SP
		if(GameType() != GAME_SINGLE_PLAYER) {
			if(ConsolePlayerNumber() != (sp & 0xFFFF) - 1 || CheckActorResearchStatus(ConsolePlayerNumber() + P_TIDSTART, sp >> 16))
				Thing_Remove(0);
		}
		else if(CheckActorResearchStatus(ConsolePlayerNumber() + P_TIDSTART, sp >> 16))
			Thing_Remove(0);
	}
	else if(extra & (DND_SPECIAL_ORB | DND_SPECIAL_TALENTCAPSULE | DND_SPECIAL_CHARM)) {
		if((sp & 0xFFFF) != 256 && ConsolePlayerNumber() != (sp & 0xFFFF) - 1)
			Thing_Remove(0);
		else
			SetActorProperty(0, APROP_ALPHA, 1.0);
	}
}

Script "DnD Player Speed Slowdown" (int percent) {
	if(!percent) {
		if(!CheckInventory("ShowingMenu")) // don't break menu functionality
			SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
		RestoreRPGStat(RES_PLAYERSPEED);
	}
	else {
		percent = ((percent << 16) / 100);
		SlowPlayer(percent, 0, 0);
	}
	SetResultValue(0);
}

Script 920 (int mode) {
	if(!mode) {
		SlowPlayer(0, SF_FREEZE, 0);
	}
	else {
		// hacky fix: while this player can load, hold back on fixing player movement
		while(isSoftorHardcore() && PlayerCanLoad[PlayerNumber()])
			Delay(17);
		if(mode == 1) {
			if(!CheckInventory("ShowingMenu")) // don't break menu functionality
				SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
			RestoreRPGStat(RES_PLAYERSPEED);
			TakeInventory("P_Frozen", 1);
		}
		else if(mode == 2) {
			if(!CheckInventory("MinigunFiring"))
				SlowPlayer(0.75, 0, 0);
		}
	}
}

Script 921 (int type, int duration) {
	Delay(duration);
	switch(type) {
		case 0:
			GiveInventory("ChangeReflect", 1);
			TakeInventory("P_Invulnerable", 1);
		break;
		case 1:
			SetPlayerProperty(0, 0, PROP_BUDDHA);
			TakeInventory("P_Invulnerable", 1);
		break;
	}
}

script 922 (int actor_num, int radius, int totalactors) {
     int angle = GetUserVariable(0, "user_angle") * 360; 
     Thing_ChangeTID(0, REFLECTFXTID);
	 SetActivatorToTarget(0);
	 int owner = ActivatorTID();
	 // the below arrangement ensures each and every actor gets a unique TID relative to the owner's tid
	 int newtid =  REFLECTFXTID + ((owner % MAXPLAYERS) + 1) * totalactors + actor_num;
	 Thing_ChangeTID(REFLECTFXTID, newtid);
	 
	 int cx = radius * cos(angle) + GetActorX(owner);
	 int cy = radius * sin(angle) + GetActorY(owner);
	 int cz = GetActorZ(owner) + 32.125;
	 
	 SetActorPosition(newtid, cx, cy, cz, 0);
}

// Till 922 are reserved for mons.c

Script "DnD Setup Shootable" (void) {
	if(!ActivatorTID())
		GiveShootableTID();
}

// Monster scaler -- add scaling stuff here
Script "DnD Monster Scale" (int monsterid, int isSummoned) {
	GiveMonsterTID(ActivatorTID());

	//printbold(s:"Monster ", s:GetActorClass(0), s:" id ", d:ActivatorTID());
	//printbold(s:"Monster id: ",d:monsterid,s:", (After Spawn) Mob spawn hp:", d:GetActorProperty(0, APROP_SpawnHealth), s:", Mob hp:", d:GetActorProperty(0, APROP_Health), s:", Mob realhp",d:realhp);
	//Make sure mob gets to right amount of hp at this point
	int maxhp, base, add, pcount = PlayerInformationInLevel[PLAYERLEVELINFO_COUNTATSTART], this = ActivatorTID(), realhp = MonsterData[monsterid].health;
	int m_id = this - DND_MONSTERTID_BEGIN;

	// reset attachment array to 0
	ACS_NamedExecuteWithResult("Dnd Init Monster Attachments", m_id);

	if(!pcount)
		pcount = 1;
	
	MonsterProperties[m_id].id = monsterid;
	
	LoadMonsterTraits(m_id, monsterid);
	if(isSummoned)
		MonsterProperties[m_id].trait_list[DND_SUMMONED] = true;

	//MonsterProperties[m_id].trait_list[DND_VENOMANCER] = true;

	if(GetCVar("dnd_monsterscale")) {
		// scaling code -- delay is because monsters are initialized before enter scripts are executed
		while(DnD_StateChecker[DND_STATECHECK_PLAYERJOIN] < PlayerInformationInLevel[PLAYERLEVELINFO_COUNTATSTART])
			Delay(const:3);
		//This delay needs a check
		//Delay(35); // wait just in case someone leaves, disconnect script will correct the level
		pcount = PlayerInformationInLevel[PLAYERLEVELINFO_COUNTATSTART];
		if(!pcount)
			pcount = 1;
		maxhp = ScaleMonster(this, m_id, pcount, realhp, isSummoned);
	}
	else {
		maxhp = realhp;
		MonsterProperties[m_id].basehp = maxhp;
		MonsterProperties[m_id].maxhp = maxhp;
		MonsterProperties[m_id].level = 1;
	}

	// run elite checks
//#ifdef ISDEBUGBUILD
//	if(1)
//#else
	if(
		!IsEliteException(m_id, monsterid) && GetCVar("dnd_enable_elites") 																	&& 
		RollEliteChance() && PlayerInformationInLevel[PLAYERLEVELINFO_LEVELATSTART] / pcount >= GetCVar("dnd_elite_spawnlevel")				&&
		!IsUniqueMonster(monsterid)
	)
//#endif
	{
		MonsterProperties[m_id].isElite = true;
		
		// Elite bonuses
		base = maxhp;
		add = base * GetEliteHealthScale(MonsterProperties[m_id].level) / 100;
		maxhp = base + add;
		
		MonsterProperties[m_id].basehp = maxhp;
		MonsterProperties[m_id].maxhp = maxhp;
		// roll more traits randomly
		int traitcount = random(DND_MIN_ELITEMODS, DND_MAX_ELITEMODS);
		DecideEliteTraits(this, m_id, traitcount);
		// Double Health
		if(MonsterProperties[m_id].trait_list[DND_VITAL]) {
			base = maxhp;
			add = base * DND_ELITE_VITAL_SCALE / 100;
			maxhp = Clamp_Between(base + add, 1, INT_MAX);
			MonsterProperties[m_id].basehp = maxhp;
			MonsterProperties[m_id].maxhp = maxhp;
		}
	}
	else // important addition to prevent elite name from clogging up later, uncleaned
		MonsterProperties[m_id].isElite = false;
		
	HandlePostInitTraits(m_id, monsterid, -1);
	
	// sync the decided traits
	ACS_NamedExecuteWithResult(
		"DnD Sync Monster Trait CS", 
		m_id, 
		GetMonsterTraits(m_id, 0),
		GetMonsterTraits(m_id, 1),
		GetMonsterTraits(m_id, 2)
	);
	
	//printbold(s:"(Before) Mob spawn hp:", d:GetActorProperty(0, APROP_SpawnHealth), s:", Mob hp:", d:GetActorProperty(0, APROP_Health), s:", Mob realhp",d:realhp, s:", Mob current hp:", d:maxhp);
	//int dmg = GetActorProperty(0, APROP_SpawnHealth) - GetActorProperty(0, APROP_Health);
	SetActorProperty(0, APROP_HEALTH, maxhp);
	
	ScaleMonsterMass(MonsterProperties[m_id].level);
	/*Clamp_Between(dmg, 0, maxhp + 1);
	Thing_Damage2(this, dmg, "None");*/
	//Mob might actually be dead by this point.
	if (GetActorProperty(0, APROP_Health) < realhp || GetActorProperty(0, APROP_Health) == INT_MAX) {
		// In the rare case the mob keeps the very high hp, if some reason SetActorProperty fails.
		// Just kill it
		//Thing_Damage2(ActivatorTID(), GetActorProperty(0, APROP_Health) + 1, "None");
		Thing_Remove(this);
		SetResultValue(0);
		Terminate;
	}
	
	// handle things that should be given specifically to certain traits
	// commented out as we already did this in decidetraits, this is only relevant for reviving monsters
	// HandleSpecialTraits(m_id, monsterid);

	for(maxhp = 0; maxhp < DND_MAX_MONSTER_PRECALC_RNG; ++maxhp)
		MonsterProperties[m_id].rng_vals[maxhp] = random(0, 1.0);
	
	// set its true height user variable user_spawnheight
	// printbold(s:"set spawn height to ", d:GetActorProperty(0, APROP_HEIGHT) >> 16);
	SetUserVariable(0, "user_spawnheight", GetActorProperty(0, APROP_HEIGHT) >> 16);
	
	GiveInventory("DnD_MonsterSetupDone", 1);
	
	SetResultValue(0);
}

// properties holds the monster id in first 9 bits (512 custom monsters... more than enough)
// next 5 bits holds monster class (shotgunner, baron etc)
// next 6 bits holds monster type powers (demon, undead, zombie, robot etc.)
Script "DnD Custom Monster Scale" (int properties, int traits, int traits2, int traits3) {
	GiveMonsterTID(ActivatorTID());
	int maxhp, base, add, pcount = PlayerCount(), this = ActivatorTID(), realhp = GetActorProperty(0, APROP_SPAWNHEALTH);
	int m_id = this - DND_MONSTERTID_BEGIN;
	if(!pcount)
		pcount = 1;
		
	MonsterProperties[m_id].id = properties & 0x1FF;
	MonsterProperties[m_id].class = (properties >> 9) & 0x1F;
	properties >>= 14;
		
	if(GetCVar("dnd_monsterscale")) {
		// scaling code -- delay is because monsters are initialized before enter scripts are executed
		while(DnD_StateChecker[DND_STATECHECK_PLAYERJOIN] < PlayerCount())
			Delay(const:3);
		if(!pcount)
			pcount = 1;
		maxhp = ScaleMonster(this, m_id, pcount, realhp, MonsterProperties[m_id].trait_list[DND_SUMMONED]);
	}
	else {
		maxhp = realhp;
		MonsterProperties[m_id].basehp = maxhp;
		MonsterProperties[m_id].maxhp = maxhp;
		MonsterProperties[m_id].level = 1;
	}
	
	LoadCustomMonsterTraits(m_id, properties, traits, traits2, traits3);
	
	GiveInventory("MonsterTypeToken", properties);
	ACS_NamedExecuteWithResult("DnD Sync Custom Monster Type", properties);

	// never roll elite status on FRIENDLY custom monsters / unique bosses
	if
	(
		!CheckFlag(0, "FRIENDLY") &&
		!MonsterProperties[m_id].trait_list[DND_LEGENDARY] && 
		MonsterProperties[m_id].id != MONSTER_CUSTOM_UNIQUEBOSS && 
		GetCVar("dnd_enable_elites") && 
		RollEliteChance() && 
		PlayerInformationInLevel[PLAYERLEVELINFO_LEVELATSTART] / pcount >= GetCVar("dnd_elite_spawnlevel")
	) {
		MonsterProperties[m_id].isElite = true;

		// Elite bonuses
		base = maxhp;
		add = base * GetEliteHealthScale(MonsterProperties[m_id].level) / 100;
		maxhp = base + add;
		MonsterProperties[m_id].basehp = maxhp;
		MonsterProperties[m_id].maxhp = maxhp;
		// roll more traits randomly
		int traitcount = random(DND_MIN_ELITEMODS, DND_MAX_ELITEMODS);
		DecideEliteTraits(this, m_id, traitcount);
		// Double Health
		if(MonsterProperties[m_id].trait_list[DND_VITAL]) {
			base = maxhp;
			add = base * DND_ELITE_VITAL_SCALE / 100;
			maxhp = Clamp_Between(base + add, 1, INT_MAX);
			MonsterProperties[m_id].basehp = maxhp;
			MonsterProperties[m_id].maxhp = maxhp;
		}
	}
	else // important addition to prevent elite name from clogging up later, uncleaned
		MonsterProperties[m_id].isElite = false;
		
	HandlePostInitTraits(m_id, MonsterProperties[m_id].id, -1);

	// sync the decided traits
	ACS_NamedExecuteWithResult(
		"DnD Sync Monster Trait CS", 
		m_id, 
		GetMonsterTraits(m_id, 0),
		GetMonsterTraits(m_id, 1),
		GetMonsterTraits(m_id, 2)
	);
	
	//printbold(s:"(Before dmg) Mob spawn hp:", d:GetActorProperty(0, APROP_SpawnHealth), s:", Mob hp:", d:GetActorProperty(0, APROP_Health), s:", Mob realhp",d:realhp, s:", Mob current hp:", d:maxhp);
	//int dmg = GetActorProperty(0, APROP_SpawnHealth) - GetActorProperty(0, APROP_Health);
	SetActorProperty(0, APROP_HEALTH, maxhp);
	
	ScaleMonsterMass(MonsterProperties[m_id].level);
	/*Clamp_Between(dmg, 0, maxhp + 1);
	Thing_Damage2(this, dmg, "None");*/
	//Mob might actually be dead by this point.
	if (GetActorProperty(0, APROP_Health) < realhp || GetActorProperty(0, APROP_Health) == INT_MAX) {
		// In the rare case the mob keeps the very high hp, if some reason SetActorProperty fails.
		// Just kill it
		//Thing_Damage2(ActivatorTID(), GetActorProperty(0, APROP_Health) + 1, "None");
		Thing_Remove(this);
		SetResultValue(0);
		Terminate;
	}
	
	// handle things that should be given specifically to certain traits
	// commented out as we already did this in decidetraits, this is only relevant for reviving monsters
	// HandleSpecialTraits(m_id, monsterid);
	
	// set its true height user variable user_spawnheight
	// printbold(s:"set spawn height to ", d:GetActorProperty(0, APROP_HEIGHT) >> 16);
	SetUserVariable(0, "user_spawnheight", GetActorProperty(0, APROP_HEIGHT) >> 16);
	
	CheckUniqueBossPossibility(this, m_id);
	
	GiveInventory("DnD_MonsterSetupDone", 1);

	SetResultValue(0);
}

Script "DnD Sync Custom Monster Type" (int token) CLIENTSIDE {
	GiveInventory("MonsterTypeToken", token);
	SetResultValue(0);
}

// Decide monster to spawn on a certain monster category given weight list
Script "DnD Monster Spawner" (int category) {
    // count and initialization
	int i = 0;

	while(!IsSetupComplete(SETUP_STATE1, SETUP_CLEANINGMONSTERTIDS))
		Delay(const:5);

	while(!IsSetupComplete(SETUP_STATE1, SETUP_MONSTERS))
		Delay(const:HALF_TICRATE);

    // add up total count and weight sum of category
    if(!MonsterCategoryData[category][MONSTERDATA_VARIATIONCOUNT]) {
        for(; i < MAX_MONSTER_VARIATIONS && Monster_Weights[category][i] != DND_MWEIGHT_ENDMARKER; MonsterCategoryData[category][MONSTERDATA_WEIGHTSUM] += Monster_Weights[category][i], ++i);
		MonsterCategoryData[category][MONSTERDATA_VARIATIONCOUNT] = i;
	}
		
    int sum = MonsterCategoryData[category][MONSTERDATA_WEIGHTSUM];
    bool picked = false;
    // for each bin, do condition check, see if roll fits in a range
    // wait for the players to enter (returns 0 to imply everyone ready)
    while(PlayerInformationInLevel[PLAYERLEVELINFO_MAXLEVEL] <= 0 || PlayersNotReadyForHardcore())
        Delay(const:10);

	// throttle the spawns -- score field is used as a means to bypass delay here
	if(GameType() != GAME_SINGLE_PLAYER && !GetActorProperty(0, APROP_SCORE))
		Delay(17 * (random(0, DND_MAX_MONSTERDELAY) + 1)); //Added 1 second for player level to be accurate first (people might load at last second).
	int roll, bin;
	int avg_level = GetAveragePlayerLevel();
	// roll legendary monster chance and do checks of it
	if(!MadeLegendary && category == DND_CYBERDEMONID && random(1, 100) <= Clamp_Between(GetCVar("dnd_legendary_chance"), 1, 100) && avg_level >= 25) {
		MadeLegendary = 1;
		// decide which legendary
		roll = random(1, DND_MAX_LEGENDARY);
		SetActorState(0, StrParam(s:"Leg", d:roll), true);
		ACS_NamedExecuteAlways("DnD Legendary Announcer", 0);
	}
	else {
		// check for unique possibility here
		if(!UniqueMonsterAvailability[category] && avg_level >= 25 && random(0, 1.0) <= GetCVar("dnd_uniquemonster_spawnchance")) {
			SetActorState(0, "Unique", true);
			UniqueMonsterAvailability[category] = true;
			Terminate;
		}
	
		int factor = Clamp_Between(GetCVar("dnd_monster_variation_factor"), 1.0, 5.0);
		while(!picked) {
			roll = random(1, sum);
			bin = 0;
			// start i from 0 here, because bin starts from 0 the added weight should be consistent with where we started
			// count is 1 more than the index allowed as is expected, so if it picked the next we must subtract 1 from bin
			for(i = 0; bin < MonsterCategoryData[category][MONSTERDATA_VARIATIONCOUNT] && i < roll; ++bin)
				i += Monster_Weights[category][bin];
			--bin;
			// go to vanilla if bin is 0
			if(!bin) {
				SetActorState(0, "Vanilla", true);
				picked = true;
			}
			else {
				// dumb spawner, just check weight
				if(!GetCVar("dnd_usesmartmonsterspawner")) {
					SetActorState(0, StrParam(s:"Var", d:bin), true);
					picked = true;
				}
				else {
					/* 	formula:
						ratio = f = VANILLA_WEIGHT / bin_weight;
						bias = b (factor default = 1.5)
						
						f <= b + PMAXLVL / (5 * f)
					*/
					
					int m_level = Monster_Weights[category][bin] << 16;
					int ratio = FixedDiv(Monster_Weights[category][0] << 16, m_level);
					int bias = random(factor / 5, factor);
					if(ratio <= bias + PlayerInformationInLevel[PLAYERLEVELINFO_MAXLEVEL] * FixedDiv(1.0, ratio) / 5) {
						SetActorState(0, StrParam(s:"Var", d:bin), true);
						picked = true;
					}
				}
			}
		}
	}
}

Script 961 (int type, int amt, int item) {
	if(type == 2)
		SetActorProperty(0, APROP_ALPHA, 0.5);
	else if(type == 3)
		SetActorProperty(0, APROP_ALPHA, 1.0);
	else if(type == 4) {
		if(!item) {
			//MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].traits = amt;
			Log(s:"I shouldn't have been called by ", s:GetActorClass(0));
		}
	}
	else if(type == 5) {
		SetResultValue(GetActorProperty(0, APROP_HEALTH) < MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp >> 1);
	}
	else if(type == 6) {
		// don't judge me, this shit just doesn't work in decorate of zan 3.0...
		Spawn("DarkHealEffectSpawner", GetActorX(0), GetActorY(0), GetActorZ(0));
	}
	else if(type == 7) {
		//printbold(s:"ActivatorTID",d:ActivatorTID(),s:" basehp",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].basehp,s:" maxhp",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp,s:" level",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].level,s:" id",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].id,s:" traits",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].traits,s:" traits2",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].traits2,s:" nameskip",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].nameskip,s:" properties",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].properties);
		amt = MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp;
		if(!amt)
			amt = GetActorProperty(0, APROP_SpawnHealth);
		SetResultValue(amt);
	}
}

// 962 - 969 are in mons.c

script 970 (int type, int actor_num, int radius) CLIENTSIDE {
	int angle, this, owner, cx, cy, cz;
	if(!type) {
		this = ActivatorTID();
		angle = (GetUserVariable(this, "user_angle") * 360) % 1.0;
		owner = GetActorProperty(this, APROP_HEALTH);
		cx = radius * cos(angle) + GetActorX(owner);
		cy = radius * sin(angle) + GetActorY(owner);
		cz = GetActorZ(owner) + 108.0;

		SetActorPosition(this, cx, cy, cz, 0);
	}
	else {
		angle = (GetUserVariable(0, "user_angle") * 360) % 1.0;
		this = ActivatorTID();
		owner = GetActorProperty(this, APROP_HEALTH);
		
		if(CheckInventory("AvatarOnAttack")) {
			angle = (60 * (actor_num - 1)) * 360;
			SetUserVariable(this, "user_angle", 60 * (actor_num - 1));
		}
		
		cx = radius * cos(angle) + GetActorX(owner);
		cy = radius * sin(angle) + GetActorY(owner);
		cz = GetActorZ(owner) + 108.0;
		SetActorPosition(this, cx, cy, cz, 0);
	}
}

// 971 - 972 are in mons.c

Script 973 (int mode) { // Avatar tid / targeter
	if (mode == 1) {
		int owner = ActivatorTID(), curdist;
		
		SetActivator(owner, AAPTR_TARGET);
		int target = ActivatorTID();
		SetActivator(owner);
		
		for(int i = 0; i < AVATAR_SOUL_COUNT; i++) {
			// choose closest target
			curdist = INT_MAX;
			for(int j = 0; j < MAXPLAYERS; j++) {
				int dist = fdistance(owner, P_TIDSTART + j);
				if(GetActorProperty(P_TIDSTART + j, APROP_HEALTH) > 0 && dist < curdist) {
					target = P_TIDSTART + j;
					curdist = dist;
				}
			}
			
			SetActorPosition(owner, GetActorX(owner), GetActorY(owner), GetActorZ(owner) + 56.0, 0);
			SpawnProjectile(owner, "HolyMissile2", GetActorAngle(owner), 128, 0, 0, AVATAR_SOUL_TID);
			SetActorPosition(owner, GetActorX(owner), GetActorY(owner), GetActorZ(owner) - 56.0, 0);
			SetActorPosition(AVATAR_SOUL_TID, GetActorX(AVATAR_SOUL_TID), GetActorY(AVATAR_SOUL_TID), GetActorZ(AVATAR_SOUL_TID) + 54.0, 0);
			SetActivator(AVATAR_SOUL_TID);
			SetPointer(AAPTR_TARGET, owner);
			SetPointer(AAPTR_TRACER, target);
			int dx = GetActorX(target) - GetActorX(AVATAR_SOUL_TID);
			int dy = GetActorY(target) - GetActorY(AVATAR_SOUL_TID);
			SetActorAngle(AVATAR_SOUL_TID, VectorAngle(dx, dy));
			Thing_ChangeTID(AVATAR_SOUL_TID, 0);
			SetActivator(owner);
			Delay(const:12);
		}
	}
	else {
		if(GetActorProperty(0, APROP_HEALTH) < MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp / 3)
			GiveInventory("AcolyteSummoner", 1);
	}
}

// Form the blade vortex
Script 974 (int radius) {
	int tid = ActivatorTID(); // Owner TID
	int newtid = tid + VORTEXTIDSTART + 16 * ((tid + 1) % MAXPLAYERS);
	
	for(int m = 0; m < 16; m++)
		Thing_Remove(newtid + m);
	
	int cx, cy, cz;
	cz = GetActorZ(tid) + 26.125;
	int pang = GetActorAngle(tid) >> 8;
	
	// i goes to 16, pang += 16 to complete 256, 360 degrees of doom.
	for(int i = 0; i < 16; ++i) {
		// initial radius is 1/32th of the intended to make all of the blades spawn properly
		cx = GetActorX(tid) + radius*cos(pang<<8)/32;
		cy = GetActorY(tid) + radius*sin(pang<<8)/32;
		pang += 16;
		Spawn("VortexBlade", cx, cy, cz, newtid + i, 0); // Basically, first 1032 are for playernum 0, then a 32 is added and it becomes 1064 etc... Max Value is 3144. (For 64th player)
		SetActivator(newtid + i);
		SetPointer(AAPTR_TARGET, tid);
		SetActivator(tid);
	}
	ACS_executeAlways(975, 0, tid, pang, radius); // Align coords
}

// Constantly rotate the ring
Script 975 (int tid, int pang, int radius) {
	// Create the phase
	int angadd = 0;
	int bladetid = tid + VORTEXTIDSTART + 16 * ((tid + 1) % MAXPLAYERS);
	str tocheck = "VortexTimer";
	if(CheckInventory("Ability_Arcanery"))
		tocheck = "VortexTimer2";
	while(true) {
		if(!CheckActorInventory(tid, tocheck) || GetActorProperty(tid, APROP_HEALTH) <= 0) {
			for(int m = 0; m < 16; ++m)
				Thing_Remove(bladetid + m);
			angadd = 0;
			break;
		}
		
		int cx, cy;
		int cz = GetActorZ(tid) + 26.125;
		
		for(int i = 0; i < 16; ++i) {
			pang += 16;
			cx = GetActorX(tid) + radius*cos((pang+angadd)<<8);
			cy = GetActorY(tid) + radius*sin((pang+angadd)<<8);
			SetActorPosition(bladetid + i, cx, cy, cz, 0);
		}
		angadd += 2;
		Delay(const:1);
	}
}

Script "DnD Golgoth Health Check" (void) {
	Delay(const:35);
	int comp = MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp / 2;
	while(GetActorProperty(0, APROP_HEALTH) < comp)
		Delay(const:10);
	GiveInventory("DnD_Boolean", 1);
	GiveInventory("MakeNoPain", 1);
}

Script "DnD Monster Trait Take" (int flag1, int flag2, int flag3, int flag4) {
	int m_tid = ActivatorTID() - DND_MONSTERTID_BEGIN;
	MonsterProperties[m_tid].trait_list[flag1] = false;
	if(flag2 != -1)
		MonsterProperties[m_tid].trait_list[flag2] = false;
	if(flag3 != -1)
		MonsterProperties[m_tid].trait_list[flag3] = false;
	if(flag4 != -1)
		MonsterProperties[m_tid].trait_list[flag4] = false;
	ACS_NamedExecuteWithResult("DnD Monster Trait Take CS", flag1, flag2, flag3, flag4);
	SetResultValue(0);
}

Script "DnD Monster Trait Take CS" (int flag1, int flag2, int flag3, int flag4) CLIENTSIDE {
	int m_tid = ActivatorTID() - DND_MONSTERTID_BEGIN;
	MonsterProperties[m_tid].trait_list[flag1] = false;
	if(flag2 != -1)
		MonsterProperties[m_tid].trait_list[flag2] = false;
	if(flag3 != -1)
		MonsterProperties[m_tid].trait_list[flag3] = false;
	if(flag4 != -1)
		MonsterProperties[m_tid].trait_list[flag4] = false;
	SetResultValue(0);
}

Script "DnD Monster Trait Take - TID" (int tid, int flag1, int flag2, int flag3) {
	int m_tid = tid - DND_MONSTERTID_BEGIN;
	MonsterProperties[m_tid].trait_list[flag1] = false;
	if(flag2 != -1)
		MonsterProperties[m_tid].trait_list[flag2] = false;
	if(flag3 != -1)
		MonsterProperties[m_tid].trait_list[flag3] = false;
	ACS_NamedExecuteWithResult("DnD Monster Trait Take CS", tid, flag1, flag2, flag3);
	SetResultValue(0);
}

Script "DnD Monster Trait Take CS - TID" (int tid, int flag1, int flag2, int flag3) CLIENTSIDE {
	int m_tid = tid - DND_MONSTERTID_BEGIN;
	MonsterProperties[m_tid].trait_list[flag1] = false;
	if(flag2 != -1)
		MonsterProperties[m_tid].trait_list[flag2] = false;
	if(flag3 != -1)
		MonsterProperties[m_tid].trait_list[flag3] = false;
	SetResultValue(0);
}

Script "DnD Monster Trait Take Single" (int tid, int flag) {
	int m_tid = tid - DND_MONSTERTID_BEGIN;
	MonsterProperties[m_tid].trait_list[flag] = false;
	ACS_NamedExecuteWithResult("DnD Monster Trait Take Single CS", tid, flag);
	SetResultValue(0);
}

Script "DnD Monster Trait Take Single CS" (int tid, int flag) CLIENTSIDE {
	int m_tid = tid - DND_MONSTERTID_BEGIN;
	MonsterProperties[m_tid].trait_list[flag] = false;
	SetResultValue(0);
}

Script "DnD Monster Trait Give" (int flag1, int flag2, int flag3, int flag4) {
	int m_tid = ActivatorTID() - DND_MONSTERTID_BEGIN;
	bool noAntiBlock = !CheckInventory("DnD_AntiBlockCounter");
	if(flag1 != DND_ISBLOCKING || noAntiBlock)
		MonsterProperties[m_tid].trait_list[flag1] = true;
	else
		flag1 = -1;

	if(flag2 != -1 && (flag2 != DND_ISBLOCKING || noAntiBlock))
		MonsterProperties[m_tid].trait_list[flag2] = true;
	else
		flag2 = -1;

	if(flag3 != -1 && (flag3 != DND_ISBLOCKING || noAntiBlock))
		MonsterProperties[m_tid].trait_list[flag3] = true;
	else
		flag3 = -1;

	if(flag4 != -1 && (flag4 != DND_ISBLOCKING || noAntiBlock))
		MonsterProperties[m_tid].trait_list[flag4] = true;
	else
		flag4 = -1;

	ACS_NamedExecuteWithResult("DnD Monster Trait Give CS", flag1, flag2, flag3, flag4);
	SetResultValue(0);
}

Script "DnD Monster Trait Give CS" (int flag1, int flag2, int flag3, int flag4) CLIENTSIDE {
	int m_tid = ActivatorTID() - DND_MONSTERTID_BEGIN;
	if(flag1 != -1)
		MonsterProperties[m_tid].trait_list[flag1] = true;
	if(flag2 != -1)
		MonsterProperties[m_tid].trait_list[flag2] = true;
	if(flag3 != -1)
		MonsterProperties[m_tid].trait_list[flag3] = true;
	if(flag4 != -1)
		MonsterProperties[m_tid].trait_list[flag4] = true;
	SetResultValue(0);
}

Script "DnD Monster Trait Give Single" (int tid, int flag) {
	int m_tid = tid - DND_MONSTERTID_BEGIN;
	if(flag != DND_ISBLOCKING || !CheckInventory("DnD_AntiBlockCounter")) {
		MonsterProperties[m_tid].trait_list[flag] = true;
		ACS_NamedExecuteWithResult("DnD Monster Trait Give Single CS", tid, flag);
	}
	SetResultValue(0);
}

Script "DnD Monster Trait Give Single CS" (int tid, int flag) CLIENTSIDE {
	int m_tid = tid - DND_MONSTERTID_BEGIN;
	MonsterProperties[m_tid].trait_list[flag] = true;
	SetResultValue(0);
}

Script "DnD Hit Monster Trait Check" (int flag) {
	int tracer = GetActorProperty(0, APROP_TRACERTID);
	SetResultValue(MonsterProperties[tracer - DND_MONSTERTID_BEGIN].trait_list[flag]);
}

// Checks Ankh
Script "DnD Ankh Checker" (void) {
	int pnum = PlayerNumber();
	while(PlayerInGame(pnum)) {
		if(!CheckInventory("ParsingData")) {
			// ankh check
			if
			(
				!CheckInventory("P_Invulnerable") &&
				GetActorProperty(0, APROP_HEALTH) == 1 &&
				!CheckInventory("Intervened") &&
				IsAccessoryEquipped(ActivatorTID(), DND_ACCESSORY_ANGELICANKH) && 
				CheckInventory("CanIntervene")
			)
			{
				GiveInventory("Intervention", 1);
				GiveInventory("Intervened", 1);
				TakeInventory("CanIntervene", 1);
				GiveInventory("InterventionFXSpawner", 1);
				GiveInventory("P_Invulnerable", 1);
				ACS_ExecuteAlways(921, 0, 1, INTERVENTION_DURATION);
			}
		}
		Delay(const:5);
	}
}

Script "DnD Player Levelup Check" (int tid) {
	SetActivator(tid);
	
	int pnum = PlayerNumber();
	int prevlvl = GetActorLevel(tid), exptemp;
	int currlvl;

	// -1 because initial level is 1
	// we need to check for the current up-to-date level, not previous level here!!
	while((currlvl = GetActorLevel(tid)) < MAXLEVELS && GetPlayerExp(pnum) >= LevelCurve[currlvl - 1]) {
		// don't keep checking if player suffers a terrible fate
		if(!PlayerInGame(pnum) || !IsActorAlive(tid))
			Terminate;

		exptemp = GetPlayerExp(pnum) - LevelCurve[currlvl - 1];
		if(!((currlvl + 1) % 5)) { // multiples of 5 give perk
			GiveActorInventory(tid, "PerkPoint", 1);
			UpdateActivity(pnum, DND_ACTIVITY_PERKPOINT, 1, 0);
			GiveActorInventory(tid, "PerkedUp", 1);
			ACS_NamedExecuteAlways("DnD Levelup Log", 0, 1);
		}

		GiveActorInventory(tid, "Level", 1);
		SetPlayerExp(pnum, exptemp);
		GiveActorInventory(tid, "AttributePoint", ATTRIB_PER_LEVEL);
		UpdateActivity(pnum, DND_ACTIVITY_ATTRIBUTEPOINT, ATTRIB_PER_LEVEL, 0);
		
		++PlayerInformationInLevel[PLAYERLEVELINFO_LEVEL];
		UpdateActivity(pnum, DND_ACTIVITY_LEVEL, 1, 0);

		Delay(const:1);
	}

	currlvl = GetActorLevel(tid) - prevlvl;

	if(currlvl) {
		LocalAmbientSound("RPG/LevelUp", 127);
		GiveActorInventory(tid, "LevelUpEffectSpawner", 1);
		GiveActorInventory(tid, "LeveledUp", 1);
		ACS_NamedExecuteAlways("DnD Levelup Log", 0);
		if(GetActorLevel(tid) - 1 == PlayerInformationInLevel[PLAYERLEVELINFO_MAXLEVEL])
			PlayerInformationInLevel[PLAYERLEVELINFO_MAXLEVEL] = GetActorLevel(tid);
			
		// sync level cap exp
		CalculatePlayerExpRatio(tid);
		// heal on level up flag is on
		if(GetCVar("dnd_healonlevelup"))
			ACS_NamedExecuteAlways("DnD Health Pickup", 0, 100, 0);
		
		currlvl = GetActorLevel(tid);
		// player just leveled and got their perks? check if so
		bool newPerk = false;
		for(int i = DND_CLASSPERK_1; !newPerk && i < DND_CLASSPERK_LAST; ++i)
			newPerk = prevlvl < i * DND_PERK_REGULARTHRESHOLD && currlvl <= i + DND_PERK_REGULARTHRESHOLD;

		if(newPerk) {
			HandleClassPerks(tid);
			
			// this is done as new perks might increase some damage factors
			ForcePlayerDamageCaching(pnum);
			
			// make some announcement the player has a new perk
			ACS_NamedExecuteAlways("DnD Announcer", 0, DND_ANNOUNCER_NEWCLASSPERK);
		}
		else
			ACS_NamedExecuteAlways("DnD Announcer", 0, DND_ANNOUNCER_ATTRIBPOINT);
	}
	
	UpdateActivity(pnum, DND_ACTIVITY_EXP, GetPlayerExp(pnum), 0);
}

// Weapon tip display
Script 977 (int type, int itemnum) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
	    Terminate;
	if(!type && !CheckInventory("ParsingData")) { // weapon tip
		str text = GetWeaponTipText(itemnum);
		int len = StrLen(StrParam(l:text));
		
		LocalAmbientSound("Weapon/Popup", 127);
		SetHudSize(640, 480, 1);
		
		int midcount = 1 + len / 150;
		int i = 0;

		int hud_pos = (GetHudRight(640) << 16) - QSTBOX_XF / 2 + 0.4;
		SetFont("MSGBOXT");
		HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVEID, CR_UNTRANSLATED, hud_pos, 48.1, 4.0, 1.0, 1.0);

		for(i = 0; i < midcount; ++i) {
			SetFont("MSGBOXM");
			HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVEID + 1 + i, CR_UNTRANSLATED, hud_pos, 118.1 + i * TIPBOX_MIDLEN, 4.0, 1.0, 1.0);
		}

		SetFont("MSGBOXB");
		HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVEID + 2 + i, CR_UNTRANSLATED, hud_pos, 118.1 + i * TIPBOX_MIDLEN, 4.0, 1.0, 1.0);

		SetFont(Weapons_Data[itemnum].icon);
		HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVEICO, CR_UNTRANSLATED, hud_pos + 16.0, 64.0, 4.0, 1.0, 1.0);
		SetFont("OBJFONT");
		HudMessage(d:GetGameSlotOfWeapon(itemnum); HUDMSG_FADEINOUT, SURVIVETOPTEXTID, CR_GOLD, hud_pos - 99.0, 70.0, 4.0, 1.0, 1.0);

		hud_pos = (GetHudRight(960) << 16) - 3 * QSTBOX_XF / 2 + 42.1;
		SetHudSize(960, 600, 1);
		SetHudClipRect(hud_pos >> 16, 96, 320, 128 + len, 320);
		HudMessage(l:text; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 104.1, 4.0, 1.0, 1.0);
		SetHudClipRect(0, 0, 0, 0);
	}
}

// Checking for Bonuses
Script "DnD Bonus Detect" OPEN {
	int KillBonus, ItemBonus, SecretBonus, BonusBonus;
	int curkills, curitems, cursecrets, bonusval;
	
	// this construct is necessary so maps that don't have any monster besides custom monsters dont act up... I've seen things, alright? I SAW MONSTER COUNT == -2 in this fucking loop, dont test me!
	do {
		Delay(const:TICRATE);
	} while (isSoftorHardcore() && PlayersNotReadyForHardcore());
	Delay(const:17 * (DND_MAX_MONSTERDELAY + 2));

	while(true) {
		if(!GetCVar("dnd_disablelevelbonus")) {
			curkills = GetLevelInfo(LEVELINFO_KILLED_MONSTERS);
			curitems = GetLevelInfo(LEVELINFO_FOUND_ITEMS);
			cursecrets = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
			
			if(GetLevelInfo(LEVELINFO_TOTAL_MONSTERS)) {
				if(!KillBonus && curkills >= GetLevelInfo(LEVELINFO_TOTAL_MONSTERS)) {
					DistributeBonus(BONUS_KILL);
					KillBonus = 1;
				}
			}
			else
				KillBonus = 2; // means there were no monsters at all

			if(GetLevelInfo(LEVELINFO_TOTAL_ITEMS)) {
				if(!ItemBonus && curitems >= GetLevelInfo(LEVELINFO_TOTAL_ITEMS)) {
					DistributeBonus(BONUS_ITEM);
					ItemBonus = 1;
				}
			}
			else
				ItemBonus = 2; // means there were no items at all
			
			if(GetLevelInfo(LEVELINFO_TOTAL_SECRETS)) { // if there are some secrets
				if(!SecretBonus && cursecrets >= GetLevelInfo(LEVELINFO_TOTAL_SECRETS)) {
					DistributeBonus(BONUS_SECRET);
					SecretBonus = 1;	
				}
			}
			else
				SecretBonus = 2;
			
			// if there was at least some bonus involved!
			if(KillBonus && ItemBonus && SecretBonus && !BonusBonus && (KillBonus + ItemBonus + SecretBonus != 6)) {
				Delay(4);
				DistributeBonus(BONUS_BONUS);
				BonusBonus = 1;
			}
		}
		Delay(const:17);
	}
}

Script "DnD Bonus Message State" (int bonustype) CLIENTSIDE {
	for(int i = 0; i < DND_BONUS_SCREENTIME; ++i)
		Delay(const:35);
	DnD_StateChecker[bonustype + 1] = 0;
};

Script "DnD Bonus Message Show" (int bonustype) CLIENTSIDE {
	// add 1 to skip playerjoin state
	ACS_NamedExecuteAlways("DnD Bonus Message State", 0, bonustype);
	Delay(bonustype + 1);
	DnD_StateChecker[bonustype + 1] = 1;
	int y = DnD_BonusMessageY(bonustype);
	ShowBonusMessage(bonustype, y);
}

Script "DnD Monster Scanner Picker" (void) {
	int this = ActivatorTID();
	while(isActorAlive(this)) {
		if(CheckActorInventory(this, "ShowingMenu")) {
			Delay(const:3);
			continue;
		}

		SetActivatorToTarget(this);
		
		int montid = ActivatorTID();
		int m_id = 0;
		int healthbarcolor = 0;
		
		if(!montid || montid == this || CheckInventory("EnemyInDisguise")) {
			// player has no targets
			SetActivator(this);
			
			// if off cd or monster is dead, remove its data, we won't redraw it
			if(!CheckInventory("TargetPickCooldown")) {
				SetInventory("TargetMaximumHealth", 0);
				SetInventory("TargetCurrentHealth", 0);
				SetInventory("TargetHealthBarColor", 0);
				SetInventory("TargetLevel", 0);
				SetInventory("TargetIsWhat", 0);
				SetInventory("TargetIsElite", 0);
				SetInventory("TargetFortify", 0);
				SetInventory("TargetTID", 0);
			}
			else {
				montid = CheckActorInventory(this, "TargetTID");
				SetActivator(montid);
			}
		}
		else {
			if(!CheckInventory("EnemyInDisguise") && (CheckActorProperty(0, APROP_Friendly, 0) || CheckInventory("FriendlyInDisguise")))
				healthbarcolor = 1;
			else if(CheckActorProperty(0, APROP_Friendly, 1) || CheckInventory("EnemyInDisguise"))
				healthbarcolor = 0;
			
			// manipulate player stuff now
			SetActivator(this);
			
			if(isActorAlive(montid)) {
				// this part retrieves data from server
				// if not a pet
				bool pet_state = IsPet(montid);
				if(!pet_state) {
					// this part uses the inventory method to avoid having to constantly sync variables between clients
					m_id = montid - DND_MONSTERTID_BEGIN;
					SetInventory("TargetMaximumHealth", MonsterProperties[m_id].maxhp);
					SetInventory("TargetLevel", MonsterProperties[m_id].level);
					SetInventory("TargetIsWhat", MonsterProperties[m_id].id);
					SetInventory("TargetIsElite", MonsterProperties[m_id].isElite);
					SetInventory("TargetFortify", CheckActorInventory(montid, "MonsterFortifyCount"));
				}
				else {
					// this part uses the inventory method to avoid having to constantly sync variables between clients
					m_id = montid - DND_PETTID_BEGIN;
					SetInventory("TargetMaximumHealth", PetMonsterProperties[m_id].maxhp);
					SetInventory("TargetLevel", PetMonsterProperties[m_id].level);
					SetInventory("TargetIsWhat", PetMonsterProperties[m_id].id);
					SetInventory("TargetIsElite", PetMonsterProperties[m_id].isElite);
					SetInventory("TargetFortify", CheckActorInventory(montid, "MonsterFortifyCount"));
				}

				SetInventory("TargetTID", montid);
				SetInventory("TargetMonId", m_id);
				SetInventory("TargetHealthBarColor", healthbarcolor);
				SetInventory("TargetCurrentHealth", GetActorProperty (montid, APROP_Health));
			}
			else {
				SetInventory("TargetMaximumHealth", 0);
				SetInventory("TargetCurrentHealth", 0);
				SetInventory("TargetHealthBarColor", 0);
				SetInventory("TargetLevel", 0);
				SetInventory("TargetIsWhat", 0);
				SetInventory("TargetIsElite", 0);
				SetInventory("TargetFortify", 0);
				SetInventory("TargetTID", 0);
			}
			
			// fixes initialization bug
			SetActivator(this);
		}
		Delay(const:2);
	}
	SetResultValue(0);
}

// takes flag segments
Script "DnD Sync Monster Trait CS" (int m_id, int v1, int v2, int v3) CLIENTSIDE {
	// get all of the flagsets now
	int i;
	if(v1) {
		for(i = 0; i < 32; ++i)
			MonsterProperties[m_id].trait_list[i] = IsSet(v1, i);
		MonsterProperties[m_id].hasTrait = true;
	}
	else {
		for(i = 0; i < 32; ++i)
			MonsterProperties[m_id].trait_list[i] = false;
	}
	
	if(v2) {
		for(i = 32; i < 64; ++i)
			MonsterProperties[m_id].trait_list[i] = IsSet(v2, i - 32);
		MonsterProperties[m_id].hasTrait = true;
	}
	else {
		for(i = 32; i < 64; ++i)
			MonsterProperties[m_id].trait_list[i] = false;
	}

	if(v3) {
		for(i = 64; i < MAX_MONSTER_TRAITS_STORED; ++i)
			MonsterProperties[m_id].trait_list[i] = IsSet(v3, i - 64);
		MonsterProperties[m_id].hasTrait = true;
	}
	else {
		for(i = 64; i < MAX_MONSTER_TRAITS_STORED; ++i)
			MonsterProperties[m_id].trait_list[i] = false;
	}
	
	SetResultValue(0);
}

Script "DnD Sync Pet Monster Trait CS" (int id, int v1, int v2, int v3) CLIENTSIDE {
	int m_id = id - DND_PETTID_BEGIN;
	
	// get all of the flagsets now
	int i;
	if(v1) {
		for(i = 0; i < 32; ++i)
			PetMonsterProperties[m_id].trait_list[i] = IsSet(v1, i);
		PetMonsterProperties[m_id].hasTrait = true;
	}
	
	if(v2) {
		for(i = 32; i < 64; ++i)
			PetMonsterProperties[m_id].trait_list[i] = IsSet(v2, i - 32);
		PetMonsterProperties[m_id].hasTrait = true;
	}

	if(v3) {
		for(i = 64; i < MAX_MONSTER_TRAITS_STORED; ++i)
			PetMonsterProperties[m_id].trait_list[i] = IsSet(v3, i - 64);
		PetMonsterProperties[m_id].hasTrait = true;
	}
	
	SetResultValue(0);
}

Script "DnD Constant Unique Boss Sync" (int tid) {
	SetActivator(-1);
	int lasthp = GetActorProperty(tid, APROP_HEALTH);
	int lastfort = CheckActorInventory(tid, "MonsterFortifyCount");
	bool hasFort = !!lastFort;
	bool awakened = false;
	
	// force sync on initial tic
	ACS_NamedExecuteWithResult("DnD Unique Boss Property Sync", tid, lasthp, BOSSDATA_HP, 0);
	ACS_NamedExecuteWithResult("DnD Unique Boss Property Sync", tid, lastfort, BOSSDATA_FORT, 0);

	while(isActorAlive(tid)) {
		Delay(const:1);
		
		int hp = GetActorProperty(tid, APROP_HEALTH);
		if(hp != lasthp) {
			ACS_NamedExecuteWithResult("DnD Unique Boss Property Sync", tid, hp, BOSSDATA_HP, lasthp - hp);
			lasthp = hp;
		}
		
		hp = hasFort * CheckActorInventory(tid, "MonsterFortifyCount");
		if(hp != lastfort) {
			ACS_NamedExecuteWithResult("DnD Unique Boss Property Sync", tid, hp, BOSSDATA_FORT, lastfort - hp);
			lastfort = hp;
		}
		
		if(!awakened && GetActorProperty(tid, APROP_TARGETTID)) {
			ACS_NamedExecuteWithResult("DnD Unique Boss Property Sync", 0, 1, BOSSDATA_AWAKENED);
			ACS_NamedExecuteWithResult("DnD Unique Boss Bar Draw SpecOnly", tid);
			awakened = true;
		}
	}

	SetResultValue(0);
}

Script "DnD Unique Boss Property Sync" (int tid, int val, int prop, int diff) CLIENTSIDE {
	// if non-zero that means this isn't an init step, this is an update request so we took damage
	if(prop == BOSSDATA_HP && DungeonBossData[prop]) {
		DungeonBossData[BOSSDATA_DMGTAKEN] = diff;
		DungeonBossData[BOSSDATA_DMGTRIGGER] = 1;
	}
	DungeonBossData[prop] = val;
	SetResultValue(0);
}

Script "DnD Monster Scanner" (void) CLIENTSIDE {
	int mmaxhp;
	
	Delay(const:TICRATE);
	
	int temp = DungeonBossData[BOSSDATA_TID];
	int m_id = temp - DND_MONSTERTID_BEGIN;
	bool hadTarget = false;
	bool drawnOverlay = false;
	
	while(isAlive()) {
		// disable during intermission
		if(CheckInventory("DnD_IntermissionState"))
			break;
			
		// dont draw old style bar for unique bosses
		mmaxhp = CheckInventory("TargetMaximumHealth");
		m_id = CheckInventory("TargetIsWhat");
		if(mmaxhp && !isUniqueBossMonster_Id(m_id) && GetCVar("dnd_monsterbars")) {
			hadTarget = true;
			DrawMonsterHPBar(
				CheckInventory("TargetTID"),
				mmaxhp,
				CheckInventory("TargetCurrentHealth"),
				CheckInventory("TargetLevel"),
				CheckInventory("TargetIsWhat"),
				CheckInventory("TargetMonId"),
				CheckInventory("TargetFortify")
			);
		}
		else if(DungeonBossData[BOSSDATA_TID] && DungeonBossData[BOSSDATA_AWAKENED]) {
			temp = DungeonBossData[BOSSDATA_TID];
			
			if(hadTarget) {
				hadTarget = false;
				DeleteTextRange(MONSTER_BARFILLID, MONSTER_BARFILLOVERLAY);
			}
			
			if(!drawnOverlay) {
				// this will draw it for everyone, no need to check spectators here but the overall boss bar needs to be drawn specifically for spectators
				drawnOverlay = true;
				//BossBarDrawnForPlayer[ConsolePlayerNumber()] = true;
				ACS_NamedExecuteWithResult("DnD Boss HP FX Overlay", temp);
			}
		
			m_id = temp - DND_MONSTERTID_BEGIN;
			// draw permanently as soon as the boss monster wakes only replaced by looking at another monster (that's why it's below)
			DrawBigBossHPBar(
				temp,
				MonsterProperties[m_id].maxhp,
				DungeonBossData[BOSSDATA_HP],
				MonsterProperties[m_id].level,
				MonsterProperties[m_id].id,
				m_id,
				DungeonBossData[BOSSDATA_FORT]
			);
		}
		else if(DungeonBossData[BOSSDATA_AWAKENED] && !DungeonBossData[BOSSDATA_TID])
			drawnOverlay = false;

		Delay(const:2);
	}
}

// This is mostly similar to zdoom source with some changes (I believe)
Script "DnD Monster Kill Ice Chunks" (int r, int h) CLIENTSIDE {
	int numChunks = Max(5, (r * h) / 256);
	int i;
	int xo, yo, zo;
	for(i = Max(10, numChunks + Random(-numChunks / 4, numChunks / 4)); i >= 0; --i) {
		xo = GetActorX(0) + r * random(-1.0, 1.0);
		yo = GetActorY(0) + r * random(-1.0, 1.0);
		zo = GetActorZ(0) + h * random(0, 1.0);

		SpawnForced("IceChunkCS", xo, yo, zo, DND_ICECHUNK_TID);
		SetActorVelocity(DND_ICECHUNK_TID, random(-1.875, 1.875), random(-1.875, 1.875), random(-1.25, 1.25), 0, 0);
		Thing_ChangeTID(DND_ICECHUNK_TID, 0);
	}
	
	// spawn ice smoke
	for(i = 0; i < 5; ++i) {
		xo = GetActorX(0) + r * random(-0.5, 0.5);
		yo = GetActorY(0) + r * random(-0.5, 0.5);
		zo = GetActorZ(0) + h * random(0.25, 0.875);
		SpawnForced("ExplosionFX10", xo, yo, zo, DND_ICECHUNK_TID);
	}

	SetResultValue(0);
}

// Calculate chance of item drop, drop if needed (out of 100)
// Note: not sure where this is called from atm
Script "DnD Item Dropchance" (int basechance) {
	SetActivatorToTarget(0);
	basechance <<= 16;
	basechance /= 100;
	SetResultValue(RunDefaultDropChance(ActivatorTID() - P_TIDSTART, basechance));
}

// Some Generic Chat Log Script
Script "DnD Message Logger" (int type, int id, int id_is_special) CLIENTSIDE {
	if(PlayerNumber() != ConsolePlayerNumber()) Terminate;
	if(!type)
		Log(s:"\cc", l:"DND_PICKUP_WEAPON", s:": \c[Y5]", s:TemporaryWeaponData[id - TEMPBEGIN][TEMPWEP_TAG], s:" - 9\c-");
	else if(type == 1) {
		id = MapClassicWeaponToTableID(id);
		Log(s:"\cc", l:"DND_PICKUP_WEAPON", s:": \c[Y5]", l:GetWeaponTag(id), s:" - ", d:GetGameSlotOfWeapon(id), s:"\c-");
	}
    else if(type == 2) {
		if(id_is_special)
			Log(s:"\cc", l:"DND_PICKUP_RESEARCH", s:": \c[Y5]", l:"DND_PICKUP_DISCOVERED", s:" ", l:GetResearchLabel(id >> 16), s:"!");
		else
			Log(s:"\cc", l:"DND_PICKUP_RESEARCH", s:": \c[Y5]", l:"DND_PICKUP_DISCOVERED", s:" ", l:GetResearchLabel(id), s:"!");
	}
	else if(type == 3)
		HandleSharedItemPickupMessage(id);
	else if(type == 4)
		Log(s:"\cc", l:"DND_PICKUP_HEALTH", s:": \c[Y5]", l:"DND_PICKUP_DEMONESSENCE");
	else
		Log(s:ChestKeyText[id]);
}

// Pickup check for the temporary weapons
Script 986 (int wepnum, int type) {
	int who = ActivatorTID();
	if(type) {
		SetActivatorToTarget(0);
		who = ActivatorTID();
	}
	wepnum -= TEMPBEGIN;
	int t = 0;
	if(!CheckActorInventory(who, "DnD_NoTempPickup")) {
		for(int i = 0; i < MAXTEMPWEPS; ++i) {
			if(i == wepnum) {   
				// do we have max ammo on this weapon
				if(CheckActorInventory(who, TemporaryWeaponData[i][TEMPWEP_AMMO]) == GetAmmoCapacity(TemporaryWeaponData[i][TEMPWEP_AMMO]))
				++t;
			}
			else if(CheckActorInventory(who, TemporaryWeaponData[i][TEMPWEP_NAME])) { // do I have any temp weapon
				if(!CheckActorInventory(who, TemporaryWeaponData[i][TEMPWEP_AMMO])) // hack to prevent a desync problem
					TakeActorInventory(who, TemporaryWeaponData[i][TEMPWEP_NAME], 1);
				else
					++t;
			}
		}
	}
	else
		t = 1;
	SetResultValue(!t);
}

Script "DnD On Respawn" RESPAWN {
	int pnum = PlayerNumber();
	Thing_ChangeTID(0, P_TIDSTART + pnum);
	TakeInventory("PowerReflection", 1);
	TakeInventory("DnD_PDead", 1);

	ClearLingeringBuffs(pnum);

	SetInventory("PlayerIsLeeching", 0);
	RestoreRPGStat(RES_ACCURACY | RES_EXPLOSIONRADIUS);
	ACS_NamedExecuteAlways("DnD Health Pickup", 0, 100, 4); // full heal
	
	// run the monster scanner script again on respawn
	ACS_NamedExecuteWithResult("DnD Monster Scanner Picker");
	ACS_NamedExecuteAlways("DnD Monster Scanner", 0);
	
	ACS_NamedExecuteAlways("DnD SBAR", 0);

	DoPreClassAdjustments();
	
	// if game mode is coop, we don't want any sort of reset on death here! make sure it's not coop
	/*if(GetCVar("Survival")) {
		if(CheckInventory("CurrentLives"))
			TakeInventory("CurrentLives", 1);
		else {
			Reset_RPGInfo(RESET_LEVEL | RESET_CREDIT | RESET_STATS | RESET_PERKS);
			StatListOpened[PlayerNumber()] = 0;
			ResetWeaponMods(PlayerNumber());
			ResetPlayerBonuses(PlayerNumber());
		}
	}*/

	// for properly setting up taltos translucency when spawn protection is on
	while(PlayerIsInvulnerable())
		Delay(const:5);

	// in case it wasn't complete due to a bug
	SetupComplete(SETUP_STATE1, SETUP_PLAYERINFO_MINMAXLEVELS);

	SetActorProperty(0, APROP_HEALTH, GetSpawnHealth());
		
	if(CheckInventory("TaltosUp"))
		GiveInventory("TaltosEffect", 1);
		
	ACS_NamedExecuteAlways("DnD Punisher Perk50 Display", 0);
	ACS_NamedExecuteWithResult("DnD Can Fire Weapon", 0);
	ACS_NamedExecuteWithResult("DnD Player Weapon Discard Sync", pnum, PlayerActivities[pnum].discarded_weapons);

	ConditionalCalculateUnity(pnum);
}

Script 988 (int wepslot, int type) {
	int res = 0;
	if(!type) {
		if(CheckSlotWeapon(wepslot))
			res = 1;
	}
	else if(type == 1) {
		if(GetCVar("sv_weaponstay"))
			res = 1;
	}
	SetResultValue(res);
}

// Clear upon leaving
Script "DnD On Disconnect" (int pnum) DISCONNECT {
	//Just to make sure a rare lvl 1 char load bug doesn't happen
	//Log(s:"player left ", d:pnum);
	PlayerDatabaseState[pnum][PLAYER_TRANSFERSTATE] = false;

	ACS_NamedExecuteAlways("DnD Class Select Cleanup", 0);
	// if someone quit during countdown just remove this
	HudMessage(s:""; HUDMSG_PLAIN, DND_HARDCORE_SCREENID, CR_RED, 320.0, 240.0, 1);
	StatListOpened[pnum] = 0;
	PlayerCanLoad[pnum] = 0;
	BreakTradesBetween(pnum);
	
	RemoveAllBuffs(pnum);
	
	// if player was in middle of saving, don't accidently interfere if player leaves early
	// save accumulated stats when player leaves
	// things saved are in DnD_Activity.h
	HandlePlayerDataSave(pnum, true);

	// this moved here so the above function has prio, not sure if it has any other implications but its good for it to be here regardless
	PlayerDatabaseState[pnum][PLAYER_SAVESTATE] = false;
	CheckEOL(true);
	
	//ACS_NamedExecuteWithResult("DnD Save Player Activities", pnum, true);
	PlayerDied[pnum] = 0;
	
	ACS_NamedExecuteWithResult("DnD Unique Boss Bar Draw SpecOnly", DungeonBossData[BOSSDATA_TID]);
	ACS_NamedExecuteAlways("DnD Menu Icon Force Remove", 0, pnum + DND_MENUFLOATYICON_TID);
}

// End of level checks
Script "DnD On Unloading" UNLOADING {
	int tid;
	SetupComplete(SETUP_STATE1, SETUP_MAPCHANGED);
	SetupComplete(SETUP_STATE1, SETUP_PLAYERDATAFINISHED);
	SetupUndo(SETUP_STATE1, SETUP_CLEANINGMONSTERTIDS);
	//Field items are global, but new items simply replace old ones no questions asked, so no need to clear this.
	//ResetFieldInventory();
	BreakAllTrades();

	if(isSoftOrHardcore() && !ScoreBoardData[DND_SCBRD_SAVESUCCEEDED]) {
		Log(s:"Saving data on unloading...");
		SaveAllPlayerData();
	}
	
	DungeonBossData[BOSSDATA_TID] = 0;
	ACS_NamedExecuteWithResult("DnD Register Unique Boss", 0);
}

// Enter level checks
Script "DnD Player Setup" ENTER {
	int pnum = PlayerNumber();
	Thing_ChangeTID(0, P_TIDSTART + pnum);

	if(StatListOpened[pnum])
		ClearMenuLeftovers(pnum);

	// if its sp and we dont have DnD_Character non-zero, bring up class menu and freeze us
	if(GameType() == GAME_SINGLE_PLAYER && !CheckInventory("DnD_Character")) {
		// freeze
		SetPlayerProperty(1, 1, PROP_FROZEN);
		
		ACS_NamedExecuteAlways("DnD Class Select", 0, 1);
		
		while(!CheckInventory("DnD_Character"))
			Delay(const:5);
			
		SetPlayerProperty(1, 0, PROP_FROZEN);
	}

	ACS_NamedExecuteAlways("DnD Class Select Cleanup", 0);
	
	SetInventory("SphereMade", 0);
	SetInventory("OrbUseType", 0);
	SetInventory("OrbResult", 0);
	// reset anything related to kill sprees on entering a new map
	SetInventory("SpreeXP", 0);
	SetInventory("DnD_SpreeTimer", 0);
	SetInventory("DnD_SpreeCountdownRunning", 0);
	SetInventory("DnD_MultikillCounter", 0);
	TakeInventory("EShieldCharging", 1);
	
	ClearLingeringBuffs(pnum);
	
	// statistics reset
	SetInventory("DnD_Kills", 0);
	ResetStatistics();
	
	// now everyone has this, no need to buy
	GiveInventory("Ability_MonsterInfo", 1);
	CleanPetStuff();
	SetInventory("DnD_MasterHealerQuest_HealAmount", 0); // reset this upon map restart
	int curlvl, i = 0;
	int temp = 0;
	bool wait_other_players = false;
	str curmap;
	SetInventory("PlayersNotReady", PlayerCount());
	SetInventory("PlayerIsLoggedIn", PlayerIsLoggedIn(pnum)); //Only used to let player know if he's logged in at start (clientside doesn't have this function).
	GiveInventory("ParsingData", 1);
	ResetAllSpellCooldowns(); // reset all leftover cooldowns
	
	// scanner runner
	ACS_NamedExecuteWithResult("DnD Monster Scanner Picker");
	ACS_NamedExecuteAlways("DnD Monster Scanner", 0);
	ACS_NamedExecuteAlways("DnD SBAR", 0);
	
	// begin hardcore countdown
	if(isSoftorHardcore() && (GetCVar("dnd_mode") >= DND_MODE_SOFTCORE)) {
		GiveInventory("P_Frozen", 1);
		GiveInventory("DontAttack", 1);
		
		while(GetGameModeState() == GAMESTATE_COUNTDOWN)
			Delay(const:17);

		// run the gui after game countdown
		RunClassLoadScripts();

		SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
		SetPlayerProperty(0, 2, PROP_INVULNERABILITY);

		PlayerDatabaseState[pnum][PLAYER_SAVESTATE] = true;
		// display countdown timer
		if (!PlayerLoaded[pnum]) {
			PlayerCanLoad[pnum] = 1;
			SetInventory("CanLoad", 1);
			
			// this is so the previous reset between maps for unlogged players is retained in hardcore
			if(isHardcore()) {
				ResetPlayerItems(pnum);
				// the above reset actual items of player, the below resets variables used to denote inventories and such
				ResetPlayerInfo(pnum);
			}
		}
		else {
			PlayerCanLoad[pnum] = 0; //it's in else part, because loop might end early otherwise.
			//UpdateActivity(pnum, DND_ACTIVITY_EXP, GetPlayerExp(pnum), 0);
		}

		if(PlayerIsLoggedIn(pnum))
			ACS_NamedExecuteWithResult("DnD Character Data Display Store", pnum);
		
		// 0 means they are ready
		int players_not_ready = PlayersNotReadyForHardcore();
		SetInventory("DnD_PlayersNotReady_Sync", players_not_ready);
		i = 0;
		temp = Clamp_Between(GetCVar("dnd_loadtime"), DND_HARDCORE_LOADTIME, 100) << 1;
		while(players_not_ready && i < temp && PlayerInGame(pnum)) {
			//Update logged in status to client as needed by hardcode timer.
			if (CheckInventory("PlayerIsLoggedIn") != PlayerIsLoggedIn(pnum)) {
				SetInventory("PlayerIsLoggedIn", PlayerIsLoggedIn(pnum));
				ACS_NamedExecuteWithResult("DnD Character Data Display Store", pnum);
			}
			// we loaded, reduce on wait time
			if(!CheckInventory("CanLoad")) {
				PlayerCanLoad[pnum] = 0;
				// message the players to wait for an amount of players to ready up (also update not ready count)
				players_not_ready = PlayersNotReadyForHardcore();
				SetInventory("DnD_PlayersNotReady_Sync", players_not_ready);
				//if (players_not_ready > 0) //This is actually possible, even here!
				//	ACS_NamedExecuteAlways("DND Wait For Other Players Message", 0, players_not_ready);
			}
			++i;
			if ((i == temp) && PlayerIsLoggedIn(pnum) && CheckInventory("CanLoad")) {
				if (ACS_NamedExecuteWithResult("DnD Load Character Check", pnum, 0) == 11) //DND_CHARLOADED
					ACS_ExecuteAlways(1001,0,0);
				else if (ACS_NamedExecuteWithResult("DnD Create Character Check", pnum, 0) == 1) //DND_LOGIN_CREATECHAROK
					ACS_ExecuteAlways(1003,0,0);
			}
			Delay(const:TICRATE / 2);
		}
	}
	
	if(!PlayerInGame(pnum)) {
		PlayerCanLoad[pnum] = 0;
		Terminate;
	}
	SetInventory("DnD_PlayersNotReady_Sync", 0);
	SetInventory("PlayersNotReady", 0);
	SetInventory("DnD_SelectedCharmBox", 0); // class menu uses this now
	SetInventory("DnD_SelectedInventoryBox", 0); // also this
	
	++DnD_StateChecker[DND_STATECHECK_PLAYERJOIN];
	
	// Checks if we should set the lives to the inventory or not (also includes one time execute things)
	// when player joins for the first time - when loading char, this section gets skipped
	if(CheckInventory("SetMyLives")) {
		// can only reflect once per map
		SetInventory("ReflectCount", 0);
		SetInventory("Intervened", 0);
		SetInventory("CanIntervene", 1);
		TakeInventory("SetMyLives", 1);
		SetInventory("ShowingMenu", 0);
		SetInventory("ShowingPrompt", 0);
		Reset_RPGInfo(RESET_LEVEL | RESET_CREDIT | RESET_STATS | RESET_PERKS);
		StatListOpened[pnum] = 0;
		GiveInventory(" Fists ", 1);
		GiveInventory(" Pistol ", 1);
		if(GetCVar("dnd_allresearchesfound"))
			GiveAndDoAllResearch();
		ACS_NamedExecuteAlways("DND Menu Cleanup", 0, pnum);
	}
	
	while(pinfo_pending_reset)
		Delay(const:10);
	
	if(PlayerInGame(pnum)) {
		curlvl = GetLevel();
		PlayerInformationInLevel[PLAYERLEVELINFO_LEVEL] += curlvl;
		PlayerInformationInLevel[PLAYERLEVELINFO_LEVELATSTART] += curlvl;
		++PlayerInformationInLevel[PLAYERLEVELINFO_COUNTATSTART];
		if(PlayerInformationInLevel[PLAYERLEVELINFO_MAXLEVEL] < curlvl)
			PlayerInformationInLevel[PLAYERLEVELINFO_MAXLEVEL] = curlvl;
		if(PlayerInformationInLevel[PLAYERLEVELINFO_MINLEVEL] > curlvl)
			PlayerInformationInLevel[PLAYERLEVELINFO_MINLEVEL] = curlvl;
	}
	
	ClearQuestCheckers();
	
	PostPlayerLoadRoutine(pnum);

	SetupUndo(SETUP_STATE1, SETUP_PLAYERDATAFINISHED);

	if(isSoftorHardcore()) {
		ACS_NamedExecuteAlways("DND Hardcore Monster Message", 0);
		// wait for monsters to appear
		Delay(17 * (DND_MAX_MONSTERDELAY + 2));
	}
	
	UnfreezePlayer();
	curlvl = GetCurrentWeaponID();
	ACS_NamedExecuteWithResult("DnD Weapon Damage Cache", curlvl);
	ACS_NamedExecuteAlways("DnD Weapon Input Handler", 0, curlvl);
	ACS_NamedExecuteWithResult("DnD Can Fire Weapon", 0);
	
	// if map changed, reset accessory stuff
	if(IsSetupComplete(SETUP_STATE1, SETUP_MAPCHANGED)) {
		SetInventory("ReflectCount", 0);
		SetInventory("Intervened", 0);
		SetInventory("P_Invulnerable", 0);
	}
	TakeInventory("PowerReflection", 1);
	// order of the above reset is important
	if(!GetCVar("sv_maxlives"))
		SetInventory("CurrentLives", 0);
	else
		SetInventory("CurrentLives", GetCvar("sv_maxlives") - 1);
	
	RestoreRPGStat(RES_ACCURACY | RES_EXPLOSIONRADIUS);
	
	// sync item mods
	SyncPlayerItemMods(pnum);
	
	// a little hack to prevent ankh going off when finishing maps with 1 hp
	if(GetActorProperty(0, APROP_HEALTH) == 1 && CheckInventory("CanIntervene"))
		HealThing(1);
	
	// Give Temporal Sphere
	if(CheckInventory("Ability_Temporal") && !CheckInventory("TemporalSphere"))
        GiveInventory("TemporalSphere", 1);
	
	if(CheckInventory("QuestCompletionToken"))
		ACS_NamedExecuteAlways("DND Quest Complete", 0);
		
	// for properly setting up taltos translucency when spawn protection is on
	while(GetActorProperty(0, APROP_INVULNERABLE) && !CheckInventory("P_Invulnerable"))
		Delay(const:7);

	SetupComplete(SETUP_STATE1, SETUP_PLAYERINFO_MINMAXLEVELS);
		
	// this is here as a precaution for taltos effect removal in case player has decided to remove it before a map ended
	DecideAccessories();

	if(HasClassPerk_Fast("Marine", 4))
		ACS_NamedExecuteAlways("DnD Marine Perk 50 Checker", 0);
	
	if(IsAccessoryEquipped(ActivatorTID(), DND_ACCESSORY_TALTOSRING))
		GiveInventory("TaltosEffect", 1);
	
	// moved here to attempt to fix the reflect pendant issue
	// just in case
	if(DnD_StateChecker[DND_STATECHECK_PLAYERJOIN] >= PlayerCount())
		SetupUndo(SETUP_STATE1, SETUP_MAPCHANGED);
	
	TakeInventory("QuestWasPicked", 1); // helps sync clientside variable Quest_Pick_Done
	/*while(!Quest_Pick_Done)
		Delay(const:10);
		
	GiveInventory("QuestWasPicked", 1);
	if(active_quest_id != -1) {
		SetInventory("ActiveQuestID", active_quest_id + 1);
		ACS_NamedExecuteAlways("DND Announcer", 0, DND_ANNOUNCER_QUEST, active_quest_id);
	}
	else
		SetInventory("ActiveQuestID", 0);
		
	while(CheckInventory("TipBoxOpen"))
		Delay(const:17);
	// give some time for completion thing to get through
	SetInventory("QuestCompletionToken", 0);
	*/
	if(isHardcore() && !CheckInventory("HardcoreDebuff"))
		GiveInventory("HardcoreDebuff", 1);

	SetInventory("MapDifficultyClientside", MapData[DND_MAPDATA_DIFFICULTY]);
	
	SetInventory("DnD_PTotalLevel", PlayerInformationInLevel[PLAYERLEVELINFO_LEVEL]);
	// for zombie quest to work
	TakeInventory("DnD_ShotUndead", 1);
	TakeInventory("ParsingData", 1);
	if(GetCVar("dnd_mode") <= DND_MODE_SOFTCORE)
		ACS_NamedExecuteAlways("DnD Ankh Checker", 0);

	ConditionalCalculateUnity(pnum);

	// wait till the loading phase is over fully
	while(GetGamemodeState() != GAMESTATE_INPROGRESS)
		Delay(const:HALF_TICRATE);

	ACS_NamedExecuteWithResult("DnD Player Weapon Discard Sync", pnum, PlayerActivities[pnum].discarded_weapons);

	//ACS_NamedExecuteAlways("DnD Can Fire Weapon", 0, pnum);
#ifndef SKIP_DB_SETTINGS
	if(isHardcore()) {
		curmap = StrParam(n:PRINTNAME_LEVEL);

		// only do these if these aren't lobby maps we changed to!
		if(!IsLobbyMap(curmap) && !GetCVar("dnd_ignorelootpenalty")) {
			// reset this before recalculating
			PlayerActivities[pnum].loot_penalty = 0;
			
			++PlayerActivities[pnum].vote_skips;
			Log(s:"Visit map data ", d:PlayerActivities[pnum].vote_skips);

			// check if map is visited already
			InsertMapVisited(pnum, curmap);

			if(!PlayerActivities[pnum].loot_penalty && PlayerActivities[pnum].vote_skips > DND_VOTESKIP_LIMIT) {
				PlayerActivities[pnum].loot_penalty = 1;
				Log(s:"Map voteskipped more than once! Loot is being reduced!");
			}

			if(PlayerActivities[pnum].loot_penalty)
				ACS_NamedExecuteAlways("DnD Loot Penalty Text", 0, pnum, PlayerActivities[pnum].vote_skips);
		}
	}
#endif
	TakeInventory("DnD_CountdownProtection", 1);
	TakeInventory("DnD_RemoveBoxSignal", 1);

/*#ifdef ISDEBUGBUILD
	Delay(10*TICRATE);
	Log(s:"nuclear count: ", d:test_counter);
#endif*/
}

Script "DnD Can Look Around" (void) {
	// add blind effects and manipulation of distance here
	int res = IsSetupComplete(SETUP_STATE1, SETUP_PLAYERINFO_MINMAXLEVELS);
	SetResultValue(res);
}

Script "DnD Can Wander Around" (void) {
	int res = IsSetupComplete(SETUP_STATE1, SETUP_PLAYERINFO_MINMAXLEVELS);
	SetResultValue(res);
}

Script "DnD Monster Idle" (void) {
	int tid = ActivatorTID();
	MonsterProperties[tid - DND_MONSTERTID_BEGIN].isIdle = true;
}

Script "DnD Monster Active" (void) {
	int tid = ActivatorTID();
	MonsterProperties[tid - DND_MONSTERTID_BEGIN].isIdle = false;

	if(NPC_States[DND_NPC_DARKWANDERER].offer == NPC_OFFER_SUPERDEMON && !NPC_States[DND_NPC_DARKWANDERER].aux_data && MonsterProperties[tid - DND_MONSTERTID_BEGIN].trait_list[DND_MARKOFASMODEUS]) {
		NPC_States[DND_NPC_DARKWANDERER].aux_data = 1;
		ACS_NamedExecuteAlways("DnD Dark Wanderer Challenge Track", 0);
	}
}

Script "DnD Loot Penalty Text" (int pnum, int val) CLIENTSIDE {
	if(ConsolePlayerNumber() != pnum)
		Terminate;
	if(val)
		Log(s:"\cgWARNING!\c- \ckLoot is reduced due to repeating maps or callvote changes!");
	PlayerActivities[pnum].vote_skips = val;
}

Script "DnD Force Sync Player Global Data" (void) {
	int pnum = PlayerNumber();
	SyncAllItemData(pnum, DND_SYNC_ITEMSOURCE_ITEMSUSED);
	SyncAllItemData(pnum, DND_SYNC_ITEMSOURCE_PLAYERINVENTORY);
	SyncAllItemData(pnum, DND_SYNC_ITEMSOURCE_STASH);
	SyncAllClientsideVariables(pnum);
}

// Control for ammo capacity
Script 992 (int t, int simple) {
	SetResultValue(CheckAmmoPickup(t, simple));
}

Script "DnD On Player Enter CS" ENTER CLIENTSIDE {
	int cpnum = ConsolePlayerNumber();

	if(cpnum != PlayerNumber())
		Terminate;

	int status = GetCVar("dnd_dashstatus");
	NamedRequestScriptPuke("DnD User CVAR Status Receive", status);
	
	int class_id = GetUserCVar(cpnum, "dnd_playerclass");
	
	if(GameType() != GAME_SINGLE_PLAYER)
		NamedRequestScriptPuke("DnD Set Class", class_id, cpnum);

	ResetPlayerScriptChecks();

	if(GetCVar("dnd_showmapinfo"))
		SetInventory("ShowMapInfo", 1);
		
	ACS_NamedExecuteAlways("DnD Punisher Perk50 Display", 0, true);

	NamedRequestScriptPuke("DnD Temp Ignore Toggle", cpnum, GetCVar("dnd_ignoretempweps"));
	NamedRequestScriptPuke("DND Set Pickup Filter", cpnum, GetCVar("dnd_pickup_filter"));
}

// A generic checker function
Script 994 (int type, int extra, int wantNoAmmo) {
	int res = 0;
	int temp;
	if(type == 1) {
		if(!extra) { // attack check
			if(CheckInventory("FireLeft") && CheckInventory("AkimboClipLeft"))
				res = 2;
			if(!CheckInventory("FireLeft") && CheckInventory("AkimboClipRight"))
				res = 3;
			// force reload when out of ammo
			if(!res || (!CheckInventory("AkimboClipLeft") && !CheckInventory("AkimboClipRight")))
				res = 1;
		}
		else { // reload check
			if(CheckInventory("Clip")) {
				int cap = GetAmmoCapacity("AkimboClipLeft");
				res = CheckInventory("AkimboClipLeft") < cap || CheckInventory("AkimboClipRight") < cap;
			}
		}
	}
	else if(type == 3)
		res = GetPlayerInput(-1, INPUT_BUTTONS) & BT_ALTATTACK;
	else if(type == 4)
		res = Clamp_Between(GetCVar("dnd_respawn_count"), 1, 0x7FFFFFFF);
	else if(type > 4 && type < 9) { // keep until cleanup
		if(GetCVar("dnd_monsterscale")) {
			int bonus = 0;
			if(type == 5) {
				bonus = (MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[DND_EXTRASTRONG]) ? DND_ELITE_EXTRASTRONG_BONUS : 0;
				res = (Clamp_Between(MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].level, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 1, 100));
				if(MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].isElite)
					res = FixedMul(res, 1.0 + DND_ELITE_DMGSCALE + bonus);
				res >>= 16;
			}
			else if(type == 6) {
				SetActivatorToTarget(0);
				bonus = (MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[DND_EXTRASTRONG]) ? DND_ELITE_EXTRASTRONG_BONUS : 0;
				res = (Clamp_Between(MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].level, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 1, 100));
				if(MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].isElite)
					res = FixedMul(res, 1.0 + DND_ELITE_DMGSCALE + bonus);
				res >>= 16;
			}
			else if(type == 7) {
				bonus = (MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[DND_EXTRASTRONG]) ? DND_ELITE_EXTRASTRONG_BONUS : 0;
				res = (Clamp_Between(extra, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 1, 100));
				if(MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].isElite)
					res = FixedMul(res, 1.0 + DND_ELITE_DMGSCALE + bonus);
				res >>= 16;
			}
			else if(type == 8)
				res = MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].level;
		}
	}
	else if(type == 9)
		res = GetPlayerInput(-1, INPUT_BUTTONS) & BT_RELOAD;
	else if(type == 10) { // checks shell clip size
		str tocheck = "ShellSize_8N";
		str ammotype = "Shell";
		str weptype = "SpecialAmmoMode_3";
		if(extra == 1)
			tocheck = "ShellSize_8";
		else if(extra == 2)
			tocheck = "ShellSize_10";
		else if(extra == 3)
			tocheck = "ShellSize_12";
		else if(extra == 4) {
			tocheck = "ShellSize_2";
			weptype = "SpecialAmmoMode_3X";
		}
		ammotype = GetSpecialAmmoString(CheckInventory(weptype), AMMOINFO_NAME);
		res = CheckInventory(ammotype) > CheckInventory(tocheck);
		if(wantNoAmmo) {
			// we are either holding fire when we have no ammo for early reload cancel, or we are holding reload when we have ammo, for early reload cancel
			temp = GetPlayerInput(-1, INPUT_BUTTONS);
			res &= (!CheckInventory(tocheck) && (temp & BT_ATTACK)) || (temp & BT_RELOAD);
		}
	}
    else if(type == 11) // has research?
        res = CheckResearchStatus(extra) == RES_NA;
    else if(type == 12)
        res = CheckInventory("LightningStacks");
    else if(type == 13) {
        // check riotgun mode switch possibility
        int norm = !!CheckInventory("RiotgunShell"), nitro = !!CheckInventory("NitroShell"), explo = !!CheckInventory("ExplodingShell");
        // only let switching if more than 1 is available
        res = norm || explo || nitro;
    }
	else if(type == 14)
		res = GetActorProperty(0, APROP_INVULNERABLE);
	SetResultValue(res);
}

Script "DnD Check Special Match" (int multispecial) {
	int sp = GetActorProperty(0, APROP_MASS), res = 0;
	int who = 0;
	SetActivatorToTarget(0);
	who = ActivatorTID();
	if(!multispecial)
		res = who - P_TIDSTART == sp - 1;
	else {
		// 256 means anyone can pick or see w.e
		if((sp & 0xFFFF) == 256)
			res = 1;
		else {
			res = who - P_TIDSTART == (sp & 0xFFFF) - 1;
			if(multispecial & DND_SPECIAL_RESEARCH)
				res = res && !CheckActorResearchStatus(who, sp >> 16);
		}
	}
	//printbold(d:res);
	SetResultValue(res);
}

Script "DnD Spawn Grabby" (int multispecial) {
	int sp = GetActorProperty(0, APROP_MASS), res = 0;
	int who = 0;

	int ox = GetActorX(0);
	int oy = GetActorY(0);
	int oz = GetActorZ(0);

	SetActivatorToTarget(0);
	who = ActivatorTID();
	if(!multispecial)
		res = who - P_TIDSTART == sp - 1;
	else {
		// 256 means anyone can pick or see w.e
		if((sp & 0xFFFF) == 256)
			res = 1;
		else {
			res = who - P_TIDSTART == (sp & 0xFFFF) - 1;
			if(multispecial & DND_SPECIAL_RESEARCH)
				res = res && !CheckActorResearchStatus(who, sp >> 16);
		}
	}

	if(!res)
		Terminate;

	ACS_NamedExecuteWithResult("DnD Spawn Grabby - CS", who - P_TIDSTART, ox, oy, oz);
}

Script "DnD Spawn Grabby - CS" (int pnum, int ox, int oy, int oz) CLIENTSIDE {
	if(ConsolePlayerNumber() != pnum)
		Terminate;
	SpawnForced("GrabbyHandIcon", ox, oy, oz + 32.0);
	SetResultValue(0);
}

Script "DnD Blood Rune" (void) {
	str togive = "FakeBloodPower";
	if(CheckInventory("Ability_Arcanery"))
		togive = "FakeBloodPowerBetter";
	ActivatorSound("items/bloodrun", 127);
	GiveInventory(togive, 1);
}

Script "DnD Vampirism FX CS" (int target) CLIENTSIDE {
	GiveActorInventory(target, "DarkHealFX_Spawner", 1);
}

Script "DnD Ruination Ticker" (void) {
	int count = 0;
	while(isAlive() && CheckInventory("RuinationStacks")) {
		Delay(const:RUINATION_TIC);
		++count;
		if(!(count % TICRATE) && CheckInventory("RuinationStacks") == RUINATION_MAX_STACKS)
			break;
		if(count == RUINATION_MAX_TICS) {
			TakeInventory("RuinationStacks", 1);
			count = 0;
		}
	}
}

// Backpack / Research script
Script 996 (int type, int id) {
    if(!type) {
		if (CheckInventory("BackpackCounter") < DND_MAX_BACKPACK) {
			// give additional ones for db save
			int add_backpack_amount = 1;
			if(GetCVar("dnd_firstbackpackold"))
				add_backpack_amount += 8;
			//Respect the max backpack amount
			SetInventory("BackpackCounter", Min(CheckInventory("BackpackCounter") + add_backpack_amount, DND_MAX_BACKPACK));

			SetAllAmmoCapacities(PlayerNumber());
			//ACS_ExecuteAlways(993, 0, 1); //Why did this call script 993?
		}
		int i,j;
		//Give base 1/20 of initial ammo on backpack pickup.
		for(i = 0; i < MAX_SLOTS - 1; ++i) //Except souls
			int temp = GetAmmoSlotMaxIndex(i);
			for(j = 0; j < temp && AmmoInfo[i][j].initial_capacity != -1; ++j) {
				type = GetAmmoContainerValue(i, j);
				GiveInventory(AmmoInfo[i][j].name, ((type / 5) + (type / 5) * (GetPlayerAttributeValue(PlayerNumber(), INV_AMMOGAIN_INCREASE) + (CheckInventory("Perk_Munitionist") * DND_MUNITION_GAIN))/100));
			}
	}
    else if(type == 1) {
        // give research
        GiveResearch(id, false);
    }
}

// Dash Script
Script 997 (void) NET {
	bool soundplayed = 0;
	int input;
	int angle;
	int velX;
	int velY;
	int velZ;
	bool dashed = false;
	Delay(3);
	if(CheckInventory("Ability_Dash") && !CheckInventory("DashDelay") && GetActorVelZ(0) >= 0.0 && !CheckInventory("DashDisabled") && !CheckInventory("P_Frozen") && GetActorProperty(0, APROP_HEALTH) > 0) {
		for(int i = 0; i < 4; ++i) {
			input = GetPlayerInput(-1, INPUT_BUTTONS);
			//oldInput = GetPlayerInput(-1, INPUT_OLDBUTTONS);
			if(IsButtonHeld(input, GetMovementButton(i))) {
			//if(IsButtonPressed(input, oldInput, settings[i][0])){
				angle = GetActorAngle(0) + GetMovementAngle(i);
				
				if(GetActorZ(0) - GetActorFloorZ(0) > 0) {
					velX = FixedMul(cos(angle), SD_DASHSPEED);
					velY = FixedMul(sin(angle), SD_DASHSPEED);
					velZ = -GetActorVelZ(0) + SD_DASHJUMP;
				}
				
				else {
					velX = FixedMul(cos(angle), SD_DASHSTRONG);
					velY = FixedMul(sin(angle), SD_DASHSTRONG);
					velZ = 0.0;
				}
				
				SetActorVelocity(0, velX, velY, velZ, true, false);
				if(!soundplayed) {
					ActivatorSound("Player/Dash", SD_SOUNDVOLUME);
					soundplayed = 1;
				}
				GiveInventory("DashEffect", 1);
				GiveInventory("DashDelay", 1);
				dashed = true;
			}
		}
		soundplayed = 0;

		if(dashed && HasClassPerk_Fast("Trickster", 4) && !CheckInventory("Trickster_Acrobat_Cooldown")) {
			GiveInventory("Trickster_Acrobat_Cooldown", 1);

			if(!!HasPlayerBuff(PlayerNumber(), BTI_PHASING))
				ACS_NamedExecuteWithResult("DnD Give Buff", DND_BUFF_PHASING_DASH, DEBUFF_F_PLAYERISACTIVATOR);
		}
	}
}

// reload script -- rewrite sometime
Script 998 (int wepnum, int side, int extra) {
	int base, amt;
	str totake, baseammo = "Clip";
	if(!wepnum) {
		base = GetAmmoCapacity("MGClip");
		totake = "MGClip";
	}
	else if(wepnum == 2) {
		base = GetAmmoCapacity("MGClip2");
		totake = "MGClip2";
	}
	else if(wepnum == 3) {
		base = GetAmmoCapacity("MGClip4");
		totake = "MGClip4";
	}
	else if(wepnum == 4) {
        if(side) {
			if(extra == -1)
				extra = CheckInventory("SpecialAmmoMode_4");
            int need = GetAmmoCapacity("RiotgunClip") - CheckInventory("RiotgunClip");
            if(need) {
				amt = CheckInventory(GetSpecialAmmoString(extra, AMMOINFO_NAME));
                if(amt >= need)
                    GiveInventory("RiotgunClip", need);
                else
                    SetInventory("RiotgunClip", amt);
            }
            Terminate;
        }
        else {
            base = GetAmmoCapacity("MGClip5");
            totake = "MGClip5";
        }
	}
	else if(wepnum == 5) {
		base = GetAmmoCapacity("AcidClip");
		baseammo = "AcidAmmo";
		totake = "AcidClip";
	}
	else if(wepnum == 6) {
		base = GetAmmoCapacity("MGClip6");
		baseammo = "FusionCell";
		totake = "MGClip6";
	}
	else if(wepnum == 7) {
		base = GetAmmoCapacity("MGClip7");
		totake = "MGClip7";
	}
	else if(wepnum == 8) {
		baseammo = "SawedoffShell";
		base = 2;
		totake = "SawedoffCounter";
	}
	
	amt = base - CheckInventory(totake);
	
	if(CheckInventory(baseammo) < base) {
		GiveInventory(totake, CheckInventory(baseammo));
		TakeInventory(baseammo, amt);
	}
	else {
		TakeInventory(baseammo, amt);
		GiveInventory(totake, amt);
	}
}

// Regeneration and other infrequent periodic checks
Script "DnD Periodic Regeneration" ENTER {
	int cur, amt, lim, pnum = PlayerNumber(), this = ActivatorTID();
	int ticker = 0;
	while(PlayerInGame(pnum)) {
		if(isAlive()) {
			buffData_T module& pbuffs = GetPlayerBuffData(pnum);
			int regen_amt = pbuffs.buff_net_values[BUFF_HEALTHREGEN].additive;

			if(!(ticker % 10) && (amt = GetPlayerAttributeValue(pnum, INV_INC_PASSIVEREGEN))) {
				regen_amt += amt;
				ticker = 0;
			}

			if((regen_amt > 0 || CheckInventory("Ability_Regeneration")) && !IsAccessoryEquipped(this, DND_ACCESSORY_GRYPHONBOOTS)) {
				cur = GetActorProperty(0, APROP_HEALTH);
				regen_amt = (regen_amt * 100) >> 16;
				lim = GetRegenCap(pnum);
				amt = CheckInventory("PlayerHealthCap") * (DND_REGEN_PERCENT + regen_amt) / 100;
				amt = amt * (100 + GetPlayerAttributeValue(pnum, INV_REGENRATE)) / 100;

				regen_amt = pbuffs.buff_net_values[BUFF_HEALTHREGEN].multiplicative;
				if(regen_amt != 1.0) {
					regen_amt = (regen_amt * 100) >> 16;
					amt = amt * regen_amt / 100;
				}
				
				if(!amt)
					amt = 1;
				
				// cyborg perk
				if(HasClassPerk_Fast("Cyborg", 1))
					amt += amt * DND_CYBORG_CYBER_MULT / DND_CYBORG_CYBER_DIV;
				
				if((!CheckInventory("DnD_Hit_CombatTimer") || GetPlayerAttributeValue(pnum, INV_CORR_DMGDOESNTSTOPREGEN) || GetPlayerAttributeValue(pnum, INV_INC_HPREGENINTERRUPT)) && cur < lim) {
					if(cur + amt < lim)
						GiveInventory("HealthBonusX", amt);
					else
						GiveInventory("HealthBonusX", lim - cur);
					GiveInventory("RegenEffect", 1);
					LocalAmbientSound("ability/regen", 127);
				}
			}

			// energy shield regeneration
			amt = CanRegenEShield(pnum);
			if(amt)
				ACS_NamedExecuteAlways("DnD Energy Shield Regen", 0, amt, pnum);
		}
		Delay(const:TICRATE);
		++ticker;
	}
}

Script "DnD Energy Shield Regen" (int cap, int pnum) {
	GiveInventory("EShieldCharging", 1);

	// minimum wait time will always be 1 second before a recovery can start
	int rchrg = GetPlayerEnergyShieldRechargeDelay(pnum);

	// if we get hit, stop this
	rchrg /= 7;

	int count = 0;
	while(count < 7 && !CheckInventory("EShieldChargeNow")) {
		++count;

		// if we died, or if we are in combat AND we don't have "can charge right now!" or we have no eshield at this time
		if
		(
			!isAlive() || 
			(CheckInventory("DnD_Hit_CombatTimer") && !GetPlayerAttributeValue(pnum, INV_EX_ESCHARGE_DMGNOINTERRUPT) && !GetPlayerAttributeValue(pnum, INV_INC_ESHIELDNOINTERRUPT) && !CheckInventory("EShieldChargeNow")) || 
			!GetAmmoCapacity("EShieldAmountVisual")
		)
		{
			TakeInventory("EShieldCharging", 1);
			Terminate;
		}

		Delay(rchrg);
	}

	// check it again just in case
	cap = GetPlayerEnergyShieldCap(pnum);
	if(!cap)
		Terminate;

	ACS_NamedExecuteAlways("DnD Energy Shield FX", 0, cap, pnum);

	// we can start the recovery now, but we still have to check if we enter combat etc.
	rchrg = GetPlayerEnergyShieldRecoveryRate(pnum, cap);
	if((count = GetPlayerAttributeValue(pnum, INV_EX_ESCHARGE_USEHP))) {
		// take life from player now
		count = rchrg * count / 100;
		if(count <= 0)
			count = 1;
	}
	else
		count = 0;

	while(isAlive() && CheckInventory("EShieldAmount") < cap) {
		AddEnergyShield(rchrg);
		if(CheckInventory("EShieldAmount") >= cap)
			SetEnergyShield(cap);

		if(count) {
			// take life -- do not damage, we aren't triggering on hit effects!
			if(GetActorProperty(0, APROP_HEALTH) - count > 0)
				SetActorProperty(0, APROP_HEALTH, GetActorProperty(0, APROP_HEALTH) - count);
			else {
				GiveInventory("DnD_Hit_CombatTimer", 1);
				TakeInventory("EShieldChargeNow", 1);
				TakeInventory("EShieldCharging", 1);
				LocalAmbientSound("EShield/Finish", 127);
				Terminate;
			}
		}
		
		if(CheckInventory("DnD_Hit_CombatTimer") && !GetPlayerAttributeValue(pnum, INV_EX_ESCHARGE_DMGNOINTERRUPT) && !CheckInventory("EShieldChargeNow")) {
			TakeInventory("EShieldCharging", 1);
			TakeInventory("EShieldChargeNow", 1);
			Terminate;
		}

		if(!GetAmmoCapacity("EShieldAmountVisual") || CheckInventory("TaltosUp")) {
			SetEnergyShield(0);
			TakeInventory("EShieldCharging", 1);
			TakeInventory("EShieldChargeNow", 1);
			Terminate;
		}

		Delay(ESHIELD_RECOVERYRATE_TICS);
	}

	if(isAlive()) {
		TakeInventory("EShieldCharging", 1);
		LocalAmbientSound("EShield/Finish", 127);
		TakeInventory("EShieldChargeNow", 1);
	}
}

Script "DnD Energy Shield FX" (int cap, int pnum) CLIENTSIDE {
	if(ConsolePlayerNumber() != pnum)
		Terminate;

	int amt;
	int x, y, a;

	PlaySound(0, "EShield/Begin", CHAN_6, 1.0);

	while
	(
		isAlive() && 
		CheckInventory("EShieldCharging") &&
		!CheckInventory("TaltosUp") && 
		(amt = CheckInventory("EShieldAmount")) < cap &&
		!CheckInventory("DnD_IntermissionState")
	)
	{
		// get how far off we are from completion to adjust position and alpha
		int pct = 0;
		if(amt < 65536) {
			amt <<= 16;
			pct = FixedDiv(amt, cap << 16) * 100;
		}
		else {
			// at this point the tiny pct values we lose are irrelevant
			pct = amt * 100 / cap;
			pct <<= 16;
		}

		SetHudSize(640, 480, 0);
		SetFont("SHLDLFT");

		x = (GetHudLeft(640) << 16) - 120.0;
		y = 0.0;
		a = abs(sin((pct / 50) % 1.0));
		HudMessage(s:"A";  HUDMSG_FADEINOUT | HUDMSG_ALPHA | HUDMSG_ADDBLEND, ESHIELD_LEFT_ID, CR_WHITE, GetIntegerBits(x + 88 * pct / 100) + 0.2, y, 0.75, 0.0, 0.75, a);

		SetFont("SHLDRGT");
		x = (GetHudRight(640) << 16) - 136.0;
		HudMessage(s:"A";  HUDMSG_FADEINOUT | HUDMSG_ALPHA | HUDMSG_ADDBLEND, ESHIELD_RIGHT_ID, CR_WHITE, GetIntegerBits(x - 88 * pct / 100) + 0.1, y, 0.75, 0.0, 0.75, a);

		Delay(const:1);
	}

	StopSound(0, CHAN_6);

	// insta clean if in scoreboard when this happens
	if(CheckInventory("DnD_IntermissionState"))
		HudMessage(s:"";  HUDMSG_FADEOUT | HUDMSG_ALPHA | HUDMSG_ADDBLEND, ESHIELD_RIGHT_ID, CR_WHITE, GetIntegerBits(x - 88 * pct / 100) + 0.1, y, 0.1, 0.25, a);

	GiveInventory("EShieldBlend", 1);
}

Script "DnD Lifesteal Script" (int tid) {
	if(tid > 0)
		SetActivator(tid);

	GiveInventory("PlayerIsLeeching", 1);

	int pnum = PlayerNumber();
	int tics = GetLifestealRate(pnum);
	int amt;
	int cap = GetSpawnHealth();
	bool cyborgCheck = HasClassPerk_Fast("Cyborg", 5);
	if(cyborgCheck)
		cap = GetPlayerEnergyShieldCap(pnum);

	// printbold(s:"health cap: ", d:cap, s: " tics: ", d:tics);
	int ls_amount = 0;
	while((IsAlive() && (ls_amount = CheckInventory("LifeStealAmount"))) || CheckInventory("LifestealCooldown")) {
		if(ls_amount) {
			int toCompare = GetActorProperty(0, APROP_HEALTH);
			if(cyborgCheck)
				toCompare = CheckInventory("EShieldAmount");

			amt = GetLifestealLifeRecovery(pnum, cap);
			TakeInventory("LifeStealAmount", amt);
			
			if(toCompare + amt < cap) {
				if(!cyborgCheck)
					GiveInventory("HealthBonusX", amt);
				else
					AddEnergyShield(amt);
			}
			else {
				// we can put "lifesteal effect not removed when reaching max life" here in the future if needed to not break, but also not heal
				if(!cyborgCheck)
					GiveInventory("HealthBonusX", cap - toCompare);
				else
					AddEnergyShield(cap - toCompare);
				break;
			}
		}
		Delay(tics);

		// in case a new update occurs during
		tics = GetLifestealRate(pnum);
	}

	TakeInventory("LifestealScriptRunning", 1);
	SetInventory("LifeStealAmount", 0);
	TakeInventory("PlayerIsLeeching", 1);
}

// for elites with pierce armor flag
Script "DND Pierce Check" (void) {
	int owner = GetActorProperty(0, APROP_TARGETTID);
	// setactorflag isnt in zandro, so
	if(CheckFlag(owner, "PIERCEARMOR"))
		GiveInventory("MakePierce", 1);
}

Script "DND Riotgun Decide" (void) {
	// check riotgun mode switch clip
	str mode = "RiotgunShell";
	if(CheckInventory("SpecialAmmoMode_4") == AMMO_EXPLOSIVESHELL)
		mode = "ExplodingShell";
	else if(CheckInventory("SpecialAmmoMode_4") == AMMO_NITROGENSHELL)
		mode = "NitroShell";
	// either clip full or special ammo clip full
	if((CheckInventory("RiotgunClip") == GetAmmoCapacity("RiotgunClip") || CheckInventory("RiotgunClip") == CheckInventory(mode)) && CanSwitchMode(AMMO_TYPE_SHELL2, SPWEP_MG))
		SetInventory("RiotgunReloadModeDecide", 2); // mode switch
	else if(CheckInventory("RiotgunClip") < GetAmmoCapacity("RiotgunClip") && CheckInventory(mode) > CheckInventory("RiotgunClip"))
		SetInventory("RiotgunReloadModeDecide", 1); // reload
}

Script 1000 (int isSoftcore) {
	int i;
	// casual mode has higher drop rates
	if(isSoftcore != 2) {
		for(i = 0; i < MAXFLAGS; ++i)
			ConsoleCommand(StrParam(s:FlagCheckList[i], s: " ", d:FlagAcceptedValues[i]));
		for(i = 0; i < MAXDNDFLAGS; ++i)
			SetCVar(DNDFlagCheckList[i], DNDFlagAcceptedValues[i]);
		// handle fixed point shit here because getcvar is stupid with them
		ConsoleCommand("sv_coop_damagefactor 1.0");
		/*SetCVar("dnd_researchdroprate", 0.0025);
		SetCVar("dnd_uniquemonster_spawnchance", 0.025);*/
	}
	if(isSoftcore < 2) {
		if(isSoftcore) {
			SetCVar("dnd_mode", 1); //Softcore
		}
		else {
			SetCVar("dnd_mode", 2); //Hardcore
		}
		ConsoleCommand("authhostname auth.zandronum.com:16666");
	}
	else if(isSoftcore < 4) {
		// softcore == 2 => casual mode, default settings
		// beginner mode, force smart monster spawner
		// 4 or 5 are simulated softcore / hardcore for singleplayer or local servers -- no database but ruleset is the same
		if(isSoftcore == 3) {
			SetCVar("dnd_allresearchesfound", 0);
			SetCVar("dnd_usesmartmonsterspawner", 1);
		}
	}
	ConsoleCommand("map map01");
}

Script "DnD Levelup Log" (int has_perk) CLIENTSIDE {
	if(has_perk)
		Log(s:"\cc", l:"DND_ANNOUNCE", s:": \c-", n:0, s:" \c[Y5]", l:"DND_GOTPERK");
	else
		Log(s:"\cc", l:"DND_ANNOUNCE", s:": \c-", n:0, s:" \c[Y5]", l:"DND_HASLEVELEDUP", s:"\cv ", d:CheckInventory("Level"), s:"\c[Y5]!");
}

// This redirection is needed because players receive inventory tokens, but the monster executed the script so players don't properly get the tokens
Script "DnD Legendary Announcer" (void) {
	for(int i = 0; i < MAXPLAYERS; ++i) {
		if(PlayerInGame(i)) {
			SetActivator(i + P_TIDSTART);
			ACS_NamedExecuteAlways("DnD Announcer", 0, DND_ANNOUNCER_LEGENDARYMONSTER);
		}
	}
}

Script "DND Announcer" (int num, int extra, int to) CLIENTSIDE {
	if(to)
		SetActivator(to + P_TIDSTART - 1);
		
	while(CheckInventory("TipBoxOpen"))
		Delay(const:35);
		
	// dont proceed if we are in scoreboard
	if(CheckInventory("DnD_IntermissionState"))
		Terminate;
		
	GiveInventory("TipBoxOpen", 1); // just in case this wasn't given before
	if(num != DND_ANNOUNCER_TRADEREQUEST)
		LocalAmbientSound("Quest/Announce", 127);
	if(num == DND_ANNOUNCER_LEGENDARYMONSTER)
		AmbientSound("LegendaryHere", 127);
	SetHudSize(640, 480, 1);

	int hud_pos = (GetHudRight(640) << 16) - NOTIFBAK_XF / 2 + 0.4;
	if(num != DND_ANNOUNCER_LEGENDARYMONSTER) {
		if(num != DND_ANNOUNCER_QUEST) {
			SetFont("QUESTPOP");
			HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVETOPTEXTID, CR_UNTRANSLATED, hud_pos, 72.0, 4.0, 1.0, 1.0);
		}
		SetFont("NOTIFBAK");
		HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVEBAKID, CR_UNTRANSLATED, hud_pos, 96.0, 4.0, 1.0, 1.0);
	}
	else {
		SetFont("QUESTPOP");
		HudMessageBold(s:"A"; HUDMSG_FADEINOUT, SURVIVETOPTEXTID, CR_UNTRANSLATED, hud_pos, 72.0, 4.0, 1.0, 1.0);
		SetFont("NOTIFBAK");
		HudMessageBold(s:"A"; HUDMSG_FADEINOUT, SURVIVEBAKID, CR_UNTRANSLATED, hud_pos, 96.0, 4.0, 1.0, 1.0);
	}
		
	SetFont("OBJFONT");
	SetHudSize(960, 600, 1);
	
	hud_pos = GetHudRight(960) - 3 * NOTIFBAK_X / 2 + 8;
	hud_pos <<= 16;
	
	if(num == DND_ANNOUNCER_QUEST) {
		SetHudClipRect(hud_pos >> 16, 52, 225, 144, 225);
		HudMessage(
			l:"DND_NEWQUEST"; 
			HUDMSG_FADEINOUT, SURVIVETEXTID, CR_CYAN, GetIntegerBits(hud_pos + 2 * NOTIFBAK_XF / 3) + 0.4, 48.1, 4.0, 1.0, 1.0
		);
		
		HudMessage(
			s:"\cf", l:GetQuestLabel(extra, QUEST_NAME),
			s:"\n\c[Y5]", l:"DND_REQ", s:": \c-", l:GetQuestLabel(extra, QUEST_REQ),
			s:"\n\cd", l:"DND_REW", s:": \c-", l:GetQuestLabel(extra, QUEST_REW);
			HUDMSG_FADEINOUT, SURVIVETEXTID2, CR_WHITE, hud_pos + 0.1, 72.1, 4.0, 1.0, 1.0
		);
	}
	else {
		SetHudClipRect(hud_pos >> 16, 96, 225, 128, 225);
		hud_pos += 0.1;
		
		if(num == DND_ANNOUNCER_ATTRIBPOINT)
			HudMessage(l:"DND_TEXT_UNSPENTPOINT", s:" ", l:"DND_TEXT_SPENDINMENU"; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 126.1, 4.0, 1.0, 1.0);
		else if(num == DND_ANNOUNCER_NEWCLASSPERK)
			HudMessage(l:"DND_TEXT_NEWPERK"; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 126.1, 4.0, 1.0, 1.0);
		else if(num == DND_ANNOUNCER_LEGENDARYMONSTER) // this one is called from the monster spawner and thus must be hudmessagebold
			HudMessageBold(l:"DND_TEXT_LEGENDARYWALKS"; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 126.1, 4.0, 1.0, 1.0);
		else if(num == DND_ANNOUNCER_RESEARCHDISCOVER)
			HudMessage(l:"DND_TEXT_DISCOVEREDRES", s:": \cd", l:GetResearchLabel(extra), s:"\c-!"; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 126.1, 4.0, 1.0, 1.0);
		else if(num == DND_ANNOUNCER_TRADEREQUEST) {
			LocalAmbientSound("TradeRequest", 127);
			HudMessage(l:"DND_TEXT_TRADEREQUEST", s:": ", n:extra + 1; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 126.1, 4.0, 1.0, 1.0);
		}
	}
	SetHudClipRect(0, 0, 0, 0, 0);
}

Script 1002 (void) NET CLIENTSIDE {
	int qid = CheckInventory("ActiveQuestID") - 1;
	if(qid < 0 || !CheckInventory("QuestWasPicked")) {
		Log(l:"DND_TEXT_NOACTIVEQUEST");
		Terminate;
	}
	else if(CheckInventory("TipBoxOpen"))
		Terminate;
			
			
	SetHudSize(640, 480, 1);
	SetFont("QUESTPOP");
	
	int hud_pos = (GetHudRight(640) << 16) - QSTBOX2_XF / 2 + 0.4;
	GiveInventory("TipboxOpen", 1);
	LocalAmbientSound("Quest/View", 127);
	SetHudSize(640, 480, 1);
	SetFont("QSTBOX2");
	HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVEID, CR_UNTRANSLATED, hud_pos, 136.0, 4.0, 1.0, 1.0);
	
	hud_pos = (GetHudRight(960) << 16) - 3 * QSTBOX2_XF / 2 + 48.1;
	SetHudSize(960, 600, 1);
	SetFont("OBJFONT");
	HudMessage
	(
		s:"\cf", l:GetQuestLabel(qid, QUEST_NAME);
		HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 112.1, 4.0, 1.0, 1.0
	);
	// requirement
	SetHudClipRect(hud_pos >> 16, 128, 384, 64, 384);
	HudMessage
	(
		s:"\c-\c[Y5]", l:"DND_REQ", s:": \c-", l:GetQuestLabel(qid, QUEST_REQ);
		HUDMSG_FADEINOUT, UPGRADETEXTID, CR_WHITE, hud_pos, 136.1, 4.0, 1.0, 1.0
	);
	// reward
	SetHudClipRect(hud_pos >> 16, 176, 384, 64, 384);
	HudMessage
	(
		s:"\c-\cd", l:"DND_REW", s:": \c-", l:GetQuestLabel(qid, QUEST_REW);
		HUDMSG_FADEINOUT, SURVIVEICO, CR_WHITE, hud_pos, 184.1, 4.0, 1.0, 1.0
	);
	SetHudClipRect(0, 0, 0, 0, 0);
	// progress
	if(Quest_List[qid].qflag & QTYPE_TRACKABLE) {
		int progress = Clamp_Between((100 * CheckInventory(Quest_List[qid].qchecker)) / GetQuestProgressRequirement(qid), 0, 100);
		str color = "\cg";
		if(progress == 100)
			color = "\cd";
		else if(progress > 75)
			color = "\cf";
		else if(progress > 50)
			color = "\ck";
		else if(progress > 25)
			color = "\ci";
		HudMessage
		(
			l:"DND_PROGRESS", s:": ", s:color, d:progress, s:"%\c-";
			HUDMSG_FADEINOUT, SURVIVETOPTEXTID, CR_WHITE, hud_pos, 232.1, 4.0, 1.0, 1.0
		);
	}
	Delay(35 * 5);
	LocalAmbientSound("Quest/Close", 127);
	SetHudClipRect(0, 0, 0, 0, 0);
}

Script "DND Quest Complete" (int isFail) CLIENTSIDE {
	while(CheckInventory("ShowingMenu"))
		Delay(const:35);
	int qid = CheckInventory("QuestCompletionToken") - 1;
	if(qid < 0)
		Terminate;
	while(ScreenResOffsets[0] == -1)
		Delay(const:17);
	
	int hud_pos = (GetHudRight(640) << 16) - QSTBOX_XF / 2 + 0.4;
	GiveInventory("TipBoxOpen", 1);
	SetHudSize(640, 480, 1);
	SetFont("QUESTBOX");
	HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVEID, CR_UNTRANSLATED, hud_pos, 120.0, 3.0, 1.0, 1.0);
	
	hud_pos = (GetHudRight(960) << 16) - 3 * QSTBOX_XF / 2 + 48.1;
	SetHudSize(960, 600, 1);
	SetFont("OBJFONT");
	if(!isFail) {
		LocalAmbientSound("Quest/Done", 127);
		HudMessage
		(
			s:"\cf", l:GetQuestLabel(qid, QUEST_NAME),
			s:"\c-\n\c[Y5]", l:"DND_QUESTCOMPLETE";
			HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 104.1, 3.0, 1.0, 1.0
		);
	}
	else {
		LocalAmbientSound("Quest/Fail", 127);
		HudMessage
		(
			s:"\cf", l:GetQuestLabel(qid, QUEST_NAME),
			s:"\c-\n\c[B1]", l:"DND_QUESTFAILED";
			HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, hud_pos, 104.1, 3.0, 1.0, 1.0
		);
	}
}

Script "DND Weapon Damage Retrieve" (int dmgid, int damage_category, int flags) {
	int isSpecial = flags & DND_WDMG_ISSPECIALAMMO;
	int wepid = dmgid >> 16;
	dmgid &= 0xFFFF;
	
	// hack for crit guarantee on multi-proj attacks
	bool proj_crit = AdjustDamageRetrievePointers(flags, true, wepid);
	
	// if bad activator, stop
	// note: for some reason I noticed hitscan type attacks print a bunch of -1 pnum, and 0 activator so this should prevent the load caused by those
	// 		 not to mention it's bad (-1 pnum array access...)
	if(!ActivatorTID()) {
		SetResultValue(0);
		Terminate;
	}

	SetResultValue(RetrieveWeaponDamage(PlayerNumber(), wepid, dmgid, damage_category, flags, isSpecial));
}

// Used mainly for non-weapons (like artifacts, spells and so on)
// send order for attn: first 8 => str, 2nd 8 => dex, 3rd 8 => int
Script "DND Player Damage Scale" (int dmg, int damage_category, int flags, int attunements) {
	AdjustDamageRetrievePointers(flags, true);

	int str_scaling = 0.01 * (attunements & ATTUNEMENT_MASK);
	int dex_scaling = 0.01 * ((attunements >> DEX_ATTUNE_BITS) & ATTUNEMENT_MASK);
	int int_scaling = 0.01 * ((attunements >> INT_ATTUNE_BITS) & ATTUNEMENT_MASK);

	dmg = HandleNonWeaponDamageScale(
		dmg, 
		damage_category,
		flags,
		str_scaling,
		dex_scaling,
		int_scaling
	);

	SetResultValue(dmg);
}

Script "DnD Give Energy Shield" (int val) {
	int cap = GetPlayerEnergyShieldCap(PlayerNumber());
	if(cap) {
		// still assume this as minimum
		if(cap < DND_ESHIELD_NONE_BASE)
			cap = DND_ESHIELD_NONE_BASE;
		val = val * cap / 100;
		if(!val)
			val = 1;
		if(CheckInventory("EShieldAmount") < cap - val)
			AddEnergyShield(val);
		else
			SetEnergyShield(cap);
	}
	else if(CheckInventory("EShieldAmount") < DND_ESHIELD_NONE_BASE)
		AddEnergyShield(1);
	
}

Script "DnD Toggle NoPain" (void) {
	// only take away this if the monster initially did not have it, some monsters have this and we dont want to deprive it of that flag
	if(!MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[DND_NOPAIN])
		GiveInventory("TakeNoPain", 1);
}

Script "DnD Timed Monster" (int time, int isPet) {
	int cnt = 0;
	while(cnt++ != time)
		Delay(const:TICRATE);
	if(!isPet)
		SetActorState(0, "Remove");
	else
		Thing_Damage2(0, GetActorProperty(0, APROP_HEALTH) * 3, "Perish");
	SetResultValue(0);
}

Script "DND Hardcore Monster Message" (void) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	Delay(const:1);
	SetFont("DBIGFONT");
	SetHudSize(640, 480, 0);
	HudMessage(l:"DND_TEXT_LOADINGMONS"; HUDMSG_PLAIN, DND_HARDCORE_SCREENID, CR_RED, 320.4, 240.0, 0);
	Delay(const:17 * (DND_MAX_MONSTERDELAY + 2)); // Add 3 seconds to it to allow player script to finish first.
	HudMessage(s:""; HUDMSG_PLAIN, DND_HARDCORE_SCREENID, CR_RED, 320.0, 240.0, 1);
}

// skip wait for load on this guy
Script 1004 (void) NET {
	int pnum = PlayerNumber();
	if (PlayerInGame(pnum) && CheckInventory("CanLoad"))
	{
		if (PlayerIsLoggedIn(pnum))
		{
			if (ACS_NamedExecuteWithResult("DnD Load Character Check", pnum, 0) == 11) //DND_CHARLOADED
				ACS_ExecuteAlways(1001,0,0);
			else if (ACS_NamedExecuteWithResult("DnD Create Character Check", pnum, 0) == 1) //DND_LOGIN_CREATECHAROK
				ACS_ExecuteAlways(1003,0,0);
		}
		else {
			SetInventory("CanLoad", 0);
			PlayerCanLoad[pnum] = 0;
		}
	}
}

// receive user settings from client => server
Script "DnD User CVAR Status Receive" (int bits) NET {
	int tid = ActivatorTID();
	SetActorInventory(tid, "DashDisabled", bits & 1);
}

Script "DnD Drop Orb" (void) {
	SpawnOrbForAll(1);
}

Script "DnD Play Local Item Drop Sound" (int who, int droptype, int extra) CLIENTSIDE {
	if(ConsolePlayerNumber() != who)
		Terminate;
	
	switch(droptype) {
		case DND_ITEM_CHARM:
			PlaySound(0, "Items/CharmDrop", 4);
		break;
		case DND_ITEM_ORB:
			if(IsMidTierOrb(extra))
				PlaySound(0, "Drop/Mid", 5);
			else if(IsHighTierOrb(extra))
				PlaySound(0, "Drop/High", 5);
			else
				PlaySound(0, "Items/OrbDrop", 5);
		break;
		case DND_ITEM_TOKEN:
			Playsound(0, "Items/TokenDrop", 6);
		break;
		case DND_ITEM_BODYARMOR:
		case DND_ITEM_BOOT:
		case DND_ITEM_HELM:
			Playsound(0, "Items/ArmorEquip", 6);
		break;
		case DND_ITEM_SPECIALTY_CYBORG:
			Playsound(0, "Items/PowercoreDrop", 6);
		break;
	}
}

Script "DnD Chest Opened" (int ctype) {
	HandleChestDrops(ctype);
}

Script "DnD Check Special GameMode" (void) {
	SetResultValue(isSoftorHardcore());
}

Script "DnD Talisman Mark Timer" (int counter) {
	GiveInventory("HunterTalismanMarkBool", 1);
	for(int i = 0; i < counter && isAlive(); ++i)
		Delay(35);
	TakeInventory("HunterTalismanMarkBool", 1);
}

Script "DnD Talisman Mark" (void) CLIENTSIDE {
	CreateMonsterAttachment(ActivatorTID(), "HunterTalismanFX", 0, 0, 48.0);
}

Script "DnD Chest Dropping Item" (int chance_penalty) {
	// after the initial spawning this will be checked to not spawn a chest again
	if(IsSetupComplete(SETUP_STATE1, SETUP_PLAYERINFO_MINMAXLEVELS))
		Terminate;

	while(GetGameModeState() != GAMESTATE_INPROGRESS)
		Delay(const:TICRATE);
	// additional delay for the map difficulty calculator
	Delay(const:TICRATE);
	HandleChestSpawn(chance_penalty);
}

Script "DnD Give Research" (int sp) {
	SetActivator((sp & 0xFFFF) + P_TIDSTART);
	GiveInventory("ResearchSoundPlayer", 1);
	ACS_NamedExecuteAlways("DnD Message Logger", 0, 2, sp, 1);
	GiveResearch(sp >> 16, false);
}

Script "DnD Give Research - Regular" (int res_id, int fancy) {
	if(CheckResearchStatus(res_id) == RES_NA) {
		GiveInventory("ResearchSoundPlayer", 1);
		GiveResearch(res_id, fancy);
	}
}

Script "DnD Orb Message" (int id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	ActivatorSound("Items/OrbPick", 127);
	GiveInventory("OrbSoundPlayer", 1);
	Log(s:StrParam(s:"\cc", l:"DND_PICKUP_ORB", s:": \c[Y5]", l:GetInventoryTag(id + ORBS_BEGIN), s:"!\c-"));
}

Script "DnD Token Message" (int id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	ActivatorSound("Items/TokenPick", 127);
	GiveInventory("TokenSoundPlayer", 1);
	Log(s:StrParam(s:"\cc", l:"DND_PICKUP_TOKEN", s:": \c[Y5]", l:GetInventoryTag(id + TOKEN_BEGIN), s:"!\c-"));
}

Script "DnD Stacked Item Pickup" (int sp, int type) {
	if((sp & 0xFFFF) == 255)
		SetActivatorToTarget(0);
	else
		SetActivator((sp & 0xFFFF) + P_TIDSTART);
	SetResultValue(HandleStackedPickup(sp >> 16, type));
}

Script "DnD Drop Research" (void) {
	// this guarantees the activator is the player that opened it
	SetActivatorToTarget(0);
	SpawnResearch(ActivatorTID() - P_TIDSTART);
}

// From HardDoom v83
Script "DnD Footstep Sound" ENTER CLIENTSIDE {
	int DelayTime, StepVolume, x;
	int pnum = PlayerNumber();
	while(PlayerInGame(pnum)) {
		Delay(const:1);
		x = min(GetPVelocity(), 9);
		DelayTime = 16 - GetPVelocity() / 2;
		StepVolume = 7 * x;
		if(GetActorZ(0) - GetActorFloorZ(0) == 0)
			ActivatorSound(DefStepSound, StepVolume);
		Delay(DelayTime);
	}
}

Script "DnD Weapon Can Switch Mode" (int ammo_category, int weptype) {
	// prevent switching while in menu
	SetResultValue(!CheckInventory("ShowingMenu") && CanSwitchMode(ammo_category, weptype));
}

Script "DnD Get Target" (void) {
	SetActivatorToTarget(0);
	SetResultValue(ActivatorTID());
}

Script "DnD Get Target of Target" (void) {
	SetActivatorToTarget(0);
	SetActivatorToTarget(0);
	SetResultValue(ActivatorTID());
}

Script "DnD Get Master of Target" (void) {
	SetActivatorToTarget(0);
	SetResultValue(GetActorProperty(0, APROP_MASTERTID));
}

Script "target test" (void) {
	printbold(s:"target test before: ", s:GetActorClass(GetActorProperty(0, APROP_TARGETTID)), s:" ", d:GetActorProperty(0, APROP_TARGETTID));
	SetActivator(0, AAPTR_TARGET);
	printbold(s:"target test mid: ", s:GetActorClass(GetActorProperty(0, APROP_TARGETTID)), s:" ", d:GetActorProperty(0, APROP_TARGETTID));
	SetActivator(0, AAPTR_TARGET);
	printbold(s:"target test after: ", s:GetActorClass(0), s:" ", d:ActivatorTID());
}

Script "DnD Target Fix" (void) {
	// if none assigned
	if(!GetActorProperty(0, APROP_TARGETTID)) {
		int tid = ACS_NamedExecuteWithResult("DnD Get Target of Target");
		SetActorProperty(0, APROP_TARGETTID, tid);
		SetPointer(AAPTR_TARGET, tid);	
	}
	SetResultValue(0);
}

Script "DnD Player Pain Sound" (void) CLIENTSIDE {
	int ptype = CheckInventory("DnD_Character") - 1;
	HandlePlayerPainSound(ptype);
}

Script "DnD Player Death Sound" (int isXDeath) CLIENTSIDE {
	int ptype = CheckInventory("DnD_Character") - 1;
	HandlePlayerDeathSound(ptype, isXDeath);
}

Script "DnD Research Fancy Message" (int res_id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	Log(s:"\cc", l:"DND_PICKUP_RESEARCH", s:":\c[Y5] ", l:GetResearchLabel(res_id), s:"!");
	LocalAmbientSound("items/research", 127);
	ACS_NamedExecuteAlways("DND Announcer", 0, DND_ANNOUNCER_RESEARCHDISCOVER, res_id);
}

Script "DnD Is Demon" (void) {
	SetActivator(0, AAPTR_TRACER);
	SetResultValue(ActivatorTID() && IsDemon());
}

Script "DnD Is Demon - Self" (void) {
	SetResultValue(ActivatorTID() && IsDemon());
}

Script "DnD Give Ammo" (int slot, int ammotype, int amount) {
	GiveAmmo(amount, slot, ammotype);
}

Script "DnD Give Ammo To Target" (int slot, int ammotype, int amount) {
	SetActivatorToTarget(0);
	GiveAmmo(amount, slot, ammotype);
}

Script "DnD Emerald Death" (void) {
	int this = ActivatorTID();
	SetActivatorToTarget(0);
	int target = ActivatorTID();
	if(Spawn("EmeraldDeathActor", GetActorX(this), GetActorY(this), GetActorZ(this) + GetActorProperty(this, APROP_HEIGHT) / 2, target + DND_EMERALD_TIDADD)) {
		SetActivator(target + DND_EMERALD_TIDADD);
		SetPointer(AAPTR_TARGET, target);
		Thing_ChangeTID(0, 0);
	}
}

Script "DnD Charm Message" (int id, int type) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	if(type > UNIQUE_BEGIN) {
		type = (type >> UNIQUE_BITS) - 1;
		Log(s:StrParam(s:"\cc", l:"DND_PICKUP_CHARM", s:": \c[Y5]", l:GetUniqueItemName(DND_ITEM_CHARM, type), s:"!\c-"));
	}
	else
		Log(s:StrParam(s:"\cc", l:"DND_PICKUP_CHARM", s:": \c[Y5]", l:GetItemTagName(DND_ITEM_CHARM, id), s:"!\c-"));
}

Script "DnD Charm Pickup" (int sp) {
	if((sp & 0xFFFF) == 255)
		SetActivatorToTarget(0);
	else
		SetActivator((sp & 0xFFFF) + P_TIDSTART);
	ACS_NamedExecuteAlways("DnD Charm Message", 0, Inventories_On_Field[sp >> 16].item_subtype, Inventories_On_Field[sp >> 16].item_type);
	GiveInventory("CharmSoundPlayer", 1);
	HandleInventoryPickup(sp >> 16);
}

// if we have enough space and we pressed use
Script "DnD Player Has Spot For Item" (int sp) {
	if (GetGameModeState() == GAMESTATE_INPROGRESS) {
		if((sp & 0xFFFF) == 255)
			SetActivatorToTarget(0);
		else
			SetActivator((sp & 0xFFFF) + P_TIDSTART);
		//if (!CheckInventory("CanLoad")) { //BUG: This check is needed to prevent grabbing items before loading char, but had to comment because of extreme lag.
			int filter = CheckInventory("PlayerPickupFilter");
			int ipos = sp >> 16;
			bool res = !CheckInventory("DnD_WaitNextItemPick");

			if
			(
				!CheckInventory("AutoPickCooldown") &&
					(((filter & ITEMFILTER_STACKABLE) && Inventories_On_Field[ipos].item_stack) ||
					((filter & ITEMFILTER_CHARM) && (Inventories_On_Field[ipos].item_type & 0xFFFF) == DND_ITEM_CHARM) ||
					(filter & ITEMFILTER_ARMOR) && (IsArmorTypeItem(Inventories_On_Field[ipos].item_type & 0xFFFF)))
			)
			{
				// actually do nothing here as res will only need to check for waiting item pick cooldown, rather than pressing use
				GiveInventory("AutoPickCooldown", 1);
			}
			else
				res &= CheckInventory("DnD_PressedUse");

			if(res) {
				GiveInventory("DnD_WaitNextItemPick", 1);

				int pnum = PlayerNumber();
				bool spot = false;
				if(Inventories_On_Field[ipos].item_stack)
					spot = GetFreeSpotForItemWithStack(ipos, pnum, DND_SYNC_ITEMSOURCE_FIELD, DND_SYNC_ITEMSOURCE_PLAYERINVENTORY, false) != -1;
				else
					spot = GetFreeSpotForItem(ipos, pnum, DND_SYNC_ITEMSOURCE_FIELD, DND_SYNC_ITEMSOURCE_PLAYERINVENTORY) != -1;
				
				if(!spot && res) {
					// clientside warning sound and text
					ACS_NamedExecuteAlways("DnD Inventory Full CS", 0, pnum);
				}
				SetResultValue(res && spot);
			}
			else
				SetResultValue(false);
		//}
	}
	else
		SetResultValue(false);
}

Script "DnD Inventory Full CS" (int pnum) CLIENTSIDE {
	if(ConsolePlayerNumber() != pnum)
		Terminate;
	LocalAmbientSound("RPG/MenuError", 127);
	Log(s:"\cg", l:"DND_TEXT_NOTIFICATION", s:": \c[Y5]", l:"DND_TEXT_INVENTORYFULL", s:"!");
}

// Player picks up item
Script "DnD Preview Item" (int sp, int target) CLIENTSIDE {
	if((sp & 0xFFFF) == 255) {
		SetActivatorToTarget(0);
		if(!ActivatorTID())
			SetActivator(target);
	}
	else
		SetActivator((sp & 0xFFFF) + P_TIDSTART);
		
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;

	int field_index = sp >> 16;
	//Log(s:"trying to preview item ", d:GetItemSyncValue(PlayerNumber(), DND_SYNC_ITEMTYPE, field_index, -1, DND_SYNC_ITEMSOURCE_FIELD));
	DrawInventoryInfo_Field(PlayerNumber(), field_index, DND_SYNC_ITEMSOURCE_FIELD, 16.0, false);
}

Script "DnD Chestkey Message" (int id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	ActivatorSound("Items/ChestKey", 127);
	GiveInventory("ChestkeySoundPlayer", 1);
	Log(s:StrParam(s:"\cc", l:"DND_PICKUP_BONUS", s:": \c[Y5]", l:GetInventoryTag(id + CHESTKEY_BEGIN), s:"!\c-"));
}

Script "DnD Try Open Chestkey" (int keytype) {
#ifdef ISDEBUGBUILD
	SetResultValue(1);
#else
	int res = -1;
	if ((GetGameModeState() == GAMESTATE_INPROGRESS) && (!CheckActorInventory(GetActorProperty(0, APROP_TARGETTID), "CanLoad"))) {
		res = CheckPlayerInventoryList(GetActorProperty(0, APROP_TARGETTID) - P_TIDSTART, DND_ITEM_CHESTKEY, keytype);
		if(res != -1) {
			SetActivatorToTarget(0);
			UsePlayerItem(PlayerNumber(), res, false);
		}
	}
	SetResultValue(res != -1);
#endif
}

Script "Dnd Init Lootbox" (int val) {
	int tid = DND_LOOTBOX_TID + DnD_TID_Counter[DND_TID_LOOTBOXES];
	Thing_ChangeTID(0, tid);
	DnD_TID_Counter[DND_TID_LOOTBOXES]++;

	SetThingSpecial(0, ACS_NamedExecuteWithResult, "DnD Try Open Lootbox", val, tid);
	SetResultValue(0);
}

Script "DnD Try Open Lootbox" (int for_player, int box_tid) {
	int can_open = ACS_NamedExecuteWithResult("DnD Lootbox Open Check", for_player);
	if(can_open) {
		SetActorState(box_tid, "Open", 0);
		SetThingSpecial(box_tid, 0);
	}
	SetResultValue(0);
}

Script "DnD Lootbox Open Check" (int for_player) {
	SetActivatorToTarget(0);
	int p_tid = ActivatorTID();
	int res = 0;

	// any player can open
	if(for_player == -1)
		res = IsPlayer(p_tid) && GetGameModeState() == GAMESTATE_INPROGRESS && (!CheckActorInventory(p_tid, "CanLoad"));
	else if(IsPlayer(p_tid) && IsPlayer(for_player + P_TIDSTART)) {
		// only specific player can open
		if(p_tid != for_player + P_TIDSTART) {
			SetActivator(p_tid);
			ACS_NamedExecuteAlways("DnD Lootbox Fail Open Message", 0, for_player);
		}
		else if(GetGameModeState() == GAMESTATE_INPROGRESS && (!CheckActorInventory(p_tid, "CanLoad")))
			res = 1;
	}
	SetResultValue(res);
}

Script "DnD Lootbox Fail Open Message" (int for_player) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	ActivatorSound("Chest/Locked", 127);
	Log(s:StrParam(s:"\cc", l:"DND_NOTYOURCHEST", s:" ", l:"DND_IT_BELONGS_TO", s:"\c- ", n:for_player + 1));
}

// guaranteed_orb is +1 of actual value
Script "DnD Lootbox Opened" (int for_player, int guaranteed_orb) {
	if(for_player == -1) {
		for(for_player = 0; for_player < MAXPLAYERS; ++for_player) {
			// run each player's chance, drop for corresponding player only
			SpawnLootboxRewards(for_player, guaranteed_orb);
		}
	}
	else {
		// spawn stuff only for that player
		SpawnLootboxRewards(for_player, guaranteed_orb);
	}
}

Script "DnD Explosion Radius Retrieve" (int flags) {
	if(flags & DND_WDMG_USETARGET)
		SetactivatorToTarget(0);
	else if(flags & DND_WDMG_USEMASTER) {
		if(flags & DND_WDMG_SETMASTER) // this is a hack
			SetPointer(AAPTR_TARGET, GetActorProperty(0, APROP_MASTERTID));
		SetActivator(GetActorProperty(0, APROP_MASTERTID));
	}
	else if(flags & DND_WDMG_USETARGETSMASTER) {
		SetActivator(ACS_NamedExecuteWithResult("DnD Get Master of Target"));
	}
	SetResultValue(GetPlayerAttributeValue(PlayerNumber(), INV_EXPLOSION_RADIUS));
}

// after 16th bit there can be extra info
// never put AMMO_CLIP as 16 bit onwards
Script "DnD Ammo Gain Chance" (int slot, int ammo, int amount) {
	HandleAmmoGainChance(slot, ammo, amount);
	HandleAttackEvent(CheckInventory("DnD_WeaponID"), slot == DND_AMMOSLOT_SPECIAL, ammo > SSAM_SLUG ? ammo - 1 : ammo);
}

// in here because dnd_mons.bcs can't access values of the variables used below
Script "DnD Warmaster Rage" (void) {
	while(!CheckInventory("WarmasterActive"))
		Delay(const:17);
	int i, tidlim, dist;
	while(CheckInventory("WarmasterActive")) {
		bool found = false;
		// try to see if there's at least one monster that is closest to this
		for(int mn = 0; mn < DnD_TID_Counter[DND_TID_MONSTER] && !found; ++mn) {
			i = UsedMonsterTIDs[mn];
		
			if(IsActorAlive(i)) {
				dist = fdistance(0, i);
				// no self find
				if(dist >= 2.0 && dist <= WARMASTER_DIST)
					found = true;
			}
		}
		
		if(found)
			GiveInventory("WarmasterRage", 1);
		else
			TakeInventory("WarmasterRage", 1);
		Delay(const:TICRATE);
	}
}

Script "DnD Get Aspect For Inventory View" (void) CLIENTSIDE {
	SetResultValue(ScreenResOffsets[2]);
}

Script "DnD Force Sync Player Bonuses" (void) {
	Delay(TICRATE * 5);
	if(CheckInventory("DnD_SyncMe"))
		SyncAllClientsideVariables(PlayerNumber());
}

Script "DnD Force Damage Cache Recalculation" (int pnum) {
	if(pnum == -1)
		pnum = PlayerNumber();

	ForcePlayerDamageCaching(pnum);
}

Script "DnD Pet Monster Scale" (int petid, int trait1, int trait2) {
	int master = GetActorProperty(0, APROP_MASTERTID);

	GivePetTID(master);
	
	int base, add, level, temp, this = ActivatorTID();
	int m_id = this - DND_PETTID_BEGIN;
	int pnum = master - P_TIDSTART;
	base = GetActorProperty(0, APROP_HEALTH);
	
	add = 0, level = CheckActorInventory(master, "Level");
	if(level > 1) {
		// our new scaling formula
		add = GetMonsterHPScaling(m_id, level);
		
		add = base * add / 100;
		
		// flat int scaling to pets
		add += GetIntellectEffect(pnum, SKILL_ZOMBIE_HP_PER_INT);

		// add level factor to it
		// first overflow check
		if(add > INT_MAX - base)
			add = INT_MAX - base;
	}
	SetActorProperty(0, APROP_HEALTH, base + add);
	ScaleMonsterMass(level);
	PetMonsterProperties[m_id].id = petid;
	PetMonsterProperties[m_id].basehp = base;
	PetMonsterProperties[m_id].maxhp = base + add;
	PetMonsterProperties[m_id].level = level;
	PetMonsterProperties[m_id].trait_list[DND_PET] = true;
	
	// find a better way to transfer these
	if(trait1 != -1)
		PetMonsterProperties[m_id].trait_list[trait1] = true;
	if(trait2 != -1)
		PetMonsterProperties[m_id].trait_list[trait2] = true;
	
	ACS_NamedExecuteWithResult(
		"DnD Sync Pet Monster Trait CS", 
		this, 
		GetPetMonsterTraits(m_id, 0),
		GetPetMonsterTraits(m_id, 1),
		GetPetMonsterTraits(m_id, 2)
	);

	// pet icon
	ACS_NamedExecuteAlways("DND Spawn Attachment", 0, this, DND_ATTACHMENT_PETICON);
}

Script "DnD Master Skill Info" (int skill_id) {
	int res = 0;
	int master = GetActorProperty(0, APROP_MASTERTID);
	switch(skill_id) {
		case SKILLINFO_ZOMBIEPETTIMER:
			res = GetIntellectEffect(master - P_TIDSTART, SKILL_ZOMBIE_DURATION, ZOMBIE_INT_TIMER_FACTOR);
		break;
	}
	SetResultValue(res);
}

Script "DND Pet Monster Damage Scale" (int base, int rnd, int flags) {
	if(flags & 1) // target
		SetactivatorToTarget(0);
	int this = ActivatorTID();
	int master = GetActorProperty(0, APROP_MASTERTID);
	int res = 1.0 + Clamp_Between(PetMonsterProperties[this - DND_PETTID_BEGIN].level, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 1, 100);
	if(flags & DND_WDMG_ISRIPPER)
		res >>= 1;
	res += GetPetDamageFactor(base, master);
	// we don't need monster id from here onwards
	base &= 0xFFFF;
	// apply the monster's base damage first
	res *= base;
	res >>= 16;
	// now get player damage bonus stuff included
	SetActivator(master);
	int pnum = PlayerNumber();
	res += MapDamageCategoryToFlatBonus(pnum, DND_DAMAGECATEGORY_OCCULT, 0);
	res = res * (100 + DND_DEMONBANE_GAIN * IsAccessoryEquipped(ActivatorTID(), DND_ACCESSORY_DEMONBANE)) / 100;

	// talent bonus
	// to do: check if pet attack was melee or ranged... it makes no sense otherwise -- assuming melee as the only pet is a melee one now
	res = res * (100 + HandleStatBonus(pnum, 0, 0, DND_STAT_ATTUNEMENT_GAIN, true)) / 100;
	
	// TODO: later check if damage is physical, improve this script
	int temp = GetPlayerAttributeValue(pnum, INV_EX_PHYSDAMAGEPER_FLATHEALTH);
	if(temp) {
		temp = GetFlatHealthDamageFactor(temp);
		res = res * (100 + temp) / 100;
	}
		
	temp = MapDamageCategoryToPercentBonus(pnum, DND_DAMAGECATEGORY_OCCULT, 0);
	if(temp)
		res = res * (100 + temp) / 100;
		
	// finally crit chance -- move to damagedeal for pets in damage event later
	if(CheckCritChance(pnum, -1, -1, false, -1)) {
		res = res * GetCritModifier(pnum, -1, -1) / 100;
		HandleHunterTalisman();
	}

	if(rnd)
		res *= random(rnd & 0xFFFF, rnd >> 16);

	SetResultValue(res);
}

Script "DnD On Summon Death Check" (int monsterID) {
	switch(monsterID) {
		case MONSTER_PET_ZOMBIE:
			SetActivator(0, AAPTR_MASTER);
			TakeInventory("SummonedZombiePets", 1);
			TakeInventory("PetCounter", 1);
		break;
	}
}

Script "DnD On Pet Summon" (void) {
	// check for damage shared buff
	/*if(CheckInventory("StatbuffCounter_PainSharedWithPets")) {
		// a bit of delay to register the pet summoning
		Delay(const:10);
		if(CheckInventory("PetCounter"))
			GiveInventory(StrParam(s:"PetDamageReduction_", d:CheckInventory("PetCounter")), 1);
	}*/
}

Script "DnD Pet Distance Move" (void) {
	int master = GetActorProperty(0, APROP_MASTERTID), dx, dy, dz;
	while(IsAlive() && IsActorAlive(master)) {
		if(!CheckInventory("MovePetCooldown")) {
			dx = GetActorX(0) - GetActorX(master);
			dy = GetActorY(0) - GetActorY(master);
			dz = GetActorZ(0) - GetActorZ(master);
			if(fdistance_delta(dx, dy, dz) > DND_PET_MOVEDIST) {
				GiveInventory("MovePetCooldown", 1);
				Thing_Move(0, master, 1);
				SetActorAngle(0, GetActorAngle(master));
				GiveInventory("PetTargetClear", 1);
			}
		}
		Delay(const:TICRATE);
	}
}

Script "DnD Give Soul Ammo" (int amt) {
	GiveAmmo(amt, DND_AMMOSLOT_SOULS, 0);

	// check if special soul pickup mods are there
	int pnum = PlayerNumber();
	int temp = GetPlayerAttributeValue(pnum, INV_EX_SOULPICKUPSINFAMMO);
	if(temp) {
		if(!CheckInventory("SoulPickupInfinityPrevention")) {
			SetInventory("SoulPickupInfinityTimer", temp * TICRATE);
			GiveInventory("SoulPickupInfinityPrevention", GetPlayerAttributeValue(pnum, INV_EX_SOULPICKUPSONLYAMMO));

			// add script call here for the timer deduction
			ACS_NamedExecuteWithResult("DnD Soul Infinity Timer");
		}
		else
			TakeInventory("SoulPickupInfinityPrevention", 1);
	}
}

Script "DnD Soul Infinity Timer" (void) {
	while(isAlive() && CheckInventory("SoulPickupInfinityTimer")) {
		TakeInventory("SoulPickupInfinityTimer", 1);
		Delay(const:1);
	}
	SetResultValue(0);
}

// called whenever player makes an attack, melee weapons or weapon attacks that use no ammo need to call this explicitly
// reason is this is embedded in ammo gain chance script for ease
// extra is special ammo type, isspecial is 1 or 0
Script "DnD On Attack" (int isSpecial, int extra) {
	HandleAttackEvent(CheckInventory("DnD_WeaponID"), isSpecial, extra);
	
	SetResultValue(0);
}

Script "DnD On Artifact Use" (void) {
	if(IsQuestComplete(0, QUEST_USENOARTIFACT))
		GiveInventory("DnD_ArtiDmgPower", 1);
}

// This doesn't trigger when a monster is continuously attacking, their stuff is manually added unfortunately
Script "DnD On Monster Attack" (int isMelee) {
	int this = ActivatorTID();
	int m_id = this - DND_MONSTERTID_BEGIN;
	if(MonsterProperties[m_id].trait_list[DND_MARKOFCHAOS]) {
		// check monster size category -- small, medium or big
		int size = GetMonsterSizeType(MonsterProperties[m_id].id);
		switch(size) {
			case DND_MONSTERSIZE_SMALL:
				GiveInventory("Monster_Chaos_Check", 1);
			break;
			case DND_MONSTERSIZE_MEDIUM:
				GiveInventory("Monster_Chaos_Check_Medium", 1);
			break;
			case DND_MONSTERSIZE_BIG:
				GiveInventory("Monster_Chaos_Check_Big", 1);
			break;
		}
	}
	else if(MonsterProperties[m_id].trait_list[DND_MARKOFASMODEUS])
		HandleAsmodeusAttack(m_id, isMelee);

	int target = GetActorProperty(0, APROP_TARGETTID);

	// summon the grabby hands under the player the monster is targeting
	if
	(
		MonsterProperties[m_id].trait_list[DND_OTHERWORLDGRIP] && 
		random(1, 100) <= DND_OTHERWORLDGRIP_CHANCE && !CheckInventory("OtherworldGripCooldown") &&
		isPlayer(target) && fdistance(this, target) <= OTHERWORLD_GRIP_DIST
	)
	{
		GiveInventory("OtherworldGripCooldown", 1);
		ACS_NamedExecuteAlways("DnD Otherwordly Grip", 0, this, target);
	}
}

Script "DnD Otherwordly Grip Dirts" (int ox, int oy, int oz) CLIENTSIDE {
	// ox, oy, oz are center coords
	SpawnForced(
		"OtherwordlyGripDirt",
		ox + random(-OTHERWORLD_GRIP_RADIUS / 2, OTHERWORLD_GRIP_RADIUS / 2),
		oy + random(-OTHERWORLD_GRIP_RADIUS / 2, OTHERWORLD_GRIP_RADIUS / 2),
		oz
	);

	SpawnForced(
		"OtherwordlyGripDirt",
		ox + random(-OTHERWORLD_GRIP_RADIUS, OTHERWORLD_GRIP_RADIUS),
		oy + random(-OTHERWORLD_GRIP_RADIUS, OTHERWORLD_GRIP_RADIUS),
		oz
	);

	if(random(0, 1)) {
		SpawnForced(
			"OtherwordlyGripDirt",
			ox + random(-OTHERWORLD_GRIP_RADIUS / 2, OTHERWORLD_GRIP_RADIUS / 2),
			oy + random(-OTHERWORLD_GRIP_RADIUS / 2, OTHERWORLD_GRIP_RADIUS / 2),
			oz
		);
	}

	if(random(0, 1)) {
		SpawnForced(
			"OtherwordlyGripDirt",
			ox + random(-OTHERWORLD_GRIP_RADIUS, OTHERWORLD_GRIP_RADIUS),
			oy + random(-OTHERWORLD_GRIP_RADIUS, OTHERWORLD_GRIP_RADIUS),
			oz
		);
	}
}

Script "DnD Otherwordly Grip" (int monster_tid, int player_tid) {
	int ox, oy, oz;
	int count = 0;

	// telegraph the area
	PlaySound(player_tid, "OtherworldGripBegin", CHAN_7 | 4096, 1.0);
	PlaySound(player_tid, "OtherworldGripBegin", CHAN_7 | 4096, 1.0);
	PlaySound(player_tid, "OtherworldGripBegin", CHAN_7 | 4096, 1.0);
	for(count = 0; count < TICRATE; ++count) {
		ox = GetActorX(player_tid);
		oy = GetActorY(player_tid);
		oz = GetActorZ(player_tid);
		ACS_NamedExecuteAlways("DnD Otherwordly Grip Dirts", 0, ox, oy, oz);
		Delay(random(2, 5));
	}
	StopSound(player_tid, CHAN_7);

	Delay(const:HALF_TICRATE);

	// create the hands over time in this area
	count = 0;
	while(count < OTHERWORLD_GRIP_HANDTIME && isActorAlive(monster_tid)) {
		// spawn hands
		SpawnForced(
			"OtherwordlyGripHand",
			ox + random(-OTHERWORLD_GRIP_RADIUS, OTHERWORLD_GRIP_RADIUS),
			oy + random(-OTHERWORLD_GRIP_RADIUS, OTHERWORLD_GRIP_RADIUS),
			oz,
			DND_OTHERWORDLYGRIP_TID
		);
		SetActivator(DND_OTHERWORDLYGRIP_TID);
		SetPointer(AAPTR_TARGET, monster_tid);
		SetActorProperty(0, APROP_TARGETTID, monster_tid);
		SetActorPosition(0, GetActorX(0), GetActorY(0), GetActorFloorZ(0), 0);
		Thing_ChangeTID(DND_OTHERWORDLYGRIP_TID, 0);
		SetActivator(monster_tid);

		if(random(0, 1)) {
			SpawnForced(
				"OtherwordlyGripHand",
				ox + random(-OTHERWORLD_GRIP_RADIUS, OTHERWORLD_GRIP_RADIUS),
				oy + random(-OTHERWORLD_GRIP_RADIUS, OTHERWORLD_GRIP_RADIUS),
				oz,
				DND_OTHERWORDLYGRIP_TID
			);
			SetActivator(DND_OTHERWORDLYGRIP_TID);
			SetPointer(AAPTR_TARGET, monster_tid);
			SetActorProperty(0, APROP_TARGETTID, monster_tid);
			SetActorPosition(0, GetActorX(0), GetActorY(0), GetActorFloorZ(0), 0);
			Thing_ChangeTID(DND_OTHERWORDLYGRIP_TID, 0);
			SetActivator(monster_tid);
		}

		if(random(0, 1)) {
			SpawnForced(
				"OtherwordlyGripHand",
				ox + random(-OTHERWORLD_GRIP_RADIUS / 2, OTHERWORLD_GRIP_RADIUS / 2),
				oy + random(-OTHERWORLD_GRIP_RADIUS / 2, OTHERWORLD_GRIP_RADIUS / 2),
				oz,
				DND_OTHERWORDLYGRIP_TID
			);
			SetActivator(DND_OTHERWORDLYGRIP_TID);
			SetPointer(AAPTR_TARGET, monster_tid);
			SetActorProperty(0, APROP_TARGETTID, monster_tid);
			SetActorPosition(0, GetActorX(0), GetActorY(0), GetActorFloorZ(0), 0);
			Thing_ChangeTID(DND_OTHERWORDLYGRIP_TID, 0);
			SetActivator(monster_tid);
		}

		if(random(0, 2)) {
			SpawnForced(
				"OtherwordlyGripHand",
				ox + random(-OTHERWORLD_GRIP_RADIUS / 4, OTHERWORLD_GRIP_RADIUS / 4),
				oy + random(-OTHERWORLD_GRIP_RADIUS / 4, OTHERWORLD_GRIP_RADIUS / 4),
				oz,
				DND_OTHERWORDLYGRIP_TID
			);
			SetActivator(DND_OTHERWORDLYGRIP_TID);
			SetPointer(AAPTR_TARGET, monster_tid);
			SetActorProperty(0, APROP_TARGETTID, monster_tid);
			SetActorPosition(0, GetActorX(0), GetActorY(0), GetActorFloorZ(0), 0);
			Thing_ChangeTID(DND_OTHERWORDLYGRIP_TID, 0);
			SetActivator(monster_tid);
		}

		if(random(0, 1)) {
			SpawnForced(
				"OtherwordlyGripHand",
				ox + random(-OTHERWORLD_GRIP_RADIUS / 8, OTHERWORLD_GRIP_RADIUS / 8),
				oy + random(-OTHERWORLD_GRIP_RADIUS / 8, OTHERWORLD_GRIP_RADIUS / 8),
				oz,
				DND_OTHERWORDLYGRIP_TID
			);
			SetActivator(DND_OTHERWORDLYGRIP_TID);
			SetPointer(AAPTR_TARGET, monster_tid);
			SetActorProperty(0, APROP_TARGETTID, monster_tid);
			SetActorPosition(0, GetActorX(0), GetActorY(0), GetActorFloorZ(0), 0);
			Thing_ChangeTID(DND_OTHERWORDLYGRIP_TID, 0);
			SetActivator(monster_tid);
		}

		++count;
		Delay(const:3);
	}
 }

 Script "DnD Thunderstruck" (int mon_tid) {
	// player's tid acquired early on
	int player_tid = ActivatorTID();
	SetActivator(mon_tid);

	// don't spawn if there's no LOS
	if(!CheckSight(mon_tid, player_tid, 0))
		Terminate;

	SpawnForced("ThunderstruckLightning", GetActorX(player_tid) + random(-16, 16), GetActorY(player_tid) + random(-16, 16), GetActorZ(player_tid), DND_THUNDERSTRUCK_TID);
	SetActivator(DND_THUNDERSTRUCK_TID);
	SetPointer(AAPTR_TARGET, mon_tid);
	SetActorProperty(0, APROP_TARGETTID, mon_tid);
	Thing_ChangeTID(DND_THUNDERSTRUCK_TID, 0);
	SetActivator(mon_tid);
 }

 Script "DnD Temporal Bubble Ticker" (int mon_tid, int m_id) {
	SetActivator(mon_tid);
	ACS_NamedExecuteAlways("DnD Aura Giver CS", 0, DND_TEMPORALBUBBLE, 1);

	while(IsAlive() && CheckInventory("TemporalBubbleCooldown"))
		Delay(const:TICRATE);

	if(isAlive())
		ACS_NamedExecuteAlways("DnD Aura Giver CS", 0, DND_TEMPORALBUBBLE);
 }

 Script "DnD Blackout" (int victim) CLIENTSIDE {
	SetActivator(victim);

	int pnum = victim - P_TIDSTART;

	if(ConsolePlayerNumber() != pnum)
		Terminate;

	int d = DND_BLACKOUT_TIME;
	if(GetHelmID() == HELMS_SYNTHMETAL)
		d /= DND_SYNTHMASK_EFFECT;

	if(CheckInventory("BlackoutTimer"))
		SetInventory("BlackoutTimer", d);
	else {
		SetInventory("BlackoutTimer", d);

		SetHudsize(800, 600, 0);
		SetFont("NEARSEE");
		HudMessage(s:"A";  HUDMSG_PLAIN | HUDMSG_ALPHA, BLACKOUT_ID, CR_WHITE, 400.4, 300.0, 2.0, 1.0);

		d = 2 * TICRATE;
		if(GetHelmID() == HELMS_SYNTHMETAL)
			d /= DND_SYNTHMASK_EFFECT;

		Delay(d);

		int a = 1.0;
		int i = 0;
		while(isAlive() && (i = CheckInventory("BlackoutTimer"))) {
			SetHudsize(800, 600, 0);
			SetFont("NEARSEE");
			HudMessage(s:"A";  HUDMSG_PLAIN | HUDMSG_ALPHA, BLACKOUT_ID, CR_WHITE, 400.4, 300.0, 0.75, a);
			Delay(const:1);
			a = sin(0.25 * i / DND_BLACKOUT_TIME);
			TakeInventory("BlackoutTimer", 1);
		}

		HudMessage(s:""; HUDMSG_PLAIN, BLACKOUT_ID, 0, 0, 0, 0.01);
	}
 }

Script "DnD Face Tracer" (void) {
	int target = GetActorProperty(0, APROP_TRACERTID);
	int xdiff = GetActorX(target) - GetActorX(0);
	int ydiff = GetActorY(target) - GetActorY(0);
	SetActorProperty(0, APROP_SCORE, (360 * VectorAngle(xdiff, ydiff)) >> 16);
	SetActorPitch(0, VectorPitch(0, target, xdiff, ydiff, 8.0));
}

Script "DnD Doomguy Soul Pickup" (int val) {
	val = Clamp_Between(val / DND_DOOMGUY_HEALDIV, 1, DND_DOOMGUY_MAXHEAL);
	// setactivatortotarget is SHIT
	SetActivator(0, AAPTR_TARGET);
	ACS_NamedExecuteAlways("DnD Health Pickup", 0, val, 6, 0);
}

Script "DnD Init Shared Translation" (void) {
	Thing_SetTranslation(0, TRANSLATION_ICE);
	Delay(const:17);
	Thing_SetTranslation(0, DND_NO_TRANSLATION);
}

Script "DnD Disable Pickup" (int tid) {
	Thing_SetSpecial(tid, 0, 0, 0, 0);
	Thing_SetTranslation(tid, TRANSLATION_ICE);
	Delay(const:SHARED_ITEM_ACTIVITY_DELAY);
	// these are hardcoded into the engine, won't ever change prob.
	Thing_SetSpecial(tid, 226, DND_SHARED_ITEM_SCRIPT, 0, tid);
	Thing_SetTranslation(tid, DND_NO_TRANSLATION);
}

Script "DnD Budget Giver" (int amt) {
	GiveBudget(amt);
}

Script "DnD Punisher Perk50 Display" (void) CLIENTSIDE {
	if(PlayerNumber() != ConsolePlayerNumber())
		Terminate;

	while(!HasClassPerk_Fast("Punisher", 3)) {
		if(!IsAlive())
			Terminate;
		Delay(const:TICRATE);
	}

	int tmp = 0;
	int pnum = PlayerNumber();
	while(IsAlive() && PlayerInGame(pnum)) {
		SetFont("OBJFONT");
		SetHudSize(900, 600, 1);
		int x = (GetHudRight(900) << 16) - 5.8;
		int curr_tier = CheckInventory("Punisher_Perk50_Tiers");
		tmp = CheckInventory("Punisher_Perk50_Counter");
		
		HudMessage(l:"DND_CURRTIER", s:": \c[I7]", d:curr_tier, s:"\c- - \c[I7]", s:GetFixedRepresentation(CheckInventory("Punisher_Perk50_DamageBonus"), true), s:"%\c- more damage"; HUDMSG_PLAIN, PUNISHERPERKID1, -1, x, 450.0, 0.0);
		
		int req = CheckInventory("Punisher_Perk50_NextReq");
		if(curr_tier < DND_MAX_PUNISHER_PERK50_TIERS - 1)
			HudMessage(l:"DND_OBTAIN", s:" \c[I7]", f:(req - tmp) & 0xFFFFF000, s:"\c- ", l:"DND_POINTS", s: " ", l:"DND_FORBUFF"; HUDMSG_PLAIN, PUNISHERPERKID2, -1, x, 480.0, 0.0);
		else
			HudMessage(s:""; HUDMSG_PLAIN, PUNISHERPERKID2, -1, x, 480.0, 0.0);
		Delay(const:5);
	}

	HudMessage(s:""; HUDMSG_PLAIN, PUNISHERPERKID1, -1, x, 450.0, 0.0);
	HudMessage(s:""; HUDMSG_PLAIN, PUNISHERPERKID2, -1, x, 480.0, 0.0);
}

Script 1006 (int pnum) NET CLIENTSIDE {
	if(PlayerInGame(pnum)) {
		int tid = pnum + P_TIDSTART;
		int this = ActivatorTID();
		int i, j, temp, itype, isubt, cnt, val;
		
		Log(s:"\n================================\n====== ", l:"DND_PLAYERLOOKUP", s:" ======\n================================\n");
		SetActivator(tid);
		Log(s:"\cd", l:"DND_PLAYER", s:": \c-", n:pnum + 1, s:"\n\cd", l:"DND_STAT18", s:": \c-", d:CheckInventory("Level"));
		Log(s:"\cd", l:"DND_CLASS", s:": \c-", s:"\c[J7]", l:GetClassLabel(StrParam(s:"CLASS", d:CheckInventory("DnD_Character") - 1), DND_CLASS_LABEL_NAME));
		Log(s:"\cd", l:"IATTR_T0", s:": \c-", d:GetActorProperty(0, APROP_HEALTH), s: " / ", d:GetSpawnHealth());
		//Log(s:"\cd", l:"IATTR_T1", s:": \c-", d:GetArmorAmount(), s: " / ", d:GetArmorCapFromID(GetArmorID()));
		
		Log(s:"\n--------------------------------\n------- ", l:"DND_STATALLOCATION", s:" -------\n--------------------------------\n");
		Log(s:"\c[Y5]", l:"DND_STAT1", s:": \c-", d:GetStrength(pnum), s:"\n\c[Y5]", l:"DND_STAT2", s:": \c-", d:GetDexterity(pnum), s:"\n\c[Y5]", l:"DND_STAT3", s:": \c-", d:GetIntellect(pnum));
		
		Log(s:"\n--------------------------------\n------- ", l:"DND_PERKALLOCATION", s:" -------\n--------------------------------\n");
		for(i = 0; i < DND_MAX_PERKS; ++i)
			Log(s:"\c[Y5]", l:GetStatLabel(DND_PERK_BEGIN + i), s:": \c-", d:GetPerk(DND_PERK_BEGIN + i));
		
		Log(s:"\n--------------------------------\n------- ", l:"DND_MENU_ACCESSORIES", s:" -------\n--------------------------------\n");
		for(j = 0, i = 0; i < MAX_ACCESSORY && j < 2; ++i) {
			if(IsAccessoryEquipped(0, 1 << i)) {
				Log(s:"\c[Y5]", l:"DND_ACCESSORY", s:" ", d:(j + 1), s:": \c[C5]", s:AccessoryInfo[i][ACCESSORY_TAG]);
				++j;
			}
		}
		if(!j)
			Log(s:"\c[Y5]", l:"DND_ACCESSORY", s:" 1: \cuN/A\n\c[Y5]", l:"DND_ACCESSORY", s:" 2: \cuN/A");
		else if(j == 1)
			Log(s:"\c[Y5]", l:"DND_ACCESSORY", s:" 2: \cuN/A");
			
		Log(s:"\n--------------------------------\n------- ", l:"DND_WEPSOWNED", s:" -------\n--------------------------------\n");
		for(i = 0; i < MAXWEPS; ++i)
			if(CheckInventory(Weapons_Data[i].name))
				Log(s:"\cd* \c[Y5]", l:GetWeaponTag(i), s:" - \cj", l:"DND_MENU_SLOT", s:" ", d:GetGameSlotOfWeapon(i));
				
		Log(s:"\n--------------------------------\n------- ", l:"DND_MENU_HEAD_CHARMS", s:" -------\n--------------------------------\n");
		for(i = 0; i < MAX_ITEMS_EQUIPPABLE; ++i) {
			itype = Items_Used[pnum][i].item_type;
			isubt = Items_Used[pnum][i].item_subtype;
			if(itype != DND_ITEM_NULL) {
				if(itype == DND_ITEM_CHARM) {
					temp = GetItemSyncValue(pnum, DND_SYNC_ITEMLEVEL, i, -1, DND_SYNC_ITEMSOURCE_ITEMSUSED) / CHARM_ATTRIBLEVEL_SEPERATOR;
					Log(s:Charm_Strings[temp][CHARMSTR_COLORCODE], l:Charm_Strings[temp][CHARMSTR_TIERTAG], s: " ", l:GetItemTagName(DND_ITEM_CHARM, GetItemSyncValue(pnum, DND_SYNC_ITEMSUBTYPE, i, -1, DND_SYNC_ITEMSOURCE_ITEMSUSED)));
					temp = GetItemSyncValue(pnum, DND_SYNC_ITEMSATTRIBCOUNT, i, -1, DND_SYNC_ITEMSOURCE_ITEMSUSED);
					for(j = 0; j < temp; ++j)
						Log(s:"    ", s:GetItemAttributeText(GetItemSyncValue(pnum, DND_SYNC_ITEMATTRIBUTES_ID, i, j, DND_SYNC_ITEMSOURCE_ITEMSUSED), itype, isubt, GetItemSyncValue(pnum, DND_SYNC_ITEMATTRIBUTES_VAL, i, j, DND_SYNC_ITEMSOURCE_ITEMSUSED)));
				}
				else if(itype <= UNIQUE_BEGIN) {
					temp = GetItemSyncValue(pnum, DND_SYNC_ITEMLEVEL, i, -1, DND_SYNC_ITEMSOURCE_ITEMSUSED) / CHARM_ATTRIBLEVEL_SEPERATOR;
					Log(s:Charm_Strings[temp][CHARMSTR_COLORCODE], l:GetItemTagName(itype, GetItemSyncValue(pnum, DND_SYNC_ITEMSUBTYPE, i, -1, DND_SYNC_ITEMSOURCE_ITEMSUSED)));
					temp = GetItemSyncValue(pnum, DND_SYNC_ITEMSATTRIBCOUNT, i, -1, DND_SYNC_ITEMSOURCE_ITEMSUSED);
					for(j = 0; j < temp; ++j)
						Log(s:"    ", s:GetItemAttributeText(GetItemSyncValue(pnum, DND_SYNC_ITEMATTRIBUTES_ID, i, j, DND_SYNC_ITEMSOURCE_ITEMSUSED), itype, isubt, GetItemSyncValue(pnum, DND_SYNC_ITEMATTRIBUTES_VAL, i, j, DND_SYNC_ITEMSOURCE_ITEMSUSED)));
				}
				else {
					// unique case
					temp = itype & 0xFFFF;
					itype >>= UNIQUE_BITS;
					--itype;
					// itype holds unique position, temp is the actual item type
					Log(s:"\c[A1]", l:GetUniqueItemName(temp, itype), s:"\c- - \c[D1]", l:"DND_ITEM_UNIQUE", s:" ", l:GetItemTagName(temp, GetItemSyncValue(pnum, DND_SYNC_ITEMSUBTYPE, i, -1, DND_SYNC_ITEMSOURCE_ITEMSUSED)));
					cnt = GetItemSyncValue(pnum, DND_SYNC_ITEMSATTRIBCOUNT, i, -1, DND_SYNC_ITEMSOURCE_ITEMSUSED);
					// itype will count the skipped properties (the helper attributes)
					itype = 0;
					for(j = 0; j < cnt; ++j) {
						temp = GetItemSyncValue(pnum, DND_SYNC_ITEMATTRIBUTES_ID, i, j, DND_SYNC_ITEMSOURCE_ITEMSUSED);
						val = GetItemSyncValue(pnum, DND_SYNC_ITEMATTRIBUTES_VAL, i, j, DND_SYNC_ITEMSOURCE_ITEMSUSED);
						if(val >= 0)
							Log(s:"    ", s:GetItemAttributeText(temp, itype, isubt, val, 0));
						else
							Log(s:"    - ", s:GetItemAttributeText(temp, itype, isubt, val, 0));
					}
				}
			}
			else
				Log(s:"\cuN/A");
		}
		
		SetActivator(this);
	}
	else
		Log(s:"\cg", l:"DND_MENU_ERROR", s:": \cj", l:"DND_PLAYERNOTPLAYING", s:"!");
}

Script "DnD Heal Monster Direct" (int amount, int isPercent) {
	int mid = ActivatorTID() - DND_MONSTERTID_BEGIN;
	if(!isPercent)
		HealMonster(mid, amount);
	else
		HealMonster(mid, MonsterProperties[mid].maxhp * isPercent / 100);
}

Script "DnD Monster Heal Potency" (int base) {
	int this = ActivatorTID() - DND_MONSTERTID_BEGIN;
	int factor = Clamp_Between(MonsterProperties[this].level, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 1, 100);
	
	if(MonsterProperties[this].trait_list[DND_VITAL])
		factor <<= 1;
	
	base = base * (100 + factor) / 100;
	
	SetResultValue(base);
}

Script "DnD Monster Health Regen Script" (int style, int amount, int period) {
	// how many periods will be waited for this to end?
	int duration = style >> 16;
	int mid = ActivatorTID() - DND_MONSTERTID_BEGIN;
	style &= 0xFFFF;
	if(style == DND_MHR_DURATION) {
		while(duration) {
			if(!CheckInventory("MonsterRegenPause")) {
				HealMonster(mid, amount);
				--duration;
			}
			Delay(period);
		}
	}
	else if(style == DND_MHR_PERIODIC) {
		while(isAlive()) {
			if(!CheckInventory("MonsterRegenPause"))
				HealMonster(mid, amount);
			Delay(period);
		}
	}
}

// Needs to be here as it loops through monster tid variable which is changed through this part
Script "DnD Tcherno Corpse Explode" (void) {
	for(int mn = 0; mn < DnD_TID_Counter[DND_TID_MONSTER]; ++mn) {
		int i = UsedMonsterTIDs[mn];
		if(!isActorAlive(i) && fdistance(0, i) <= DREAMER_CORPSEEXPLOSION_DIST) {
			GiveActorInventory(i, "TchernoCorpseExploder", 1);
			ACS_NamedExecuteAlways("DnD Tcherno Corpse Explode Gib Giver", 0, i);
		}
	}
}

Script "DnD Tcherno Corpse Explode Gib Giver" (int i) CLIENTSIDE {
	Delay(const:TICRATE);
	GiveActorInventory(i, "TchernoCorpseExploder_Gibber", 1);
}

Script "DnD Item Linger Check" (void) {
	if(CheckInventory("DnD_NoLingerCheck") || GameType() == GAME_SINGLE_PLAYER)
		Terminate;

	int counter = 0;
	int sp = GetActorProperty(0, APROP_MASS) >> 16;
	int linger_time = Clamp_Between(GetCVar("dnd_lingertime"), 1, 65535);
	while(counter < linger_time) {
		++counter;
		Delay(const:TICRATE);
		// if this is picked up, terminate early
		if(Inventories_On_Field[sp].item_type == DND_ITEM_NULL)
			Terminate;
	}

	// not picked until now, remove it
	RemoveItemFromWorld(sp);
	Thing_Remove(0);
}

Script "DnD Taunt" (void) NET {
	// net => clientside setup ensures everyone hears it
	if(!PlayerInGame(PlayerNumber()) || GetActorProperty(0, APROP_HEALTH) <= 0 || CheckInventory("DnD_TauntCooldown"))
		Terminate;

	GiveInventory("DnD_TauntCooldown", 1);

	int ptype = CheckInventory("DnD_Character") - 1;
	ACS_NamedExecuteWithResult("DnD Play Taunt Sound", ptype);
}

Script "DnD Play Taunt Sound" (int pclass) CLIENTSIDE {
	str snd = "Doomguy/Taunt";
	switch(pclass) {
		case DND_PLAYER_MARINE:
			snd = "Marine/Taunt";
		break;
		case DND_PLAYER_HOBO:
			snd = "Hobo/Taunt";
		break;
		case DND_PLAYER_PUNISHER:
			snd = "Punisher/Taunt";
		break;
		case DND_PLAYER_WANDERER:
			snd = "Wanderer/Taunt";
		break;
		case DND_PLAYER_CYBORG:
			snd = "CyborgPlayer/Taunt";
		break;
		case DND_PLAYER_BERSERKER:
			snd = "BerserkerPlayer/Taunt";
		break;
		case DND_PLAYER_TRICKSTER:
			snd = "Trickster/Taunt";
		break;
	}
	
	PlaySound(0, snd, CHAN_BODY, 1.0);
}

Script "DnD Projectile Checks" (int isPet, int isExplosive) {
	int owner = !isPet ? GetActorProperty(0, APROP_TARGETTID) : ACS_NamedExecuteWithResult("DnD Get Master of Target");
	if(!IsPlayer(owner)) {
		SetResultValue(0);
		Terminate;
	}

	int pnum = owner - P_TIDSTART;
	int wepid = CheckActorInventory(owner, "DnD_WeaponID");

	// store owner
	SetActorProperty(0, APROP_SCORE, owner);
	
	// hack for crit store on burst fire projectiles -- they call this on their initialization phase so at this point we should be able to check the wepid
	if((wepid != -1 && GetPlayerWeaponCritState(pnum, wepid)) || CheckActorInventory(owner, "DnD_CritToken"))
		SetActorProperty(0, APROP_ACCURACY, DND_CRIT_TOKEN);
	
	if(CheckActorInventory(owner, "NetherCheck"))
		GiveInventory("ApplyNetherMaskBuff", 1);
	
	if(CheckUniquePropertyOnPlayer(pnum, PUP_IGNORERADIUSIMMUNITY) || (random(1, 100) < GetPlayerAttributeValue(pnum, INV_CHANCE_IGNORERADIUSIMMUNITY)))
		GiveInventory("ApplyForceRadiusDMG", 1);

	wepid = GetPlayerAttributeValue(pnum, INV_INC_PROJREVERSE);
	if(wepid)
		ACS_NamedExecuteAlways("DnD Proj Reverse Direction", 0, wepid);

	SetResultValue(0);
}

Script "DnD Proj Reverse Direction" (int wait_time) {
	wait_time = (wait_time * TICRATE) >> 16;
	Delay(wait_time);
	SetActorVelocity(0, -GetActorVelX(0), -GetActorVelY(0), -GetActorVelZ(0), 0, 0);
	SetActorAngle(0, GetActorAngle(0) - 0.5);
}

Script "DnD Check Crit" (void) {
	SetResultValue(GetActorProperty(0, APROP_ACCURACY) == DND_CRIT_TOKEN);
}

Script "DnD Set to Crit" (void) {
	SetActorProperty(0, APROP_ACCURACY, DND_CRIT_TOKEN);
	SetResultValue(0);
}

Script "DnD Rejuvenation" (void) {
	int id = ActivatorTID() - DND_MONSTERTID_BEGIN;
	
	// 5% every second
	int hp_per = MonsterProperties[id].maxhp / 20;
	if(!hp_per)
		hp_per = 1;
	
	while(isAlive()) {
		Delay(const:REJUV_TICS);
		
		// ignite effects prevent rejuvenation
		if(!CheckInventory("DnD_IgniteTimer") && GetActorProperty(0, APROP_HEALTH) != MonsterProperties[id].maxhp) {
			if(GetActorProperty(0, APROP_HEALTH) < MonsterProperties[id].maxhp - hp_per) {
				SetActorProperty(0, APROP_HEALTH, GetActorProperty(0, APROP_HEALTH) + hp_per);
				ACS_NamedExecuteAlways("DnD Rejuvenation FX CS", 0);
			}
			else
				SetActorProperty(0, APROP_HEALTH, MonsterProperties[id].maxhp);
		}
	}
}

Script "DnD Repel" (void) {
	// player R = 16.0
	int r = GetActorProperty(0, APROP_RADIUS) + 16.0;
	int p_tid;
	int this = ActivatorTID();
	
	while(true) {
		Delay(const:REPEL_REFRESH_RATE);
		
		if(!isAlive())
			break;

		// check all players to see if they are close to us
		for(int i = 0; i < MAXPLAYERS; ++i) {
			p_tid = i + P_TIDSTART;
			// added check for knockback immunity
			if
			(
				PlayerInGame(i) &&
				isActorAlive(p_tid) &&
				!CheckUniquePropertyOnPlayer(i, PUP_KNOCKBACKIMMUNE) &&
				AproxDistance(GetActorX(p_tid) - GetActorX(0), GetActorY(p_tid) - GetActorY(0)) <= REPEL_DISTANCE + r
				&& CheckSight(p_tid, 0, CSF_NOBLOCKALL)
			)
			{
				PushPlayerAway(p_tid, this, REPEL_FORCE, REPEL_FORCE / 2);
				ACS_NamedExecuteAlways("DnD Repel FX", 0);
				// repel will make it wait twice its duration for a total of 6 seconds
				Delay(const:REPEL_COOLDOWN);
				break;
			}
		}
	}
}

Script "DnD Phasing CS" (void) {
	SpawnForced("WhiteParticleSpawner", GetActorX(0), GetActorY(0), GetActorZ(0) + GetActorProperty(0, APROP_HEIGHT) / 2, 0);
}

Script "DnD Phasing" (void) {
	int a, m_id = ActivatorTID() - DND_MONSTERTID_BEGIN;
	SetActorProperty(0, APROP_RENDERSTYLE, STYLE_TRANSLUCENT);
	a = GetActorProperty(0, APROP_ALPHA);
	While(isAlive() && !CheckFlag(0, "GHOST")) {
		// wait while idle
		while(MonsterProperties[m_id].isIdle)
			Delay(const:TICRATE);

		Delay(TICRATE * random(1, 5));

		// if somehow already ghost here, kill the script, it acquired this through other means
		if(!isAlive() || CheckFlag(0, "GHOST") || MonsterProperties[m_id].trait_list[DND_GHOST])
			break;

		// make ghost
		GiveInventory("MakeGhost", 1);
		PlaySound(0, "PhaseIn", CHAN_AUTO, 1.0);
		ACS_NamedExecuteAlways("DnD Phasing CS", 0);
		a = GetActorProperty(0, APROP_ALPHA);
		if(a > 0.5)
			SetActorProperty(0, APROP_ALPHA, 0.5);

		Delay(TICRATE * random(1, 5));

		if(!isAlive())
			break;

		// unmake ghost
		GiveInventory("UnMakeGhost", 1);
		PlaySound(0, "PhaseOut", CHAN_AUTO, 1.0);
		ACS_NamedExecuteAlways("DnD Phasing CS", 0);
		SetActorProperty(0, APROP_ALPHA, a);
	}
	GiveInventory("UnMakeGhost", 1);
	SetActorProperty(0, APROP_ALPHA, a);
}

Script "DnD Cripple" (void) {
	int r = GetActorProperty(0, APROP_RADIUS) + 16.0;
	int p_tid;

	ACS_NamedExecuteAlways("DnD Aura Giver CS", 0, DND_CRIPPLE);
	
	while(isAlive()) {
		Delay(const:CRIPPLE_REFRESH_RATE);

		// check all players to see if they are close to us -- dont target players if we are friendly to them
		for(int i = 0; !CheckFlag(0, "FRIENDLY") && i < MAXPLAYERS; ++i) {
			p_tid = i + P_TIDSTART;
			if(PlayerInGame(i) && isActorAlive(p_tid)) {
				// 16.0 is player radius
				if(AproxDistance(GetActorX(p_tid) - GetActorX(0), GetActorY(p_tid) - GetActorY(0)) <= CRIPPLE_DISTANCE + r && CheckSight(p_tid, 0, CSF_NOBLOCKALL))
					GiveActorInventory(p_tid, "CrippleSlower", 1);
			}
		}
	}
}

Script "DnD Repel FX" (void) CLIENTSIDE {
	GiveInventory("RepelPulseFXSpawner", 1);
}

Script "DnD Rejuvenation FX CS" (void) CLIENTSIDE {
	GiveInventory("RejuvenationFX_Spawner", 1);
}

// checks if a monster is resurrectable and if so, resurrects and makes it a pet
Script "DnD Resurrect Checker" (int d, int this) {
	Delay(d);

	if(this == -1)
		this = ActivatorTID();
	//printbold(s:"res check on ", d:this);
	int id = this - DND_MONSTERTID_BEGIN;
	
	if(HasTrait(id, DND_SUMMONED) || HasTrait(id, DND_REVIVED))
		Terminate;
	
	int killer = MonsterProperties[id].killer_tid;
	//printbold(d:!CheckInventory("DnD_EnemySlatedForRemoval"), s: " ", d:CanActorHaveMorePets(killer), s: " ", d:IsMonsterCategoryResurrectable(id), s: " ", d:isPlayer(killer));
	if(!CheckInventory("DnD_EnemySlatedForRemoval") && CanActorHaveMorePets(killer) && IsMonsterCategoryResurrectable(id) && isPlayer(killer)) {
		// proceed to resurrect and make the master the player and mark this monster as a pet
		SetEliteFlag(DND_REVIVED, true);

		int tries = 0;
		while(!CanRaiseActor(this) && tries++ < 15)
			Delay(const:HALF_TICRATE);

		if(!CanRaiseActor(this))
			Terminate;

		//printbold(s:"yes we can!!");

		GiveActorInventory(this, "DnD_ResurrectMonster", 1);

		// set the killer as its owner now
		SetActorProperty(this, APROP_MASTERTID, killer);
		SetActorProperty(this, APROP_FRIENDLY, 1);
		SetActorProperty(this, APROP_SPECIES, "Player");
	}
}

Script "DnD Roll Proc" (int base, int owner_flags) {
	if(owner_flags & DND_WDMG_USETARGET)
		SetActivatorToTarget(0);

	base = (base << 16) / 100;
	SetResultValue(RunLuckBasedChance(PlayerNumber(), base, DND_LUCK_OUTCOME_GAIN));
}

Script "DnD Hurt Actor" (int hurter, int victim, int dmg) {
	SetActivator(hurter);
	Thing_Damage2(victim, dmg, "Normal");
}

Script "Dnd Pickup Setup" (void) {
	GivePickupTID();
}

Script "DnD Player WeaponPower Check" (int wepid, int power) {
	SetResultValue(HasWeaponPower(PlayerNumber(), wepid, power));
}

Script "DnD Get Player WeaponID" (void) {
	SetResultValue(GetCurrentWeaponID());
}

Script "DnD Bloodfiend Heal" (void) {
	int victim = GetActorProperty(0, APROP_TRACERTID);

	if(MonsterProperties[victim - DND_MONSTERTID_BEGIN].trait_list[DND_BLOODLESS])
		Terminate;

	SetActivatorToTarget(0);
	
	// 1% heal per pellet hitting
	ACS_NamedExecuteAlways("DnD Health Pickup", 0, GetSpawnHealth() / 100);
}

Script "DnD Kanji Detect" (void) {
	SetActivator(0, AAPTR_TARGET);
	GiveInventory("DnD_Boolean", 1);
	SetResultValue(0);
}

Script "DnD Kanji Explosion" (int x, int y, int z) {
	x <<= 16;
	y <<= 16;
	z <<= 16;
	SetActivator(0, AAPTR_TARGET);
	
	int owner = ActivatorTID();
	int tid = KANJI_TRAPEXP_TID + PlayerNumber();
	
	if(SpawnForced("DemonSealExplosion", x, y, z, tid)) {
		SetActivator(tid);
		Thing_ChangeTID(0, 0);
		SetActorProperty(0, APROP_TARGETTID, owner);
		SetPointer(AAPTR_TARGET, owner);
	}
	
	SetResultValue(0);
}

Script "DnD Remove Actor - CS" (void) CLIENTSIDE {
	SetActorState(0, "Remove", 0);
	SetResultValue(0);
}

Script "DnD Pain Immune Toggle" (int secs) {
	GiveInventory("MakeNoPain", 1);
	ACS_NamedExecuteWithResult("DnD Monster Trait Give", DND_NOPAIN, -1, -1, -1);
	Delay(TICRATE * secs);
	GiveInventory("TakeNoPain", 1);
	ACS_NamedExecuteWithResult("DnD Monster Trait Take", DND_NOPAIN, -1, -1, -1);
}

Script "DnD Ammo Token Pickup" (void) {
	// get random owned weapon of player and give ammo to it
	int id = 0;
	int pnum = PlayerNumber();
	do {
		id = PickRandomOwnedWeaponID(pnum);
	} while(Weapons_Data[id].ammo_name1 == "");

	// give 10% ammo on this weapon -- soulrender has weapon condition as ammo1 so dont give if it is 
	str ammo;
	int cap;
	
	if(id != DND_WEAPON_SOULRENDER) {
		ammo = Weapons_Data[id].ammo_name1;
		cap = GetAmmoCapacity(ammo);
		GiveInventory(ammo, cap / 10);
	}

	ammo = Weapons_Data[id].ammo_name2;
	if(ammo != "") {
		cap = GetAmmoCapacity(ammo);
		GiveInventory(ammo, cap / 10);
	}
	
	ACS_NamedExecuteAlways("DnD Ammo Token Message", 0, id);
}

Script "DnD Ammo Token Message" (int wepid) CLIENTSIDE {
	if(PlayerNumber() != ConsolePlayerNumber())
		Terminate;

	Log(s:"\ccAmmo pickup   : \c[Y5]+10% to ", l:GetWeaponTag(wepid));
}

Script "DnD Sync Actor Property" (int p_tid, int prop, int val) CLIENTSIDE {
	SetActorProperty(p_tid, prop, val);
}

Script "DnD Check Corpse Landing" (void) {
	int attempts = 0;
	while(attempts < DND_MAX_CORPSELAND_ATTEMPTS) {
		int mx = GetActorX(0), my = GetActorY(0), mz = GetActorZ(0);
		Delay(1);
		if(!isAlive() && abs(mz - GetActorZ(0)) <= DND_LAND_WINDOW) {
			SetActorState(0, "CorpseLand");
			break;
		}
		++attempts;
	}
}

Script "DnD Make Player Invuln" (void) {
	SetPlayerProperty(1, 2, PROP_INVULNERABILITY);
}

Script "DnD Generic Boss Loot" (int tier, int loc_tid, int time) {
	int boss_tid = ActivatorTID();
	int target = GetActorProperty(0, APROP_TARGETTID);

	if(!loc_tid)
		loc_tid = ActivatorTID();
		
	SetActivator(loc_tid);
	
	// when referring to the boss itself use the boss_tid!
	HandleLootDrops(boss_tid, target, false, loc_tid);

	// tier starts from 0 to 3 --- 0 is low tier boss, 1 is medium, 2 is high, 3 is end game boss
	SpawnOrbForAll(random(1 + tier / 2, tier + 1));
	
	if(tier >= 1) {
		// guaranteed charm drop from anything above medium, and a potential chest drop
		SpawnItemForAll(DND_ITEM_CHARM, 1, boss_tid - DND_MONSTERTID_BEGIN);
		
		// 33% chance to spawn a chest as well
		if(RunDefaultDropChance(target - P_TIDSTART, DND_BOSSCHEST_DROPRATE)) {
			if(tier == 3)
				SpawnDropAtActor(loc_tid, "DNDGoldChest", 0, 0, 0, 0);
			else if(tier == 2)
				SpawnDropAtActor(loc_tid, "DNDSilverChest", 0, 0, 0, 0);
			else
				SpawnDropAtActor(loc_tid, "DNDBronzeChest", 0, 0, 0, 0);
		}
	}
	
	bool exit_when_done = !!time;
	int start_time = time;
	int col = CR_GREEN;
	
	// in seconds before the map ends
	while(time) {
		SetHudSize(640, 480, 0);
		SetFont("DBIGFONT");
		
		if(time < start_time / 4)
			col = CR_RED;
		else if(time < start_time / 2)
			col = CR_ORANGE;
		else if(time < (start_time * 3) / 4)
			col = CR_YELLOW;
		
		HudMessageBold(s:"\cj", l:"DND_BOSS_LEVELENDSIN", s:":\c- ", d:time; HUDMSG_FADEOUT, MONSTER_TYPEICONID, col, 320.4, 0.1, EXIT_HOLDTIME);
		--time;
		Delay(const:TICRATE);
	}
	
	// exit script -- forced exit
	if(exit_when_done) {
		// setup the activator -- this is the boss so it isnt aware of the player
		int this;
		for(int i = 0; i < MAXPLAYERS; ++i) {
			if(PlayerInGame(i) && IsActorAlive(i + P_TIDSTART)) {
				this = i + P_TIDSTART;
				break;
			}
		}
		
		SetActivator(this);
	
		ACS_ExecuteAlways(255, 0, 0, 1);
	}
}

Script "DnD Request Level Info" (int val) {
	// as of adding this, these are legal values --- there can be more in future, check DnD_Common.h
	/*#define PLAYERLEVELINFO_LEVEL 0
	#define PLAYERLEVELINFO_MINLEVEL 1
	#define PLAYERLEVELINFO_MAXLEVEL 2
	#define PLAYERLEVELINFO_COUNTATSTART 3
	#define PLAYERLEVELINFO_TIDMONSTER 4*/
	if(val > MAX_PLAYERLEVELINFO_DATA - 1)
		val = MAX_PLAYERLEVELINFO_DATA - 1;
	SetResultValue(PlayerInformationInLevel[val]);
}

// start and end converted to 0.01 scale, total_time is the time this transition takes, max_reach_time is the time it takes to maximum fade in value
Script "DnD Fade Effect" (int start, int end, int total_time, int max_reach_time) {
	start *= 0.01;
	end *= 0.01;

	for(int i = 0; i < total_time; ++i) {
		int c = i < max_reach_time ? i : max_reach_time;
		SetActorProperty(0, APROP_ALPHA, GetActorProperty(0, APROP_ALPHA) + start * (max_reach_time - c) / max_reach_time + end * c / max_reach_time);
		Delay(const:1);
	}

	SetResultValue(0);
}

Script "DnD Temp Ignore Toggle" (int pnum, int val) NET {
	if(val)
		GiveInventory("DnD_NoTempPickup", 1);
	else
		TakeInventory("DnD_NoTempPickup", 1);
}

Script 1007 (void) NET CLIENTSIDE {
	SetCVar("dnd_detailedmods", !GetCVar("dnd_detailedmods"));
	
	// so the toggle is changed on the menu if you press it while in help page for some reason... you are weird if you do this!
	GiveInventory("DnD_RefreshPane", 1);
}

Script 1691 (int tag, int mode) {
	if(IsPlayer(ActivatorTID()))
		GiveInventory("BossBrainProtection", 1);
	
	// 2 = line, 1 = nofog
	if(mode == 3)
		Teleport_Line (tag, tag, 1);
	else if(mode == 2)
		Teleport_Line (tag, tag, 0);
	else if(mode == 1)
		Teleport_NoFog(0, 0, tag, 1);
	else
		Teleport(0, tag);
}

/*Script 69 (void) NET {
	SetInventory("Level", 98);
	SetInventory("Exp", GetExpLimit() / 2);
	SetInventory("LevelExpCap", GetExpLimit());
	CalculateExpRatio();
}

Script 70 (void) NET {
	GiveInventory("Exp", 200000);
	GiveInventory("LevelUpChecker", 1);
	CalculateExpRatio();
}*/

/*Script "Print Loc" (void) {
	printbold(f:GetActorX(0), s: " ", f:GetActorY(0), s: " ", f:GetActorZ(0));
	SetResultValue(0);
}

Script "test" (void) {
	printbold(s:"yes");
}*/

Script 68 (int x) NET {
	// this will activate if its not a debug build, which will check only allow use of this when its not a database saved mode
	#ifdef ISDEBUGBUILD
	int temp;
		//if(!isSoftorHardcore() && (GetCVar("dnd_mode") == DND_MODE_NORMAL))
	{
		int i;
		if(x < MAX_RESEARCHES) {
			GiveResearch(x, true);
			CompleteResearch(x);
		}
		else if(x == 32768) {

			SpawnSpecificOrbForAll(DND_ORB_ASSIMILATION, 1);
			SpawnSpecificOrbForAll(DND_ORB_PHANTASMAL, 1);
			SpawnSpecificOrbForAll(DND_ORB_HOLLOW, 1);
		}
		else if(x == 400) {
			GiveInventory("Punisher_Perk50_Counter", 125);
			ACS_NamedExecuteAlways("DnD Punisher Perk50 Display", 0, false);
		}
		else if(x == 401) {
			SpawnResearch(0, true);
		}
		else if(x == 402) {
			HandleShadowClone(0, ActivatorTID(), 15);
		}
		else if(x == 403) {
			for(i = 0; i < MAXPLAYERS; ++i) {
				temp = i + P_TIDSTART;
				if(PlayerInGame(i) && isActorAlive(temp)) {
					// getspawnhealth needs current activator, this wasn't using it
					SetActivator(temp);
					SpawnDrop("LootChest_ForPlayer", 0, 0, i + 1, 0);
					GiveActorInventory(temp, "DnD_BonusBonusShower", 1);
					SetActivator(-1);
				}
			}
		}
		else if(x == 420) {
			//Log(s:"charm");
			SpawnCharm(0, true);
			//SpawnCharm(0, true);
			//Log(s:"armor");
			SpawnArmor(0, true, 0);
			//Log(s:"pcore");
			SpawnPowercore(0, true);
			//Log(s:"orb");
			SpawnSpecificOrb(PlayerNumber(), DND_ORB_CORRUPT, true, true, 100);
			//SpawnSpecificOrb(PlayerNumber(), DND_ORB_ASSIMILATION, true, true, 100);
			//SpawnSpecificOrb(PlayerNumber(), DND_ORB_ORDER, true, true, 100);
			//SpawnSpecificOrb(PlayerNumber(), DND_ORB_PRISMATIC, true, true, 100);
			//SpawnToken(0, true);
			//Log(s:"boot");
			SpawnBoot(0, 0);
			//Log(s:"helm");
			//SpawnHelm(0, 0);
			//SpawnOrbForAll(1, random(300, 500));
			//SpawnChestKey(0);
			SpawnCharmWithMods_ForAll(INV_INC_PROJREVERSE);
			//SpawnCharmWithMods_ForAll(INV_INC_PLUSPROJ);
			//SpawnCharmWithMods_ForAll(INV_DAMAGEPERCENT_MORE);
			/*SpawnSpecificOrb(PlayerNumber(), DND_ORB_ELEVATION, true, false, 300);
			//SpawnArmor(0, 0, -BODYARMOR_LIGHTNINGCOIL);
			IncPlayerModValue(0, INV_PROJSPEED, 0.25);*/
			//IncPlayerModValue(0, INV_CORR_INSTALEECHPCT, 15);
			//IncPlayerModValue(0, INV_LIFESTEAL, 1.6);
			//IncPlayerModValue(0, INV_LIFESTEAL_DAMAGE, 0.05);
			//SpawnSpecificOrb(PlayerNumber(), DND_ORB_TURMOIL, true, true, 100);
			//SpawnSpecificOrb(PlayerNumber(), DND_ORB_POTENCY, true, true, 100);
			/*SpawnSpecificOrb(PlayerNumber(), DND_ORB_CORRUPT, true);
			SpawnSpecificOrb(PlayerNumber(), DND_ORB_CORRUPT, true);
			SpawnSpecificOrb(PlayerNumber(), DND_ORB_CORRUPT, true);*/
			//IncPlayerModValue(0, INV_ESS_KRULL, 50);
			//IncPlayerModValue(0, INV_LIFESTEAL, 0.875);
			//IncPlayerModValue(0, INV_ACCURACY_INCREASE, 500);
			//SpawnSpecificOrbForAll(DND_ORB_ENHANCE, 5);
			//SpawnSpecificOrbForAll(DND_ORB_SIN, 5);
			//SpawnCharmWithMods_ForAll(INV_LIFESTEAL);
			//PlayerModValues[0][INV_CRITCHANCE_INCREASE] = 0.25;
			//SpawnCharmWithMods_ForAll(INV_ESS_ZRAVOG);
			//SpawnSpecificOrbForAll(DND_ORB_WISDOM, 1);
			//SpawnCharmWithMods_ForAll(INV_RIPDAMAGE, INV_RIPCOUNT);
			//SpawnCharmWithMods_ForAll(INV_CHANCE_FLATIGNITE, INV_CHANCE_FLATPROLIF);
			/*SpawnCharmWithMods_ForAll(INV_CRITCHANCE_INCREASE);
			SpawnSpecificOrb(PlayerNumber(), DND_ORB_CORRUPT, true);
			SpawnSpecificOrb(PlayerNumber(), DND_ORB_CORRUPT, true);
			SpawnSpecificOrb(PlayerNumber(), DND_ORB_CORRUPT, true);
			SpawnSpecificOrb(PlayerNumber(), DND_ORB_CORRUPT, true);
			SpawnCharmWithMods_ForAll(INV_CRITPERCENT_INCREASE);
			SpawnCharmWithMods_ForAll(INV_DAMAGEPERCENT_MORE);
			SpawnCharmWithMods_ForAll(INV_LIFESTEAL_DAMAGE);
			SpawnCharmWithMods_ForAll(INV_ESS_ERYXIA);*/
			/*SpawnSpecificOrbForAll(DND_ORB_CORRUPT, 25);
			SpawnSpecificOrbForAll(DND_ORB_SIN, 25);
			SpawnSpecificOrbForAll(DND_ORB_ENHANCE, 5);*/

			ACS_NamedExecuteWithResult("DnD Handle Attribute Sync", PlayerNumber(), false);
		}
		else if(x == 450) {
			GiveInventory("PerkPoint", 10);
			UpdateActivity(PlayerNumber(), DND_ACTIVITY_PERKPOINT, 10, 0);
			GiveInventory("PerkedUp", 1);

			GiveInventory("AttributePoint", 25);
			UpdateActivity(PlayerNumber(), DND_ACTIVITY_ATTRIBUTEPOINT, 25, 0);
		}
		else if(x == 451)
			SpawnDrop("ResearchModule_MP", 24.0, 16, 1, random(0, 50));
		else if(x == 500) {
			IncPlayerModValue(PlayerNumber(), INV_SHIELD_INCREASE, 1000);
			IncPlayerModValue(PlayerNumber(), INV_SHIELD_RECHARGEDELAY, 100);
			HandleEShieldChange(PlayerNumber(), 0);
		}
		else if(x == 501)
			SetPlayerModValue(PlayerNumber(), INV_PELLET_INCREASE, 2 * PlayerModValues[PlayerNumber()][INV_PELLET_INCREASE] + 1.0);
		else if(x == 502) {
			IncPlayerModValue(PlayerNumber(), INV_ACCURACY_INCREASE, 1000);
			IncPlayerModValue(PlayerNumber(), INV_ESS_OMNISIGHT2, 10);
			CalculatePlayerAccuracy(PlayerNumber());
		}
		else if(x == 599)
			ACS_NamedExecuteWithResult("DnD Hud Animation", DND_ANIM_DOOMGUYPUNCH);
		else if(x == 600)
			ACS_NamedExecuteWithResult("DnD Hud Animation", DND_ANIM_DOOMGUYKICK);
		else if(x == 666)
			ACS_NamedExecuteAlways("DnD Cyborg Visor Anim", 0);
		else if(x == 667)
			ACS_NamedExecuteAlways("DnD Marine Shield Anim", 0);
		else {
			int c = CreateItemSpot();
			//i = random(UITEM_ELEMENTALBULWARK, UITEM_PAINMASTER);
			i = UITEM_UNITY;
			MakeUnique(c, DND_ITEM_CHARM, 0);
			SpawnDrop("UniqueCharmDrop", 16.0, 16, 1, c);
			
			SyncItemData(0, c, DND_SYNC_ITEMSOURCE_FIELD, -1, -1);
			ACS_NamedExecuteAlways("DnD Play Local Item Drop Sound", 0, 0, DND_ITEM_CHARM);
		}
	}
	#endif
}

/*Script "DnD Buff Test" ENTER {
	if(GetGameModeState() == GAMESTATE_COUNTDOWN)
		Terminate;

	int pnum = PlayerNumber();

	Log(s:"starting speed factor ", f:GetPlayerSpeed(pnum));

	Delay(105);

	GivePlayerBuff(pnum, ActivatorTID(), BUFF_SLOW, 0.2, BUFF_F_PLAYERSOURCE); // 0

	LogBuffList(pnum);
	Delay(105);

	GivePlayerBuff(pnum, ActivatorTID(), BUFF_SLOW, 0.2, BUFF_F_PLAYERSOURCE | BUFF_F_MORETYPE); // 1

	LogBuffList(pnum);
	Delay(105);

	GivePlayerBuff(pnum, ActivatorTID(), BUFF_SLOW, 0.3, BUFF_F_PLAYERSOURCE); // 2
	GivePlayerBuff(pnum, ActivatorTID(), BUFF_SLOW, 0.4, BUFF_F_PLAYERSOURCE); // 3

	LogBuffList(pnum);
	Delay(105);

	RemoveBuff(pnum, 2);

	LogBuffList(pnum);
	Delay(105);

	RemoveBuff(pnum, 0);

	LogBuffList(pnum);
	Delay(105);

	GivePlayerBuff(pnum, ActivatorTID(), BUFF_SLOW, 0.4, BUFF_F_PLAYERSOURCE | BUFF_F_MORETYPE, 10);
	GivePlayerBuff(pnum, ActivatorTID(), BUFF_SLOW, 0.2, BUFF_F_PLAYERSOURCE | BUFF_F_MORETYPE, 30);

	LogBuffList(pnum);
	Delay(TICRATE * 10 + 5);

	LogBuffList(pnum);
	Delay(TICRATE * 20 + 5);
	LogBuffList(pnum);

	Delay(105);

	RemoveBuff(pnum, 1);
	LogBuffList(pnum);

	Delay(105);

	RemoveBuff(pnum, 3);
	LogBuffList(pnum);
}*/

// experiment to check how evenly distributed the random attributes are
/*Script "Experiment" ENTER {
	int i;
	static int bins[KEY_PRIME];
	for(i = 0; i < KEY_PRIME; ++i)
		bins[i] = 0;
	
	int lim = DND_MONSTERTID_BEGIN + DND_MAX_MONSTERS;
	
	for(i = 0; i < lim; ++i) {
		if(random(0, 1))
			++bins[random(DND_MONSTERTID_BEGIN, lim) % KEY_PRIME];
		else
			++bins[random(0, 999) % KEY_PRIME];
	}
		
	Log(s:"checking collisions");
	for(i = 0; i < NORMAL_ATTRIBUTE_COUNT; ++i) {
		if(bins[i] > 1)
			Log(s:"collision on ", d:i, s:": ", d:bins[i]);
	}
}*/

#include "DnD_ClassScripts.h"