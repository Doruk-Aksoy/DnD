#library "DND"
#include "zcommon.h"
#nocompact

#include "DnD_Defs.h"
#include "DnD_MonsterData.h"
#include "DnD_Shared.h"
#include "DnD_Orbs.h"
#include "DnD.h"

// this is here for convenience, tracks if a legendary monster was spawned
bool MadeLegendary = 0;

Script 700 ENTER CLIENTSIDE {
	int hp, hpcomp, armor, armcomp, acomp, curammo;
	str ammo, ammoalt;
	while(IsAlive()) {
		if(GetCVar("dnd_killspree"))
			GiveInventory("KillSpreeOn", 1);
		hpcomp = GetSpawnHealth();
		hp = GetActorProperty(0, APROP_HEALTH);
		SetInventory("P_HealthCap", hpcomp);
		if(hp > hpcomp) {
			SetInventory("HPOverAmount", hp - hpcomp);
			GiveInventory("HPOver100", 1);
			TakeInventory("HPNormal", 1);
			TakeInventory("HPBelow50", 1);
			TakeInventory("HPBelow25", 1);
		}
		else if(hp > (hpcomp >> 1) - 1) {
			SetInventory("HPOverAmount", 0);
			TakeInventory("HPOver100", 1);
			GiveInventory("HPNormal", 1);
			TakeInventory("HPBelow50", 1);
			TakeInventory("HPBelow25", 1);
		}
		else if(hp > (hpcomp >> 2) - 1) {
			SetInventory("HPOverAmount", 0);
			TakeInventory("HPOver100", 1);
			TakeInventory("HPNormal", 1);
			GiveInventory("HPBelow50", 1);
			TakeInventory("HPBelow25", 1);
		}
		else {
			SetInventory("HPOverAmount", 0);
			TakeInventory("HPOver100", 1);
			TakeInventory("HPNormal", 1);
			TakeInventory("HPBelow50", 1);
			GiveInventory("HPBelow25", 1);
		}
		
		armor = CheckInventory("Armor");
		armcomp = GetArmorSpecificCap(ArmorBaseAmounts[CheckInventory("DnD_ArmorType") - 1]);
		SetInventory("P_ArmorCap", armcomp);
		if(armor > armcomp) { // can happen with armor bonuses
			SetInventory("ARMOverAmount", armor - armcomp);
			GiveInventory("ARMOver100", 1);
			TakeInventory("ARMNormal", 1);
			TakeInventory("ARMBelow50", 1);
			TakeInventory("ARMBelow25", 1);
		}
		else if(armor >= armcomp >> 1) {
			SetInventory("ARMOverAmount", 0);
			TakeInventory("ARMOver100", 1);
			GiveInventory("ARMNormal", 1);
			TakeInventory("ARMBelow50", 1);
			TakeInventory("ARMBelow25", 1);
		}
		else if(armor >= armcomp >> 2) {
			SetInventory("ARMOverAmount", 0);
			TakeInventory("ARMOver100", 1);
			TakeInventory("ARMNormal", 1);
			GiveInventory("ARMBelow50", 1);
			TakeInventory("ARMBelow25", 1);
		}
		else {
			SetInventory("ARMOverAmount", 0);
			TakeInventory("ARMOver100", 1);
			TakeInventory("ARMNormal", 1);
			TakeInventory("ARMBelow50", 1);
			GiveInventory("ARMBelow25", 1);
		}
			
		if(((Timer() * 98) / (100 * TICRATE)) < GetLevelInfo(LEVELINFO_PAR_TIME))
			GiveInventory("H_UnderPar", 1);
		else
			TakeInventory("H_UnderPar", 1);

		if(GetLevelInfo(LEVELINFO_KILLED_MONSTERS) == GetLevelInfo(LEVELINFO_TOTAL_MONSTERS))
			GiveInventory("H_KillsAchieved", 1);
		else
			TakeInventory("H_KillsAchieved", 1);

		if(GetLevelInfo(LEVELINFO_FOUND_ITEMS) == GetLevelInfo(LEVELINFO_TOTAL_ITEMS))
			GiveInventory("H_ItemsAchieved", 1);
		else
			TakeInventory("H_ItemsAchieved", 1);

		if(GetLevelInfo(LEVELINFO_FOUND_SECRETS) == GetLevelInfo(LEVELINFO_TOTAL_SECRETS))
			GiveInventory("H_SecretsAchieved", 1);
		else
			TakeInventory("H_SecretsAchieved", 1);
			
		if(GetCVar("sv_infiniteammo"))
            GiveInventory("H_InfiniteAmmo", 1);
        else
            TakeInventory("H_InfiniteAmmo", 1);
		
		ammo = GetWeaponAmmoType(GetCurrentWeaponID(), 0);
		if(StrCmp(" ", ammo)) { // if uses ammo
			acomp = GetAmmoCapacity(ammo);
			curammo = CheckInventory(ammo);
			if(curammo > (acomp + 1) / 2) {
				GiveInventory("H_PrimaryGreen", 1);
				TakeInventory("H_PrimaryYellow", 1);
				TakeInventory("H_PrimaryRed", 1);
			}
			else if(curammo > Max(acomp / 4, 1)) {
				TakeInventory("H_PrimaryGreen", 1);
				GiveInventory("H_PrimaryYellow", 1);
				TakeInventory("H_PrimaryRed", 1);	
			}
			else {
				TakeInventory("H_PrimaryGreen", 1);
				TakeInventory("H_PrimaryYellow", 1);
				GiveInventory("H_PrimaryRed", 1);		
			}
		}
		
		ammoalt = GetWeaponAmmoType(GetCurrentWeaponID(), 1);
		if(StrCmp(" ", ammoalt) && StrCmp(ammoalt, ammo)) { // if uses altammo and is not same as normal ammo
			acomp = GetAmmoCapacity(ammoalt);
			curammo = CheckInventory(ammoalt);
			if(curammo > (acomp + 1) / 2) {
				GiveInventory("H_SecondaryGreen", 1);
				TakeInventory("H_SecondaryYellow", 1);
				TakeInventory("H_SecondaryRed", 1);
			}
			else if(curammo > Max(acomp / 4, 1)) {
				TakeInventory("H_SecondaryGreen", 1);
				GiveInventory("H_SecondaryYellow", 1);
				TakeInventory("H_SecondaryRed", 1);	
			}
			else {
				TakeInventory("H_SecondaryGreen", 1);
				TakeInventory("H_SecondaryYellow", 1);
				GiveInventory("H_SecondaryRed", 1);		
			}
		}
		Delay(const:1);
	}
}

Script 701 OPEN CLIENTSIDE {
	while(1) {
		if(GameType() != GAME_SINGLE_PLAYER) {
			if(!GetCVar("compat_clientssendfullbuttoninfo"))
				Log(s:"\cgWARNING:\c- Please activate '\cdcompat_clientssendfullbuttoninfo\c-' in order to use the menu properly.");
			if(GetCVar("sv_weapondrop"))
				Log(s:"\cgWARNING:\c- Please deactivate '\cdsv_weapondrop\c-'. It breaks mod rules!");
		}
		Delay(35);
	}
}

Script "DnD On Map Load" OPEN {
	// empty translation
	CreateTranslation(DND_NO_TRANSLATION);
	CreateTranslation(DND_CRIT_TRANSLATION, 160:160=175:175);
	
	// init vars
	ResetSharedVariables();
	
	while(GetGameModeState() != GAMESTATE_INPROGRESS)
		Delay(const:TICRATE);
	CalculateMapDifficulty();
	// wait while total level is not initialized
	while(!PlayerInformationInLevel[PLAYERLEVELINFO_LEVEL])
		Delay(const:TICRATE);
	Delay(const:TICRATE);
	if (GetLevelInfo(LEVELINFO_LEVELNUM) != 99) //Prevents quests from firing on VR map (Lexicon) - compendium hubmap can't be detected this way unfortunately.
		PickQuest();
}

Script "DND Check Hardcore Softcore" OPEN {
	while(1) {
		if((GetCVar("dnd_mode") >= DND_MODE_SOFTCORE) && (GameType() != GAME_SINGLE_PLAYER))
			HardcoreSet = CheckHardcoreSettings();
		Delay(const:105);
	}
}

// Basically shut the menu down
Script "DnD On Death" DEATH {
	int i, pnum = PlayerNumber();
	PlayerDied[pnum] += 1;
	if(GetCVar("Survival")) //put this at the beginning to prevent the rare last second lvl 1 char auto-load bug.
		if(!CheckInventory("CurrentLives")) {
			PlayerLoaded[pnum] = 0;
			PlayerWillBeSaved[pnum] = false;
			PlayerTransferred[pnum] = false;
			PlayerCanLoad[pnum] = 0;
	}
			
	GiveInventory("DnD_PDead", 1);
	Thing_ChangeTID(0, 0);
	SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
	TakeInventory("P_Frozen", 1);
	StatListOpened[pnum] = 0;
	SetInventory("ShowingMenu", 0);
	SetInventory("MenuOption", 5);
	SetInventory("MenuPosX", 0);
	SetInventory("MadeChoice", 0);
	SetInventory("DnD_PopupId", 0);
	SetInventory("Punisher_Perk50_Counter", 0); // reset earned bonuses on death
	
	TakeInventory("DnD_ShowPopup", 1);
	TakeInventory("DnD_ShowSellPopup", 1);
	TakeInventory("DnD_SellConfirm", 1);
	//SetInventory("MenuPosY", 5);
	ACS_NamedExecuteAlways("DND Menu Cleanup", 0);
	BreakTradesBetween(pnum);

	if(GetCVar("Survival")) {
		if(CheckInventory("CurrentLives"))
			TakeInventory("CurrentLives", 1);
		else {
			// if player was in middle of saving, don't accidently interfere if player leaves early
			// save accumulated stats when player leaves
			// things saved are in DnD_Activity.h

			if(GetCVar("dnd_mode") == DND_MODE_HARDCORE) {
				ACS_NamedExecuteAlways("DND Database Reset On Death", 0, pnum);
				ResetPlayerActivities(pnum, false);
			} else if(GetCVar("dnd_mode") == DND_MODE_SOFTCORE)
				ACS_NamedExecuteAlways("DnD Save Player Orb and Stat Data", 0, pnum);
		}
	}
	
	// Precious Life check
	if(active_quest_id == QUEST_NODYING) {
		// fail for all players in the game
		for(i = 0; i < MAXPLAYERS; ++i)
			if(PlayerInGame(i) && isActorAlive(i + P_TIDSTART))
				FailQuest(i + P_TIDSTART);
		active_quest_id = -1; // completely remove this quest from everyone now
	}
	
	ACS_NamedExecuteAlways("DnD Punisher Perk50 Display", 0, true);
}

Script "DnD Portable Kit Script" (void) {
	int healthcap = GetSpawnHealth();
	int bonus = GetHealingBonuses();
	int amt = healthcap / 100;
	amt = amt * (100 + bonus) / 100;
	while(GetActorProperty(0, APROP_HEALTH) < healthcap && CheckInventory("StoredMedkit")) {
		TakeInventory("StoredMedkit", 1);
		GiveInventory("HealthBonusX", amt);
		GiveInventory("DnD_MasterHealerQuest_HealAmount", amt);
	}
}

// Health Kits Script (Used by Portable Medikits as well, ported here)
Script "DnD Health Pickup" (int amt, int isspecial, int useTarget) {
	if(useTarget)
		SetActivatorToTarget(0);
	int curhp = GetActorProperty(0, APROP_HEALTH);
	int healthcap = GetSpawnHealth();
	int bonus = GetHealingBonuses();
	// holds the old amt
	int toGive = amt, base = amt;
	// the percentage of spawn health is amt to be given
	amt = healthcap * amt / 100;
	// consider healing bonuses from quests
	amt = amt * (100 + bonus) / 100;
	
	// health bonus
	if(isspecial == 5) {
		GiveInventory("HealthBonusX", amt);
		GiveInventory("DnD_MasterHealerQuest_HealAmount", amt);
		GiveInventory("Research_Body_Hp_1_Tracker", amt);
		Terminate;
	}
	
	// map toast heal
	if(isspecial == 4) {
		if(GetActorProperty(0, APROP_HEALTH) < healthcap)
			SetActorProperty(0, APROP_HEALTH, healthcap);
		Terminate;
	}
	if(isspecial == 3) {
		amt = healthcap - curhp;
	    GiveInventory("HealthBonusX", amt);
		GiveInventory("DnD_MasterHealerQuest_HealAmount", amt);
		GiveInventory("Research_Body_Hp_1_Tracker", amt);
	    Terminate;
	}
	else if(isspecial == 2) { // ubersphere / megasphere
		toGive /= 100; // get the multiplier for mega / uber
		toGive = healthcap * toGive - curhp;
	}
	else if(isspecial == 1)
		toGive = amt + healthcap - curhp;
	else // for anything else (stims, medkits etc)
	    toGive = healthcap - curhp;
	
	if(toGive > amt)
		toGive = amt;
	
	if(CheckResearchStatus(RES_MEDKITSTORE) == RES_DONE && !isspecial) {
		if(curhp < healthcap) { // if my current curhp is less than max
			GiveInventory("HealthBonusX", toGive);
			GiveInventory("DnD_MasterHealerQuest_HealAmount", toGive);
			GiveInventory("Research_Body_Hp_1_Tracker", toGive);
		}
        if(toGive < amt)
            GiveInventory("StoredMedkit", Clamp_Between(amt - toGive, 1, base));
	}
	else {
		GiveInventory("HealthBonusX", toGive);
		GiveInventory("DnD_MasterHealerQuest_HealAmount", toGive);
		GiveInventory("Research_Body_Hp_1_Tracker", toGive);
	}
	
	HandleHealDependencyCheck();
}

Script "DnD Can Pick Health Item" (int type) {
	if (CheckInventory("CanLoad"))
		SetResultValue(-1);
	else
		SetResultValue(CanPickHealthItem(type));
}
// Health kits end here

Script "DnD Critical Input Handler" ENTER {
	bool temp = false;
	int pnum = PlayerNumber();
    while(PlayerInGame(pnum)) {
		if(GetPlayerInput(-1, INPUT_BUTTONS) & BT_USE)
			GiveInventory("DnD_PressedUse", 1);
			
		// additional hack for the slayer/hells maw weapon's dynamic fire modes	
		if(!CheckInventory("ShowingMenu")) {
			// shit hacks to prevent some bug...
			if(temp) {
				GiveInventory("HellsMawSynthActive", 1);
				GiveInventory("SynthFireFix", 1);
				temp = false;
			}
			
			if(CheckWeapon("Upgraded Super Shotgun3") && CheckInventory("HellsMawSynthActive")) {
				if(GetPlayerInput(-1, INPUT_BUTTONS) & BT_ATTACK) 
					GiveInventory("HellsMawSynthFireLeft", 1);
				else 
					TakeInventory("HellsMawSynthFireLeft", 1);
				
				if (GetPlayerInput(-1, INPUT_BUTTONS) & BT_ALTATTACK) 
					GiveInventory("HellsMawSynthFireRight", 1);
				else 
					TakeInventory("HellsMawSynthFireRight", 1);
					
				if(isAlive() && (CheckInventory("HellsMawFiringRight") || CheckInventory("HellsMawFiringLeft")))
					SetActorState(0, "Melee");
			}
			
			if((GetPlayerInput(-1, INPUT_BUTTONS) & BT_ALTATTACK)) {
				if(CheckWeapon("Slayer") && !CheckInventory("SlayerTimer"))
					GiveInventory("SlayerBack", 1);
				if(CheckWeapon("ResSSG3") && CheckInventory("HadesBurstFired") && !CheckInventory("HadesBurstTimer")) {
					GiveInventory("MakeHadesBurst", 1);
					GiveInventory("HadesBurstCooldown", 1);
					TakeInventory("HadesBurstFired", 1);
				}
			}
		}
		else {
			if(!temp && CheckWeapon("Upgraded Super Shotgun3")) {
				temp = true;
				TakeInventory("HellsMawSynthActive", 1);
			}
		}
		
        SetInventory("MedkitItem", CheckInventory("StoredMedKit"));
        SetInventory("DnD_PrevHealth", GetActorProperty(0, APROP_HEALTH));
        TakeInventory("FadeIntensity", 1);
		
		// had enough of armor fucking up
		if(!CheckInventory("Armor"))
			SetInventory("DnD_ArmorType", 0);
		
        Delay(const:1);
    }
	TakeInventory("HellsMawSynthFireLeft", 1);
	TakeInventory("HellsMawSynthFireRight", 1);
}

// from woc
Script 826 (int opt) {
    int intensity, maxhp = GetSpawnHealth();
    int diff = FixedDiv((100 * (CheckInventory("DnD_PrevHealth") - GetActorProperty(0, APROP_Health)) << 16), maxhp << 16);
    if(CheckInventory("FadeIntensity"))
        intensity = (CheckInventory("FadeIntensity") << 16) + diff;
    else
        intensity = diff;
    intensity >>= 16;
    if(!opt) {
        if(intensity > 75)
            SetInventory("FadeIntensity", 75);
        else
            SetInventory("FadeIntensity", intensity);
    }
    SetInventory("DnD_PrevHealth", GetActorProperty(0, APROP_Health));
    SetResultValue(CheckInventory("FadeIntensity"));
}

Script "DND Killing Spree End" (int spree, int mult, int reward) CLIENTSIDE {
	LocalAmbientsound("KillStreak/Show", 127);
	SetHudSize(480, 360, 0);
	str temp = "KILLST";
	for(int i = 0; i < 4; ++i) {
		SetFont(StrParam(s:temp, d:i + 1));
		HudMessage(s:"A"; HUDMSG_FADEOUT, DND_SPREE_BLOODID, CR_WHITE, 220.4, 324.0, 3.0, 1.0);		
		Delay(3);
	}
	SetFont("MONFONT");
	HudMessage(s:"\ci", s:SpreeText[Clamp_Between(mult - 1, 0, MAX_SPREE_TEXT - 1)], s:"!\c- \cix", f:mult * 0.25, s:"\c- bonus!"; HUDMSG_FADEINOUT, DND_SPREE_TEXT1ID, CR_WHITE, 240.4, 320.0, 2.0, 1.0, 1.0);
	HudMessage(s:"Gained extra \cf", d:reward, s: "\c- exp!"; HUDMSG_FADEINOUT, DND_SPREE_TEXT2ID, CR_WHITE, 240.4, 328.0, 2.0, 1.0, 1.0);
}

Script "DnD Killing Spree Timer" (void) {
	while(CheckInventory("DnD_SpreeTimer")) {
		TakeInventory("DnD_SpreeTimer", 1);
		Delay(1);
	}
	// countdown over, reset spree xp and handle spree stuff
	TakeInventory("DnD_SpreeCountdownRunning", 1);
	
	if(CheckInventory("DnD_MultikillCounter")) {
		while(CheckInventory("DnD_SpreeTimer"))
			Delay(1);
		if(CheckInventory("DnD_MultikillCounter") >= DND_SPREE_TRIGGER && isAlive()) {
			int spree = CheckInventory("DnD_MultiKillCounter") + 1, mult = 0, reward = 0, temp;
			SetInventory("DnD_MultiKillCounter", 0);
			// shows kill spree result on hud
			// for every 10 enemy killed in spree, add a 0.25 multiplier
			// base multiplication factor is 0.25
			mult = Clamp_Between(spree / DND_SPREE_PER, 1, MAX_SPREE_TEXT); // how many .25 to add
			temp = CheckInventory("SpreeXP") / DND_SPREE_BASE;
			while(mult) {
				// no overflow
				if(reward < INT_MAX - temp)
					reward += temp;
				--mult;
			}
			if(CheckInventory("DnD_QuestReward_KillingSpree15"))
				reward += reward * DND_QUEST_BERSERK_SPREEBONUS / 100;
			ACS_NamedExecuteAlways("DND Killing Spree End", 0, spree, spree / DND_SPREE_PER, reward);
			GiveInventory("Exp", reward);
			GiveInventory("LevelExp", reward);
			CalculateExpRatio();
			SetInventory("SpreeXP", 0);
			GiveInventory("DnD_BerserkQuest_SpreeCounter", 1);
			// ravager armor add
			int armor = GetArmorType("RavagerArmor", PlayerNumber());
			if(armor) {
				if(armor < GetArmorSpecificCap(DND_RAVAGERARMOR_AMOUNT)) {
					ACS_NamedExecuteAlways("DND Armor Give", 0, DND_ARMOR_RAVAGER, GetArmorSpecificCap(DND_RAVAGERARMOR_AMOUNT) - armor);
					GiveInventory("RavagerEffect", 1);
					LocalAmbientSound("items/armorbonus", 127);
				}
			}
			
			// punisher perk 2 -- was at least merciless
			if(CheckInventory("Punisher_Perk25") && spree >= 2) {
				ACS_NamedExecuteAlways("DnD Health Pickup", 0, (GetSpawnHealth() * DND_PUNISHER_PERK2_MULT) / DND_PUNISHER_PERK2_DIV);
				ACS_NamedExecuteAlways("DND Armor Give", 0, CheckInventory("DnD_ArmorType") - 1, GetArmorSpecificCap(ArmorBaseAmounts[CheckInventory("DnD_ArmorType") - 1]) * DND_PUNISHER_PERK2_MULT / DND_PUNISHER_PERK2_DIV);
			}
		}
		else {
			SetInventory("DnD_MultikillCounter", 0);
			SetInventory("SpreeXP", 0);
		}
		
		// spree ended
		TakeInventory("Punisher_Perk5_MoveSpeed", 1);
	}
}

Script "DND Mugshot Grin" (void) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	SetMugshotState("Grin");
}

Script "DND On Revive" (void) {
	TakeInventory("Mo_Died", 1);
	//Mob that gets revived don't call Monster Scale script. Make sure some of its effects get reapplied here.
	int id = ActivatorTID() - DND_MONSTERTID_BEGIN;
	if (MonsterProperties[id].maxhp) { //This could be skipped if all mobs have their Monster Scaling.
		SetEliteFlag(DND_REVIVED); //Add "Revived" trait to mob. Also gives "Mo_Revived" item.
		//Reapply the elite FX.
		if (MonsterProperties[id].isElite && !CheckInventory("RunEliteFXScript"))
			GiveInventory("RunEliteFXScript", 1);
		//printbold(s:"Monster id: ",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].id,s:", (After Respawn) Mob spawn hp:", d:GetActorProperty(0, APROP_SpawnHealth), s:", Mob hp:", d:GetActorProperty(0, APROP_Health), s:", Mob realhp",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp);
		//Mob revives with "APROP_SpawnHealth" HP. Make sure it respawns with the right max hp.
		int maxhp = MonsterProperties[id].maxhp;
		int dmg = GetActorProperty(0, APROP_SpawnHealth) - GetActorProperty(0, APROP_Health);
		SetActorProperty(0, APROP_HEALTH, maxhp);
		Clamp_Between(dmg, 0, maxhp + 1);
		Thing_Damage2(ActivatorTID(), dmg, "None");
		//Mob might actually be dead by this point.
		if (GetActorProperty(0, APROP_Health) > maxhp) //In the rare case the mob keeps the very high hp
			Thing_Damage2(ActivatorTID(), GetActorProperty(0, APROP_Health) + 1, "None"); //Just kill it

		HandleMonsterClassInnates(id);
	}
	//printbold(s:"(Really After Respawn) Mob spawn hp:", d:GetActorProperty(0, APROP_SpawnHealth), s:", Mob hp:", d:GetActorProperty(0, APROP_Health));
	ACS_NamedExecuteAlways("DnD On Revive CS", 0);
	GiveInventory("DnD_MonsterSetupDone", 1);
}

Script "DnD On Revive CS" (void) CLIENTSIDE {
	TakeInventory("Mo_Died", 1);
}

// Make sure clients are aware too
Script "DND On Kill CS" KILL CLIENTSIDE {
	GiveInventory("Mo_Died", 1);
}

Script "DnD Wanderer Explosions" (int this, int target) {
	int hpdamage = MonsterProperties[this - DND_MONSTERTID_BEGIN].maxhp / DND_WANDERER_EXP_DAMAGE;
	if(hpdamage < 0)
		hpdamage = 1;
	
	int exptid = DND_WANDERER_EXP_TID + target - P_TIDSTART;
	SpawnForced("Wanderer_Explosion", GetActorX(this), GetActorY(this), GetActorZ(this) + GetActorProperty(this, APROP_HEIGHT) / 2 + 24.0, exptid);
	SetUserVariable(exptid, "user_dmg", hpdamage);
	SetActivator(exptid);
	SetPointer(AAPTR_TARGET, target);
	Thing_ChangeTID(exptid, 0);
}

// Used for exp and credit calculations
Script "DND On Kill" KILL {
	int this = ActivatorTID();
	int m_id = this - DND_MONSTERTID_BEGIN;
	GiveInventory("Mo_Died", 1);
	// don't continue if monster is revived or summoned
	if(HasTrait(m_id, DND_SUMMONED) || HasTrait(m_id, DND_REVIVED))
		Terminate;
	int target = GetActorProperty(0, APROP_TARGETTID);
	if(target < P_TIDSTART || target > P_TIDSTART + MAXPLAYERS - 1) // only work if you can determine target as a player
		Terminate;
		
	if(CheckActorInventory(target, "Wanderer_Perk50"))
		ACS_NamedExecuteAlways("DnD Wanderer Explosions", 0, this, target);
		
	// remove freeze and chill timers
	SetInventory("DnD_ChillStacks", 0);
	SetInventory("DnD_FreezeTimer", 0);
	
	if(MonsterProperties[this - DND_MONSTERTID_BEGIN].trait_list[DND_REBIRTH]) {
		GiveInventory("DnD_RebirthItem", 1);
		MonsterProperties[this - DND_MONSTERTID_BEGIN].trait_list[DND_REBIRTH] = false;
	}
	
	if(CheckInventory("DnD_OverloadTimer") && !CheckInventory("DnD_OverloadLockTime")) {
		GiveInventory("DnD_OverloadZapGiver", 1);
		ACS_NamedExecuteAlways("DnD Monster Overload Zap", 0, this, target);
	}
	
	SetInventory("DnD_OverloadTimer", 0);
		
	int expshare = GetCVar("dnd_sharexp");
	int creditshare = GetCVar("dnd_sharecredit");
	int haswisdom = IsAccessoryEquipped(target, DND_ACCESSORY_TALISMANWISDOM);
	int hasgreed = IsAccessoryEquipped(target, DND_ACCESSORY_TALISMANGREED);
	
    // decide how exp/credit base is calculated
	int exptemp = MonsterProperties[m_id].maxhp / DND_HEALTHEXPSCALE;
	int credtemp = (DND_HEALTHCREDITUPSCALE * MonsterProperties[m_id].maxhp) / DND_HEALTHCREDITSCALE;
    int pnum = 0, i = MonsterProperties[m_id].level;
	
	if(i > 75)
		credtemp /= DND_HEALTHCREDITAFTER75SCALE;
	else if(i > 50)
		credtemp /= DND_HEALTHCREDITAFTER50SCALE;
	
	if(credtemp < DND_MIN_CREDIT)
		credtemp = DND_MIN_CREDIT;
	
	if(MonsterProperties[m_id].isElite) {
		exptemp += exptemp * DND_ELITE_EXP_BONUS / 100;
		credtemp += credtemp * DND_ELITE_CREDIT_BONUS / 100;
	}
	
	int pcount = Clamp_Between(PlayerCount(), 1, DND_MAX_SHARE);
	int expscale = Clamp_Between(GetCVar("dnd_exp_scale"), 1, EXP_SCALE_MAX);
	int creditscale = Clamp_Between(GetCVar("dnd_credit_scale"), 1, CREDIT_SCALE_MAX);
	int addone = 0;
	int expprev, credprev;
		
	// add monster scale stuff
	if(MonsterProperties[m_id].level > 1) {
		exptemp += exptemp * MonsterProperties[m_id].level * Clamp_Between(GetCVar("dnd_monster_rewardscalepercent"), 1, 25) / 100;
		credtemp += credtemp * MonsterProperties[m_id].level * Clamp_Between(GetCVar("dnd_monster_rewardscalepercent"), 1, 25) / 100;
	}
	
	ACS_NamedExecuteAlways("DND Show Kill Digits", 0, exptemp * expscale, credtemp * creditscale); // show the numbers
	
	if(haswisdom) { // wisdom
		exptemp *= 3;
		if(exptemp % 2)
			addone = 1;
		exptemp >>= 1;
		exptemp += addone;
	}
	addone = 0;
	if(hasgreed) { // greed
		credtemp *= 3;
		if(credtemp % 2)
			addone = 1;
		credtemp >>= 1;
		credtemp += addone;
	}
	
	addone = GetCVar("dnd_gainonlyinrange");
	
	// if full share is on we won't divide by player count, but if it isn't we will
	if(!GetCVar("dnd_fullshare")) {
		exptemp = (exptemp * expscale) / pcount;
		if(exptemp < MIN_EXP_GAIN)
			exptemp = MIN_EXP_GAIN;
		credtemp = (credtemp * creditscale) / pcount;
		if(credtemp < MIN_CREDIT_GAIN)
			credtemp = MIN_CREDIT_GAIN;
	}
	
	if(expshare || creditshare) {
		for(i = 0; i < MAXPLAYERS; ++i) {
			expprev = exptemp;
			credprev = credtemp;
			pnum = P_TIDSTART + i;
			if(IsActorAlive(pnum) && pnum != target) { // dont give twice
				// check if range flag is on, if it is check the range
				if(!addone || (addone && AproxDistance(GetActorX(target) - GetActorX(pnum), GetActorY(target) - GetActorY(pnum)) >> 16 <= GetCVar("dnd_gainrange"))) {
					if(expshare) {
						expprev += expprev * BASE_WISDOM_GAIN * CheckActorInventory(P_TIDSTART + i, "Perk_Wisdom") / 100;
						if(IsAccessoryEquipped(pnum, DND_ACCESSORY_TALISMANGREED))
							expprev >>= 1;
						expprev += (expprev * GetPlayerWisdomBonus(pnum)) / 100;
						GiveActorExp(pnum, expprev * expscale);
					}
					
					if(creditshare) {
						credprev += credprev * BASE_GREED_GAIN * CheckActorInventory(P_TIDSTART + i, "Perk_Greed") / 100;
						if(CheckActorInventory(P_TIDSTART + i, "DnD_QuestReward_MoreCredit"))
							credprev += credprev * DND_QUEST_CREDITBONUS / 100;
						if(IsAccessoryEquipped(pnum, DND_ACCESSORY_TALISMANWISDOM))
							credprev >>= 1;
						credprev += (credprev * GetPlayerGreedBonus(pnum)) / 100;
						GiveActorCredit(pnum, credprev * creditscale);
					}
				}
			}
		}
		// now give target his stuff (if expshare or creditshare, one of them was not on the target would not receive it in the loop)
		exptemp += exptemp * BASE_WISDOM_GAIN * CheckActorInventory(target, "Perk_Wisdom") / 100;
		credtemp += credtemp * BASE_GREED_GAIN * CheckActorInventory(target, "Perk_Greed") / 100;
		if(IsAccessoryEquipped(target, DND_ACCESSORY_TALISMANWISDOM))
			credtemp >>= 1;
		if(IsAccessoryEquipped(target, DND_ACCESSORY_TALISMANGREED))
			exptemp >>= 1;
		exptemp += (exptemp * GetPlayerWisdomBonus(target - P_TIDSTART)) / 100;
		credtemp += (credtemp * GetPlayerGreedBonus(target - P_TIDSTART)) / 100;
		GiveActorExp(target, exptemp * expscale);
		GiveActorCredit(target, credtemp * creditscale);
	}
	else {
		// just give target his stuff
		exptemp += exptemp * BASE_WISDOM_GAIN * CheckActorInventory(target, "Perk_Wisdom") / 100;
		credtemp += credtemp * BASE_GREED_GAIN * CheckActorInventory(target, "Perk_Greed") / 100;
		if(CheckActorInventory(target, "DnD_QuestReward_MoreCredit"))
			credtemp += credtemp * DND_QUEST_CREDITBONUS / 100;
		exptemp += (exptemp * GetPlayerWisdomBonus(target - P_TIDSTART)) / 100;
		credtemp += (credtemp * GetPlayerGreedBonus(target - P_TIDSTART)) / 100;
		GiveActorExp(target, exptemp * expscale);
		GiveActorCredit(target, credtemp * creditscale);
	}
	
	// Handle Drops
	// reuse old variable
	pnum = MonsterProperties[m_id].isElite;
	// drop coins if there should be
	if(GetCVar("dnd_credit_drops")) {
		// calculate chance of getting credit drops, more chance if monster is an elite and if player has quest
		HandleCashDrops(target - P_TIDSTART, pnum);
	}
	
	HandleMonsterTemporaryWeaponDrop(m_id, target - P_TIDSTART, pnum);

	// soul ammo drop -- considers ability - soulstealer as well
	if(
		(CanDropSoulAmmo() && RunDefaultDropChance(target - P_TIDSTART, pnum, DND_SOULAMMO_DROPRATE)) ||
		(IsDemon() && ((CheckInventory("BookCausedDeath") || (CheckActorInventory(target, "Ability_SoulStealer") && CheckInventory("MagicCausedDeath")))))
	  )
	{
		if(random(1, 100) <= DND_SOULAMMO_SMALLCHANCE || CheckInventory("BookCausedDeath"))
			SpawnDrop("Souls", 24.0, 16, 0, 0);
		else
			SpawnDrop("LargeSouls", 24.0, 16, 0, 0);
		TakeInventory("BookCausedDeath", 1);
		TakeInventory("MagicCausedDeath", 1);
	}

	if(!GetCVar("dnd_allresearchesfound")) {
		// make it less likely to drop
		// addone is the chance here (reusing old variables)
		addone = random(0, DND_RESEARCH_DROPMULT * DND_RESEARCH_MAX_CHANCE);
		#ifdef ISDEBUGBUILD
			SpawnResearch();
		#endif
		#ifndef ISDEBUGBUILD
			if(GetCVar("dnd_ignore_dropweights") || RunDropChance(target - P_TIDSTART, pnum, Clamp_Between(GetCVar("dnd_researchdroprate"), 0.0, DND_RESEARCH_MAX_CHANCE), 0.0, addone))
				SpawnResearch();
		#endif
	}
	
	// Talent Capsule Drop
	//if(RunDefaultDropChance(target - P_TIDSTART, pnum, DND_TALENTCAPSULE_DROPRATE))
	//	SpawnTalentCapsule();
	
	// Chest Key
	HandleChestKeyDrop(pnum);
	
	// if elite, roll orb and equipment drops
	if(GetCVar("dnd_ignore_dropweights") || pnum) {
		// handle orb drops
		HandleOrbDrop();
	}
	
	// accessory drops (accept only from cyber and spider masterminds)
	if(IsBoss()) {
		if(RunDropChance(target - P_TIDSTART, pnum, (Clamp_Between(GetCVar("dnd_accessory_droprate"), 0, 100) * 1.0) / 100, 0, 1.0)) {
			if((PlayerInformationInLevel[PLAYERLEVELINFO_LEVEL] / PlayerInformationInLevel[PLAYERLEVELINFO_COUNTATSTART]) >= Clamp_Between(GetCVar("dnd_accessorylevel"), 1, 100)) {
				// we can drop the spawner
				SpawnAccessory();
			}
		}
	}
	
	// Demon Bane check
	if(active_quest_id == QUEST_KILL10BOSSES && IsBoss()) {
		GiveActorInventory(target, "DnD_BossKillQuest_Counter", 1);
		if(!IsQuestComplete(target, QUEST_KILL10BOSSES) && CheckActorInventory(target, "DnD_BossKillQuest_Counter") == DND_QUEST_BOSSKILLER_REQ)
			CompleteQuest(target, QUEST_KILL10BOSSES);
	}
	
	// Elite Slayer check
	if(active_quest_id == QUEST_KILL20ELITES && pnum) {
		GiveActorInventory(target, "DnD_EliteKillQuest_Counter", 1);
		if(!IsQuestComplete(target, QUEST_KILL20ELITES) && CheckActorInventory(target, "DnD_EliteKillQuest_Counter") == DND_QUEST_ELITEKILLER_REQ)
			CompleteQuest(target, QUEST_KILL20ELITES);
	}
	
	// Legendary Kill Item
	if(MonsterProperties[m_id].id >= LEGENDARY_START) {
		for(i = 0; i < MAXPLAYERS; ++i) {
			if(PlayerInGame(i) && IsActorAlive(i + P_TIDSTART)) {
				UpdateLegendaryKill(i, MonsterProperties[m_id].id - LEGENDARY_START);
				
				if(active_quest_id - DND_LEGQUEST_START == MonsterProperties[m_id].id - LEGENDARY_START)
					CompleteQuest(i + P_TIDSTART, active_quest_id);
			}
		}
	}
	
	#ifdef ISDEBUGBUILD
		SpawnElixir(0);
		SpawnCharm(0, true);
		SpawnOrb(0, true);
	#endif
	HandleCharmLootDrop(pnum);
	
	// doomguy drop
	if(CheckActorInventory(target, "Doomguy_Perk50") && RunDefaultDropChance(i, pnum, DND_DOOMGUY_DROPCHANCE)) {
		pnum = MonsterProperties[m_id].maxhp;
		SpawnDrop("Doomguy_DemonSoul", 24.0, 16, pnum & 0xFFFF, pnum >> 16);
	}
	
	// if marked by talisman
	pnum = CheckInventory("HunterTalismanMarkBool");
	haswisdom = isBoss();
	hasgreed = isDemon();
	SetInventory("HunterTalismanMarkBool", 0);
	
	if(isZombie())
		GiveActorInventory(target, "DnD_ShotUndead", 1);
	
	// required delay for transition from specific death state labels
	Delay(const:1);
	
	HandleOtherDrops(target);
	
	// check zombie summon
	if(!IsLostSoul() && !IsRobotic()) {
		addone = CheckActorInventory(target, "IATTR_ChanceToRaiseZombieFromKills");
		if(HasRoomForPets(target) && CheckActorInventory(target, "SummonedZombiePets") < MAX_SUMMON_ZOMBIECOUNT && addone >= random(1, 100)) {
			// raise zombie
			HandleZombieRaiseOnDeath(target);
		}
	}
	
	if(CheckActorInventory(target, "StatbuffCounter_SlainMonstersRIP"))
		ACS_NamedExecuteAlways("DnD Monster RIP", 0);
		
	
	SetActivator(target);
	
	// keep the kill tally
	GiveInventory("DnD_Kills", 1);
	
	if(CheckInventory("Punisher_Perk50")) {
		GiveInventory("Punisher_Perk50_Counter", 1);
		CheckPunisherKillTally();
		ACS_NamedExecuteAlways("DnD Punisher Perk50 Display", 0, false);
	}
	
	// research track
	if(haswisdom && CheckResearchStatus(RES_IMP1) == RES_NA) {
		GiveInventory("Research_Body_Im_1_Tracker", 1);
		if(CheckInventory("Research_Body_Im_1_Tracker") == GetAmmoCapacity("Research_Body_Im_1_Tracker")) {
			GiveResearch(RES_IMP1, true);
			// take these off so they don't take netid
			TakeInventory("Research_Body_Im_1_Tracker", 65535);
		}
	}
	
	if(hasgreed && CheckResearchStatus(RES_SLOT3UPG3) == RES_NA) {
		GiveInventory("Research_Slot3Upgrade3_Tracker", 1);
		if(CheckInventory("Research_Slot3Upgrade3_Tracker") == GetAmmoCapacity("Research_Slot3Upgrade3_Tracker")) {
			GiveResearch(RES_SLOT3UPG3, true);
			// take these off so they don't take netid
			TakeInventory("Research_Slot3Upgrade3_Tracker", 65535);
		}
	}
	
	// Kill spree
	if(GetCVar("dnd_killspree"))
		ActivateKillingSpree();
	// Hunter Talisman Heal
	if(pnum) {
		GiveInventory("HunterTalismanHealFXSpawner", 1);
		ACS_NamedExecuteAlways("DnD Health Pickup", 0, GetSpawnHealth() / DND_HUNTERTALISMAN_HEALFACTOR);
	}
	
	addone = CheckInventory("IATTR_HealOnKill");
	if(addone) {
		haswisdom = (GetMissingHealth() * addone) / 100;
		if(haswisdom) {
			Spawn("DarkHealEffectSpawner", GetActorX(0), GetActorY(0), GetActorZ(0), 0);
			ACS_NamedExecuteAlways("DnD Health Pickup", 0, haswisdom);
		}
	}
}

Script "DnD Monster RIP" (void) {
	Delay(RIP_MONSTER_FADE_DELAY);
	SetActorProperty(0, APROP_RENDERSTYLE, STYLE_Translucent);
	int a = GetActorProperty(0, APROP_ALPHA);
	for(int i = 1; i < RIP_FADE_TIMER; ++i) {
		SetActorProperty(0, APROP_ALPHA, a - (i * 1.0) / RIP_FADE_TIMER);
		Delay(1);
	}
	Thing_Remove(0);
}

Script "DND Show Kill Digits" (int exp, int credit) CLIENTSIDE {
	// spectators shouldn't see this
	// for some reason exp and credit can be 0, no idea how, but this fixes it
	if(!PlayerInGame(ConsolePlayerNumber()) || (!exp && !credit))
		Terminate;
	
	// calculate the exp and credit to be added for each monster killed
	int tid = ConsolePlayerNumber() + P_TIDSTART;
	exp += (exp * BASE_WISDOM_GAIN * CheckActorInventory(tid, "Perk_Wisdom")) / 100;
	exp += (exp * GetPlayerWisdomBonus(ConsolePlayerNumber())) / 100;
	credit += (credit * BASE_GREED_GAIN * CheckActorInventory(tid, "Perk_Greed")) / 100;
	credit += (credit * GetPlayerGreedBonus(ConsolePlayerNumber())) / 100;
	GiveActorInventory(tid, "DnD_Exp_Counter", exp);
	GiveActorInventory(tid, "DnD_Credit_Counter", credit);
	GiveActorInventory(tid, "DnD_ExpCredit_Timer", 1);
	
	// check if we can truly terminate early, if we can, extend timer
	if(PlayerScriptsCheck[DND_SCRIPT_EXPTRACKER][ConsolePlayerNumber()]) {
		// refresh duration if we're already running one
		if(CheckActorInventory(tid, "DnD_ExpCredit_Timer"))
			GiveActorInventory(tid, "DnD_ExpCredit_Timer", 1);
		Terminate;
	}
	
	PlayerScriptsCheck[DND_SCRIPT_EXPTRACKER][ConsolePlayerNumber()] = true;
	while(CheckActorInventory(tid, "DnD_ExpCredit_Timer"))
		Delay(2);
	if(CheckActorInventory(tid, "DnD_Exp_Counter") || CheckActorInventory(tid, "DnD_Credit_Counter"))
		Log(s:"\ccGains pickup  : \c[Y5]", d:CheckActorInventory(tid, "DnD_Exp_Counter"), s:" exp and ", d:CheckActorInventory(tid, "DnD_Credit_Counter"), s:" credits.");
	SetActorInventory(tid, "DnD_Exp_Counter", 0);
	SetActorInventory(tid, "DnD_Credit_Counter", 0);
	PlayerScriptsCheck[DND_SCRIPT_EXPTRACKER][ConsolePlayerNumber()] = false;
}

// Stat Reset
Script 832 (void) {
	int statpts = Calculate_Stats();
	int perkpts = Calculate_Perks();
	Reset_RPGInfo(RESET_STATS | RESET_PERKS);
	StatListOpened[PlayerNumber()] = 0;
	// don't use set here, it removes unallocated pts
	GiveInventory("AttributePoint", statpts);
	GiveInventory("PerkPoint", perkpts);
}

// Weapon pickup checks, bulkiness armor check and agamotto check
Script 891 ENTER {
	int i, temp;
	while(1) {
		i = 0;
		while(i < MAXWEPS) {
			if(CheckInventory(Weapons[i][WEAPON_NAME]) && !CheckInventory(Weapons[i][WEAPON_GOT])) {
				Delay(5);
				GiveInventory(Weapons[i][WEAPON_GOT], 1);
			}
			++i;
		}
		
		// Bulkiness
		if(CheckInventory("Armor")) {
			temp = GetBulkiness();
			if(temp) {
				// allow max of 200 bulkiness to work in here
				temp = Clamp_Between(temp, 1, DND_STAT_FULLMAX);
				if(temp > 100) {
					temp -= 100;
					SetActorProperty(0, APROP_DAMAGEFACTOR, 1.0 - DND_BULKINESS_GAIN * 100 - DND_BULKINESS_GAIN_AFTER100 * temp);
				}
				else
					SetActorProperty(0, APROP_DAMAGEFACTOR, 1.0 - DND_BULKINESS_GAIN * temp);
				// adjust player knockback resist by modifying their mass
				UpdatePlayerKnockbackResist();
			}
		}
		else
			SetActorProperty(0, APROP_DAMAGEFACTOR, 1.0);
		
		if(isAlive()) {
			// Agamotto check
			if(CheckInventory("AgamottoCheck")) {
				int input = GetPlayerInput(-1, INPUT_BUTTONS);
				if(input & (BT_FORWARD | BT_BACK | BT_MOVELEFT | BT_MOVERIGHT)) {
					if(!CheckInventory("AgamottoDefense")) {
						GiveInventory("AgamottoDefense", 1);
						TakeInventory("AgamottoOffense", 1);
					}
				}
				else if(!CheckInventory("AgamottoOffense")) {
					TakeInventory("AgamottoDefense", 1);
					GiveInventory("AgamottoOffense", 1);
				}
			}
			else {
				TakeInventory("AgamottoDefense", 1);
				TakeInventory("AgamottoOffense", 1);
			}
			
			// Sigil Check
			if(CheckInventory("SigilCheck")) {
				// give item only if there is no sigil powerup currently on player
				if(HasNoSigilPower()) {
					switch(CheckInventory("SigilCheck")) {
						case 1: // fire
							GiveInventory("ElementPower_Fire", 1);
						break;
						case 2:
							GiveInventory("ElementPower_Ice", 1);
						break;
						case 3:
							GiveInventory("ElementPower_Lightning", 1);
						break;
						case 4:
							GiveInventory("ElementPower_Earth", 1);
						break;
					}
					SetInventory("SigilCheck", (CheckInventory("SigilCheck") % 4) + 1);
				}
			}
			
			if(GetArmorType("KnightArmor", PlayerNumber()) && IsUsingMeleeWeapon())
				GiveInventory("KnightProtection", 1);
			else
				TakeInventory("KnightProtection", 1);
			
			// for cautious quest
			if(GetActorProperty(0, APROP_HEALTH) < GetSpawnHealth())
				GiveInventory("DnD_HealthLess50", 1);
			
			// weapon quests
			if(GetPlayerInput(-1, INPUT_BUTTONS) & (BT_ATTACK | BT_ALTATTACK)) {
				// Simple Minded quest check
				if(PlayerWeaponUsed[PlayerNumber()] == -1)
					PlayerWeaponUsed[PlayerNumber()] = CheckInventory("DnD_WeaponID");
				else if(!CheckInventory("DnD_WeaponFiredOther") && PlayerWeaponUsed[PlayerNumber()] != CheckInventory("DnD_WeaponID"))
					GiveInventory(Quest_Checkers[QUEST_ONLYONEWEAPON], 1);

				// only slot 2 quest check
				if(
					active_quest_id == QUEST_ONLYPISTOLWEAPONS && !CheckInventory(Quest_Checkers[QUEST_ONLYPISTOLWEAPONS]) &&
					!IsQuestComplete(ActivatorTID(), QUEST_ONLYPISTOLWEAPONS) && !CheckInventory("H_WeaponSlot2")
				  )
					GiveInventory(Quest_Checkers[QUEST_ONLYPISTOLWEAPONS], 1);
				
				// only boomstick quest check
				if(
					active_quest_id == QUEST_NOSHOTGUNS && !CheckInventory(Quest_Checkers[QUEST_NOSHOTGUNS]) && 
					!IsQuestComplete(ActivatorTID(), QUEST_NOSHOTGUNS) && 
					((CheckInventory("H_WeaponSlot3") && CheckInventory("DnD_WeaponID") != DND_WEAPON_SLAYER) || CheckInventory("H_WeaponSlot3X"))
				  )
					GiveInventory(Quest_Checkers[QUEST_NOSHOTGUNS], 1);
				
				// no superweapon quest check
				if(
					active_quest_id == QUEST_NOSUPERWEAPONS && !CheckInventory(Quest_Checkers[QUEST_NOSUPERWEAPONS]) &&
					!IsQuestComplete(ActivatorTID(), QUEST_NOSUPERWEAPONS) &&
					(CheckInventory("H_WeaponSlot7") || CheckInventory("H_WeaponSlot8"))
				  )
					GiveInventory(Quest_Checkers[QUEST_NOSUPERWEAPONS], 1);
					
				// only energy quest check
				if(
					active_quest_id == QUEST_ONLYENERGY && !CheckInventory("DnD_UsingEnergy") && !CheckInventory(Quest_Checkers[QUEST_ONLYENERGY])
				  )
					GiveInventory(Quest_Checkers[QUEST_ONLYENERGY], 1);
			}
	
			if(active_quest_id == QUEST_SPEND25K && CheckInventory("DnD_MoneySpentQuest") >= DND_QUEST_MONEYMAKERREQ && !IsQuestComplete(ActivatorTID(), QUEST_SPEND25K))
				CompleteQuest(ActivatorTID(), QUEST_SPEND25K);
		}
		Delay(7);
	}
}

// 894 is for database save

Script 895 ENTER CLIENTSIDE {
	int i;
	NamedRequestScriptPuke("DnD User Dash Status Receive", GetCVar("dnd_dashstatus"));
	while(1) {
		i = 0;
		if(CheckInventory("LeveledUp")) {
			Log(s:"\ccAnnouncement  : \c-", n:0, s:" \c[Y5]has leveled up to\c- \cv", d:CheckInventory("Level"), s:"\c-\c[Y5]!");
			if(CheckInventory("TalentedUp"))
				Log(s:"\ccAnnouncement  : \c-", n:0, s:" \c[Y5]has gained a\c- \cjtalent point\c-!");
			if(CheckInventory("PerkedUp"))
				Log(s:"\ccAnnouncement  : \c-", n:0, s:" \c[Y5]has gained a\c- \cjperk point\c-!");
			TakeInventory("LeveledUp", 1);
		}
		if(GetCVar("dnd_weapontips") && !CheckInventory("ParsingData")) {
			while(i < MAXWEPS) {
				str check = Weapons[i][WEAPON_NAME];
				if(StrLen(check) && CheckInventory(check) && !CheckInventory(Weapons[i][WEAPON_GOT])) {
					ACS_ExecuteAlways(977, 0, 0, i);
					GiveInventory(Weapons[i][WEAPON_GOT], 1);
					GiveInventory("TipBoxOpen", 1);
					Delay(5);
				}
				++i;
			}
		}
		Delay(5);
	}
}

Script 896 (void) {
	int check = 0;
	for(int i = 0; i < MAXTEMPWEPS; ++i)
		if(CheckInventory(TemporaryWeapons[i][TEMPWEP_NAME])) {
			check = 1;
			break;
		}
	SetResultValue(!check);
}

Script 897 (void) {
	int i = random(0, MAXTEMPWEPS - 1);
	GiveInventory(TemporaryAmmos[i], 999);
	SetWeapon(TemporaryWeapons[i][TEMPWEP_NAME]);
	LocalAmbientSound("weapons/pickup", 127);
}

Script 898 (int msg) CLIENTSIDE {
	if(PlayerNumber() != ConsolePlayerNumber()) 
		Terminate;
	if(msg)
		Log(s:"Weapon tip boxes on");
	else
		Log(s:"Weapon tip boxes off");
}

Script 899 (int tips) NET CLIENTSIDE {
	if(GetCVar("dnd_weapontips")) {
		SetCVar("dnd_weapontips", 0);
		ACS_ExecuteAlways(898, 0, 0);
	}
	else {
		SetCVar("dnd_weapontips", 1);
		ACS_ExecuteAlways(898, 0, 1);
	}
}

// 900 is in the menu.c

Script 902 (int forceset, int id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	int i = CheckInventory("AmmoChangeMessage");
	if(forceset)
		i = id;
	if(!CheckInventory("NoAmmoMessage")) {
		SetFont("BIGFONT");
		HudMessage(s:"Now using ", s:SpecialAmmoNames[i][SPECIALAMMO_TAG], s:"!"; HUDMSG_PLAIN | HUDMSG_LOG, DND_SPECIALAMMO_TEXTID, CR_WHITE, 0.5, 0.1, 2.0);
		// hack: update ammo table to trick hud
		int pos = GetCurrentWeaponID();
		Weapons[pos][WEAPON_AMMO1] = SpecialAmmoNames[i][SPECIALAMMO_NAME];
	}
}

// Current weapon tip

Script 903 (void) NET CLIENTSIDE {
	if(!CheckInventory("TipBoxOpen")) {
		int curweap = GetCurrentWeaponID();
		ACS_ExecuteAlways(977, 0, 0, curweap);
		GiveInventory("TipBoxOpen", 1);
	}
}

// 904 is used by the menu

// temporary drops
Script 905 (int mode) NET {
	if(!mode) {
		int curweap = GetCurrentWeaponID() - TEMPBEGIN; // to put it in range of the temporary weapons
		int amt;
		// valid range, no drop spam and not able to while firing and has ammo to spare
		// gross hax, fix later
		if(curweap >= 0 && curweap < MAXTEMPWEPS && !CheckInventory("DropItemCooldown") && CheckInventory("TempWeaponReady")) {
			if(curweap > DND_TEMPAMMO_BLADEHITS)
				amt = CheckInventory(TemporaryAmmos[curweap + 1]);
			else
				amt = CheckInventory(TemporaryAmmos[curweap]);
			
			if(amt) {
				int temptid = ActivatorTID() + P_TEMPTID;
				GiveInventory("DropItemCooldown", 1);
				// the dropped versions have _D suffix
				SpawnForced(StrParam(s:TemporaryWeapons[curweap][TEMPWEP_DROP], s:"_D"), GetActorX(0) + cos(GetActorAngle(0)), GetActorY(0) + sin(GetActorAngle(0)), GetActorZ(0) + 32, temptid);
				SetActorProperty(temptid, APROP_MASS, amt);
				ThrustThing(GetActorAngle(0) >> 8, 16, 0, temptid);
				ThrustThingZ(temptid, 8, 0, 0);
				Thing_ChangeTID(temptid, 0); // clear tid to prevent stupid shit
				GiveInventory("ForceWeaponRemove", 1);
				CleanTempAmmo();
			}
		}
	}
}

// 906 to 914 reserved
script "DnD Aspect Ratio Check ENTER" ENTER CLIENTSIDE {
	aspect_ratio = GetAspectRatio();
	if (aspect_ratio == ASPECT_5_4) {
		ScreenResOffsets[0] = 0.0;
		ScreenResOffsets[1] = 0.0;
		ScreenResOffsets[2] = 0.0;
		ScreenResOffsets[3] = 0.0;
	}
	else if (aspect_ratio == ASPECT_4_3) {
		ScreenResOffsets[0] = 0.0;
		ScreenResOffsets[1] = 0.0;
		ScreenResOffsets[2] = 80.0;
		ScreenResOffsets[3] = 120.0;
	}
	else if (aspect_ratio == ASPECT_16_9) {
		ScreenResOffsets[0] = 108.0;
		ScreenResOffsets[1] = 110.0;
		ScreenResOffsets[2] = 0.0;
		ScreenResOffsets[3] = 0.0;
	}
	else if (GetAspectRatio() == ASPECT_16_10) {
		ScreenResOffsets[0] = 54.0;
		ScreenResOffsets[1] = 66.0;
		ScreenResOffsets[2] = 30.0;
		ScreenResOffsets[3] = 45.0;
	}
	delay(const:70);
	restart;
}

script "DnD Aspect Ratio Check RESPAWN" RESPAWN CLIENTSIDE {
	aspect_ratio = GetAspectRatio();
	if (aspect_ratio == ASPECT_5_4) {
		ScreenResOffsets[0] = 0.0;
		ScreenResOffsets[1] = 0.0;
		ScreenResOffsets[2] = 0.0;
		ScreenResOffsets[3] = 0.0;
	}
	else if (aspect_ratio == ASPECT_4_3) {
		ScreenResOffsets[0] = 0.0;
		ScreenResOffsets[1] = 0.0;
		ScreenResOffsets[2] = 80.0;
		ScreenResOffsets[3] = 120.0;
	}
	else if (aspect_ratio == ASPECT_16_9) {
		ScreenResOffsets[0] = 108.0;
		ScreenResOffsets[1] = 110.0;
		ScreenResOffsets[2] = 0.0;
		ScreenResOffsets[3] = 0.0;
	}
	else if (GetAspectRatio() == ASPECT_16_10) {
		ScreenResOffsets[0] = 54.0;
		ScreenResOffsets[1] = 66.0;
		ScreenResOffsets[2] = 30.0;
		ScreenResOffsets[3] = 45.0;
	}
	delay(const:70);
	restart;
}

// For each ammo category, use a multiple of 10 to store values
Script 917 (int ammo_category, int weptype) {
    // if a change did occur
	if(HasSpecialAmmoForWeapon(ammo_category) != SpecialAmmoRanges[ammo_category][0]) {
		SetSpecialAmmoMode(ammo_category, weptype);
		if(ammo_category == AMMO_TYPE_SHELL || ammo_category == AMMO_TYPE_HEAVYSHELLS)
			SetInventory(Weapons[GetCurrentWeaponID()][WEAPON_AMMO2], 0);
		ActivatorSound("AmmoType/Switch", 127);
		Delay(4);
	}
	else
		GiveInventory("NoAmmoMessage", 1);
	SetInventory("AmmoChangeMessage", 0);
}

// type = 0, check stat, type = 1, check accessory
// refactor later
Script 918 (int type, int acc, int notarget) {
	int res = 0;
	
	if(!type) { 
		if(!acc) // get strength
			res = CheckInventory("PSTAT_Strength");
	}
	else if(type == 1) { // check for accessory
		int tid = ActivatorTID();
		if(!notarget)
			tid = GetActorProperty(0, APROP_TARGETTID);
		
		if(IsAccessoryEquipped(tid, acc))
			res = 1;
	}
	else if(type == 2) { // check for abilities
		if(notarget)
			SetActivator(0, AAPTR_TARGET);
		switch(acc) {
			case 0:
				if(CheckInventory("Ability_Reloader"))
					res = 1;
			break;
			case 1:
				if(CheckInventory("Ability_Arcanery"))
					res = 1;
			break;
		}
	}
	else if(type == 3) { // talents
		if(notarget)
			SetActivator(0, AAPTR_TARGET);
		res = CheckInventory(TalentNames[acc][TALENT_TAG]);
	}
	else if(type == 4) { // dexterity
		if(notarget)
			SetActivator(0, AAPTR_TARGET);
		res = GetDexterity();
	}
	else if(type == 5) { // bulkiness
		if(notarget)
			SetActivator(0, AAPTR_TARGET);
		res = CheckInventory("PSTAT_Bulkiness");
	}
	else if(type == 6) { // gunslinger
		if(notarget)
			SetActivator(0, AAPTR_TARGET);
		res = CheckInventory("DnD_QuestReward_Slot2DmgIncrease");
	}
	else if(type == 7) { // boomsticks
		if(notarget)
			SetActivator(0, AAPTR_TARGET);
		res = CheckInventory("DnD_QuestReward_ShotgunDmgIncrease");
	}
	else if(type == 8) { // super weapons
		if(notarget)
			SetActivator(0, AAPTR_TARGET);
		res = CheckInventory("DnD_QuestReward_SuperWeaponDamage");
	}
	else if(type == 9)
		res = GetActorProperty(0, APROP_TARGETTID);
	SetResultValue(res);
}

Script 919 (void) NET CLIENTSIDE {
	if(!GetCVar("dnd_nofx")) {
		SetFont("SMALLFONT");
		HudMessage(s:"Special Effects Off"; HUDMSG_FADEINOUT | HUDMSG_LOG, 1, CR_WHITE, 0.5, 0.24, 1.2, 0.5, 0.35);
		SetCVar("dnd_nofx", 1);
	}
	else {
		SetFont("SMALLFONT");
		HudMessage(s:"Special Effects On"; HUDMSG_FADEINOUT | HUDMSG_LOG, 1, CR_GOLD, 0.5, 0.24, 1.2, 0.5, 0.35);
		SetCVar("dnd_nofx", 0);
	}
	Delay(const:5);
}

Script "DND Special FX Handle" OPEN CLIENTSIDE {
	int pnum = ConsolePlayerNumber(); // interesting detail here: open script normally has no activator, but client runs this as soon as they connect so this value matters, not playernumber
	while(PlayerInGame(pnum) || PlayerIsSpectator(pnum)) {
		if(GetCVar("dnd_nofx"))
			Thing_Remove(SPECIAL_FX_TID);
		Delay(const:1);
	}
}

// Added because the above script doesn't work for SP case
Script "DnD Special FX Handle - SP" ENTER CLIENTSIDE {
	if(GameType() != GAME_SINGLE_PLAYER)
		Terminate;
	while(true) {
		if(GetCVar("dnd_nofx"))
			Thing_Remove(SPECIAL_FX_TID);
		Delay(const:1);
	}
}

Script "DnD Remove Check Special" (int sp, int extra) CLIENTSIDE {
	// remove if spectator
	if(!PlayerInGame(ConsolePlayerNumber()))
		Thing_Remove(0);
	else if(!extra) {
		if(ConsolePlayerNumber() != sp - 1)
			Thing_Remove(0);
	}
	else if(extra == DND_SPECIAL_RESEARCH) {
		// research remove depends on if the guy has this research
		// no player check in SP
		if(GameType() != GAME_SINGLE_PLAYER) {
			if(ConsolePlayerNumber() != (sp & 0xFFFF) - 1 || CheckActorResearchStatus(ConsolePlayerNumber() + P_TIDSTART, sp >> 16))
				Thing_Remove(0);
		}
		else if(CheckActorResearchStatus(ConsolePlayerNumber() + P_TIDSTART, sp >> 16))
			Thing_Remove(0);
	}
	else if(extra & (DND_SPECIAL_ORB | DND_SPECIAL_TALENTCAPSULE | DND_SPECIAL_ELIXIR | DND_SPECIAL_CHARM)) {
		if((sp & 0xFFFF) != 256 && ConsolePlayerNumber() != (sp & 0xFFFF) - 1)
			Thing_Remove(0);
		else
			SetActorProperty(0, APROP_ALPHA, 1.0);
	}
}

Script 920 (int mode) {
	if(!mode) {
		SlowPlayer(0, SF_FREEZE, 0);
	}
	else {
		// hacky fix: while this player can load, hold back on fixing player movement
		while(HardcoreSet && PlayerCanLoad[PlayerNumber()])
			Delay(17);
		if(mode == 1) {
			if(!CheckInventory("ShowingMenu")) // don't break menu functionality
				SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
			RestoreRPGStat(RES_PLAYERSPEED);
			TakeInventory("P_Frozen", 1);
		}
		else if(mode == 2) {
			if(!CheckInventory("MinigunFiring"))
				SlowPlayer(0.75, 0, 0);
		}
	}
}

Script 921 (int type, int duration) {
	Delay(duration);
	switch(type) {
		case 0:
			GiveInventory("ChangeReflect", 1);
			TakeInventory("P_Invulnerable", 1);
		break;
		case 1:
			SetPlayerProperty(0, 0, PROP_BUDDHA);
			TakeInventory("P_Invulnerable", 1);
		break;
	}
}

script 922 (int actor_num, int radius, int totalactors) {
     int angle = GetUserVariable(0, "user_angle") * 360; 
     Thing_ChangeTID(0, REFLECTFXTID);
	 SetActivatorToTarget(0);
	 int owner = ActivatorTID();
	 // the below arrangement ensures each and every actor gets a unique TID relative to the owner's tid
	 int newtid =  REFLECTFXTID + ((owner % 100) + 1) * totalactors + actor_num;
	 Thing_ChangeTID(REFLECTFXTID, newtid);
	 
	 int cx = radius * cos(angle) + GetActorX(owner);
	 int cy = radius * sin(angle) + GetActorY(owner);
	 int cz = GetActorZ(owner) + 32.125;
	 
	 SetActorPosition(newtid, cx, cy, cz, 0);
}

// Till 922 are reserved for mons.c

Script "DND Special Player Hurt" (int type, int percent) {
	int vit, thisactor, hp;
	if(!type) {
		vit = CheckInventory("PSTAT_Vitality");
		thisactor = ActivatorTID();
		SetActivator(0, AAPTR_TARGET);
		Thing_Damage2(thisactor, vit / 4, "VileGhostDrain");
		vit = Clamp_Between(vit / 4, 1, vit);
		hp = Clamp_Between(GetActorProperty(0, APROP_HEALTH) + vit, 1, MonsterProperties[thisactor - DND_MONSTERTID_BEGIN].maxhp);
		SetActorProperty(0, APROP_HEALTH, hp);
		Spawn("RegenEffectSpawner", GetActorX(0), GetActorY(0), GetActorZ(0), 0);
	}
	else if(type == 1) {
		if(CheckInventory("DarkLichGhostDamageCooldown"))
			Terminate;
		GiveInventory("DarkLichGhostDamageCooldown", 1);
		vit = GetActorProperty(0, APROP_HEALTH) / 10;
		thisactor = ActivatorTID();
		SetActivator(0, AAPTR_TARGET);
		Thing_Damage2(thisactor, vit, "BigSpiderVoid");
	}
	else if(type == 2) {
		thisactor = ActivatorTID();
		vit = GetActorProperty(0, APROP_HEALTH);
		vit *= percent;
		vit /= 100;
		SetActivator(0, AAPTR_TARGET);
		Thing_Damage2(thisactor, vit / 2, "Magical");
	}
}

Script "DnD Setup Shootable" (void) {
	if(!ActivatorTID())
		GiveShootableTID();
}

// Monster scaler -- add scaling stuff here
Script "DnD Monster Scale" (int monsterid, int isSummoned) {
	if(!ActivatorTID())
		GiveMonsterTID();
	//printbold(s:"Monster id: ",d:monsterid,s:", (After Spawn) Mob spawn hp:", d:GetActorProperty(0, APROP_SpawnHealth), s:", Mob hp:", d:GetActorProperty(0, APROP_Health), s:", Mob realhp",d:realhp);
	//Make sure mob gets to right amount of hp at this point
	int maxhp, base, add, pcount = PlayerInformationInLevel[PLAYERLEVELINFO_COUNTATSTART], this = ActivatorTID(), realhp = MonsterData[monsterid].health;
	int m_id = this - DND_MONSTERTID_BEGIN;
	if(!pcount)
		pcount = 1;
	
	LoadMonsterTraits(monsterid);
	if(isSummoned)
		MonsterProperties[m_id].trait_list[DND_SUMMONED] = true;
	
	if(GetCVar("dnd_monsterscale")) {
		// scaling code -- delay is because monsters are initialized before enter scripts are executed
		while(DnD_StateChecker[DND_STATECHECK_PLAYERJOIN] < PlayerInformationInLevel[PLAYERLEVELINFO_COUNTATSTART])
			Delay(3);
		//This delay needs a check
		//Delay(35); // wait just in case someone leaves, disconnect script will correct the level
		pcount = PlayerInformationInLevel[PLAYERLEVELINFO_COUNTATSTART];
		if(!pcount)
			pcount = 1;
		maxhp = ScaleMonster(pcount, realhp);
	}
	else {
		maxhp = realhp;
		MonsterProperties[m_id].basehp = maxhp;
		MonsterProperties[m_id].maxhp = maxhp;
		MonsterProperties[m_id].level = 1;
	}		
	MonsterProperties[m_id].id = monsterid;

	if(GetCVar("dnd_enable_elites") && !MonsterProperties[m_id].trait_list[DND_LEGENDARY] && RollEliteChance() && PlayerInformationInLevel[PLAYERLEVELINFO_LEVEL] / pcount >= GetCVar("dnd_elite_spawnlevel")) {
		MonsterProperties[m_id].isElite = true;
		
		//printbold(s:"(Before Elite bonuses) Mob spawn hp:", d:GetActorProperty(0, APROP_SpawnHealth), s:", Mob hp:", d:GetActorProperty(0, APROP_Health), s:", Mob realhp",d:realhp);
		
		// Elite bonuses
		base = maxhp;
		add = base * DND_ELITE_HPSCALE / 100;
		maxhp = base + add;
		MonsterProperties[m_id].basehp = maxhp;
		MonsterProperties[m_id].maxhp = maxhp;
		// roll more traits randomly
		int traitcount = random(DND_MIN_ELITEMODS, DND_MAX_ELITEMODS);
		//printbold(s:"DecideEliteTraits: TID: ", d: ActivatorTID());
		DecideEliteTraits(traitcount);
		// Double Health
		if(MonsterProperties[m_id].trait_list[DND_VITAL]) {
			base = maxhp;
			add = base * DND_ELITE_VITAL_SCALE / 100;
			maxhp = Clamp_Between(base + add, 1, INT_MAX);
			MonsterProperties[m_id].basehp = maxhp;
			MonsterProperties[m_id].maxhp = maxhp;
		}
	}
	
	//printbold(s:"(Before dmg) Mob spawn hp:", d:GetActorProperty(0, APROP_SpawnHealth), s:", Mob hp:", d:GetActorProperty(0, APROP_Health), s:", Mob realhp",d:realhp, s:", Mob current hp:", d:maxhp);
	int dmg = GetActorProperty(0, APROP_SpawnHealth) - GetActorProperty(0, APROP_Health);
	SetActorProperty(0, APROP_HEALTH, maxhp);
	
	ScaleMonsterMass(MonsterProperties[m_id].level);
	Clamp_Between(dmg, 0, maxhp + 1);
	Thing_Damage2(ActivatorTID(), dmg, "None");
	//Mob might actually be dead by this point.
	if (GetActorProperty(0, APROP_Health) > maxhp) //In the rare case the mob keeps the very high hp, if some reason SetActorProperty fails.
		Thing_Damage2(ActivatorTID(), GetActorProperty(0, APROP_Health) + 1, "None"); //Just kill it
		
	// doomguy thing
	if(MapInfo[DND_MAPINFO_HASDOOMGUY] && isDemon())
		GiveInventory("Doomguy_Perk25_Weakness", 1);
	
	// handle all innate resists, weaknesses etc.
	HandleMonsterClassInnates(monsterid);
	
	GiveInventory("DnD_MonsterSetupDone", 1);
	
	SetResultValue(0);
}

// properties holds stuff like the monster's type, demon, robotic etc.
Script "DnD Custom Monster Scale" (int properties, int traits, int traits2) {
	if(!ActivatorTID())
		GiveMonsterTID();
	int maxhp, base, add, pcount = PlayerCount(), this = ActivatorTID(), realhp = GetActorProperty(0, APROP_SPAWNHEALTH);
	int m_id = this - DND_MONSTERTID_BEGIN;
	if(!pcount)
		pcount = 1;
	if(GetCVar("dnd_monsterscale")) {
		// scaling code -- delay is because monsters are initialized before enter scripts are executed
		while(DnD_StateChecker[DND_STATECHECK_PLAYERJOIN] < PlayerCount())
			Delay(3);
		if(!pcount)
			pcount = 1;
		maxhp = ScaleMonster(pcount, realhp);
	}
	else {
		maxhp = realhp;
		MonsterProperties[m_id].basehp = maxhp;
		MonsterProperties[m_id].maxhp = maxhp;
		MonsterProperties[m_id].level = 1;
	}

	MonsterProperties[m_id].id = DND_CUSTOMMONSTER_ID;
	MonsterProperties[m_id].properties = properties;

	if(GetCVar("dnd_enable_elites") && !MonsterProperties[m_id].trait_list[DND_LEGENDARY] && RollEliteChance() && PlayerInformationInLevel[PLAYERLEVELINFO_LEVEL] / pcount >= GetCVar("dnd_elite_spawnlevel")) {
		MonsterProperties[m_id].isElite = true;

		// Elite bonuses
		base = maxhp;
		add = base * DND_ELITE_HPSCALE / 100;
		maxhp = base + add;
		MonsterProperties[m_id].basehp = maxhp;
		MonsterProperties[m_id].maxhp = maxhp;
		// roll more traits randomly
		int traitcount = random(DND_MIN_ELITEMODS, DND_MAX_ELITEMODS);
		DecideEliteTraits(traitcount);
		// Double Health
		if(MonsterProperties[m_id].trait_list[DND_VITAL]) {
			base = maxhp;
			add = base * DND_ELITE_VITAL_SCALE / 100;
			maxhp = Clamp_Between(base + add, 1, INT_MAX);
			MonsterProperties[m_id].basehp = maxhp;
			MonsterProperties[m_id].maxhp = maxhp;
		}
	}

	int dmg = GetActorProperty(0, APROP_SpawnHealth) - GetActorProperty(0, APROP_Health);
	SetActorProperty(0, APROP_HEALTH, maxhp);
	
	ScaleMonsterMass(MonsterProperties[m_id].level);
	Clamp_Between(dmg, 0, maxhp + 1);
	Thing_Damage2(ActivatorTID(), dmg, "None");
	//Mob might actually be dead by this point.
	if (GetActorProperty(0, APROP_Health) > maxhp) //In the rare case the mob keeps the very high hp
		Thing_Damage2(ActivatorTID(), GetActorProperty(0, APROP_Health) + 1, "None"); //Just kill it
		
	// doomguy thing
	if(MapInfo[DND_MAPINFO_HASDOOMGUY] && properties & DND_MTYPE_DEMON_POW)
		GiveInventory("Doomguy_Perk25_Weakness", 1);
}

// Decide monster to spawn on a certain monster category given weight list
Script "DnD Monster Spawner" (int category) {
    // count and initialization
	int i = 0;
    // add up total count and weight sum of category
    if(!Monster_VariationCounts[category]) {
        for(; i < MAX_MONSTER_VARIATIONS && Monster_Weights[category][i] != DND_MWEIGHT_ENDMARKER; Monster_CategoryWeightSum[category] += Monster_Weights[category][i], ++i);
		Monster_VariationCounts[category] = i;
	}
		
    int sum = Monster_CategoryWeightSum[category];
    bool picked = false;
    // for each bin, do condition check, see if roll fits in a range
    // wait for the players to enter (returns 0 to imply everyone ready)
    while(PlayerInformationInLevel[PLAYERLEVELINFO_MAXLEVEL] <= 0 || PlayersNotReadyForHardcore())
        Delay(const:10);
	picked = false;
	// throttle the spawns
	if(GameType() != GAME_SINGLE_PLAYER)
		Delay(17 * (random(0, DND_MAX_MONSTERDELAY) + 1)); //Added 1 second for player level to be accurate first (people might load at last second).
	int roll, bin;
	// roll legendary monster chance and do checks of it
	if(!MadeLegendary && category == DND_CYBERDEMONID && random(1, 100) <= Clamp_Between(GetCVar("dnd_legendary_chance"), 1, 100) && PlayerInformationInLevel[PLAYERLEVELINFO_MAXLEVEL] >= 25) {
		MadeLegendary = 1;
		// decide which legendary
		roll = random(1, DND_MAX_LEGENDARY);
		SetActorState(0, StrParam(s:"Leg", d:roll), true);
		ACS_NamedExecuteAlways("DND Announcer", 0, DND_ANNOUNCER_LEGENDARYMONSTER);
	}
	else {
		int factor = Clamp_Between(GetCVar("dnd_monster_variation_factor"), 1.0, 5.0);
		while(!picked) {
			roll = random(0, sum);
			bin = 0;
			// start i from 0 here, because bin starts from 0 the added weight should be consistent with where we started
			// count is 1 more than the index allowed as is expected, so if it picked the next we must subtract 1 from bin
			for(i = 0; bin < Monster_VariationCounts[category] && i < roll; ++bin)
				i += Monster_Weights[category][bin];
			--bin;
			// go to vanilla if bin is 0
			if(!bin) {
				SetActorState(0, "Vanilla", true);
				picked = true;
			}
			else {
				// dumb spawner, just check weight
				if(!GetCVar("dnd_usesmartmonsterspawner")) {
					SetActorState(0, StrParam(s:"Var", d:bin), true);
					picked = true;
				}
				else {
					// investigate later if the bias is proper
					int m_level = Monster_Weights[category][bin] << 16;
					int ratio = FixedDiv(Monster_Weights[category][0] << 16, m_level);
					int bias = random(factor / 5, factor);
					if(ratio <= bias + PlayerInformationInLevel[PLAYERLEVELINFO_MAXLEVEL] * FixedDiv(1.0, ratio) / 5) {
						SetActorState(0, StrParam(s:"Var", d:bin), true);
						picked = true;
					}
				}
			}
		}
	}
}

Script 961 (int type, int amt, int item) {
	if(type == 2)
		SetActorProperty(0, APROP_ALPHA, 0.5);
	else if(type == 3)
		SetActorProperty(0, APROP_ALPHA, 1.0);
	else if(type == 4) {
		if(!item) {
			//MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].traits = amt;
			Log(s:"I shouldn't have been called by ", s:GetActorClass(0));
		}
	}
	else if(type == 5) {
		SetResultValue(GetActorProperty(0, APROP_HEALTH) < MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp >> 1);
	}
	else if(type == 6) {
		// don't judge me, this shit just doesn't work in decorate of zan 3.0...
		Spawn("DarkHealEffectSpawner", GetActorX(0), GetActorY(0), GetActorZ(0));
	}
	else if(type == 7) {
		//printbold(s:"ActivatorTID",d:ActivatorTID(),s:" basehp",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].basehp,s:" maxhp",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp,s:" level",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].level,s:" id",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].id,s:" traits",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].traits,s:" traits2",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].traits2,s:" nameskip",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].nameskip,s:" properties",d:MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].properties);
		amt = MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp;
		if(!amt)
			amt = GetActorProperty(0, APROP_SpawnHealth);
		SetResultValue(amt);
	}
}

// 962 - 969 are in mons.c

script 970 (int type, int actor_num, int radius) CLIENTSIDE {
	int angle, this, owner, cx, cy, cz;
	if(!type) {
		this = ActivatorTID();
		angle = (GetUserVariable(this, "user_angle") * 360) % 1.0;
		owner = GetActorProperty(this, APROP_HEALTH);
		cx = radius * cos(angle) + GetActorX(owner);
		cy = radius * sin(angle) + GetActorY(owner);
		cz = GetActorZ(owner) + 108.0;

		SetActorPosition(this, cx, cy, cz, 0);
	}
	else {
		angle = (GetUserVariable(0, "user_angle") * 360) % 1.0;
		this = ActivatorTID();
		owner = GetActorProperty(this, APROP_HEALTH);
		
		if(CheckInventory("AvatarOnAttack")) {
			angle = (60 * (actor_num - 1)) * 360;
			SetUserVariable(this, "user_angle", 60 * (actor_num - 1));
		}
		
		cx = radius * cos(angle) + GetActorX(owner);
		cy = radius * sin(angle) + GetActorY(owner);
		cz = GetActorZ(owner) + 108.0;
		SetActorPosition(this, cx, cy, cz, 0);
	}
}

// 971 - 972 are in mons.c

Script 973 (int mode) { // Avatar tid / targeter
	if (mode == 1) {
		int owner = ActivatorTID(), curdist;
		
		SetActivator(owner, AAPTR_TARGET);
		int target = ActivatorTID();
		SetActivator(owner);
		
		for(int i = 0; i < AVATAR_SOUL_COUNT; i++) {
			// choose closest target
			curdist = INT_MAX;
			for(int j = 0; j < MAXPLAYERS; j++) {
				int dist = fdistance(owner, P_TIDSTART + j);
				if(GetActorProperty(P_TIDSTART + j, APROP_HEALTH) > 0 && dist < curdist) {
					target = P_TIDSTART + j;
					curdist = dist;
				}
			}
			
			SetActorPosition(owner, GetActorX(owner), GetActorY(owner), GetActorZ(owner) + 56.0, 0);
			SpawnProjectile(owner, "HolyMissile2", GetActorAngle(owner), 128, 0, 0, AVATAR_SOUL_TID);
			SetActorPosition(owner, GetActorX(owner), GetActorY(owner), GetActorZ(owner) - 56.0, 0);
			SetActorPosition(AVATAR_SOUL_TID, GetActorX(AVATAR_SOUL_TID), GetActorY(AVATAR_SOUL_TID), GetActorZ(AVATAR_SOUL_TID) + 54.0, 0);
			SetActivator(AVATAR_SOUL_TID);
			SetPointer(AAPTR_TARGET, owner);
			SetPointer(AAPTR_TRACER, target);
			int dx = GetActorX(target) - GetActorX(AVATAR_SOUL_TID);
			int dy = GetActorY(target) - GetActorY(AVATAR_SOUL_TID);
			SetActorAngle(AVATAR_SOUL_TID, VectorAngle(dx, dy));
			Thing_ChangeTID(AVATAR_SOUL_TID, 0);
			SetActivator(owner);
			Delay(12);
		}
	}
	else {
		if(GetActorProperty(0, APROP_HEALTH) < MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp / 3)
			GiveInventory("AcolyteSummoner", 1);
	}
}

// Form the blade vortex
Script 974 (int radius) {
	int tid = ActivatorTID(); // Owner TID
	int newtid = tid + VORTEXTIDSTART + 16 * ((tid + 1) % 100);
	
	for(int m = 0; m < 16; m++)
		Thing_Remove(newtid + m);
	
	int cx, cy, cz;
	cz = GetActorZ(tid) + 26.125;
	int pang = GetActorAngle(tid) >> 8;
	
	// i goes to 16, pang += 16 to complete 256, 360 degrees of doom.
	for(int i = 0; i < 16; ++i) {
		// initial radius is 1/32th of the intended to make all of the blades spawn properly
		cx = GetActorX(tid) + radius*cos(pang<<8)/32;
		cy = GetActorY(tid) + radius*sin(pang<<8)/32;
		pang += 16;
		Spawn("VortexBlade", cx, cy, cz, newtid + i, 0); // Basically, first 1032 are for playernum 0, then a 32 is added and it becomes 1064 etc... Max Value is 3144. (For 64th player)
		SetActivator(newtid + i);
		SetPointer(AAPTR_TARGET, tid);
		SetActivator(tid);
	}
	ACS_executeAlways(975, 0, tid, pang, radius); // Align coords
}

// Constantly rotate the ring
Script 975 (int tid, int pang, int radius) {
	// Create the phase
	int angadd = 0;
	int bladetid = tid + VORTEXTIDSTART + 16 * ((tid + 1) % 100);
	str tocheck = "VortexTimer";
	if(CheckInventory("Ability_Arcanery"))
		tocheck = "VortexTimer2";
	while(1) {
		if(!CheckActorInventory(tid, tocheck) || GetActorProperty(tid, APROP_HEALTH) <= 0) {
			for(int m = 0; m < 16; ++m)
				Thing_Remove(bladetid + m);
			angadd = 0;
			break;
		}
		
		int cx, cy;
		int cz = GetActorZ(tid) + 26.125;
		
		for(int i = 0; i < 16; ++i) {
			pang += 16;
			cx = GetActorX(tid) + radius*cos((pang+angadd)<<8);
			cy = GetActorY(tid) + radius*sin((pang+angadd)<<8);
			SetActorPosition(bladetid + i, cx, cy, cz, 0);
		}
		angadd += 2;
		Delay(const:1);
	}
}

Script "DnD Golgoth Health Check" (void) {
	Delay(const:35);
	int comp = MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].maxhp / 2;
	while(GetActorProperty(0, APROP_HEALTH) < comp)
		Delay(const:10);
	GiveInventory("DnD_Boolean", 1);
	GiveInventory("MakeNoPain", 1);
}

Script "DnD Monster Trait Take" (int flag1, int flag2, int flag3, int flag4) {
	MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[flag1] = false;
	if(flag2 != -1)
		MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[flag2] = false;
	if(flag3 != -1)
		MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[flag3] = false;
	if(flag4 != -1)
		MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[flag4] = false;
	SetResultValue(0);
}

Script "DnD Monster Trait Give" (int flag1, int flag2, int flag3, int flag4) {
	MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[flag1] = true;
	if(flag2 != -1)
		MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[flag2] = true;
	if(flag3 != -1)
		MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[flag3] = true;
	if(flag4 != -1)
		MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[flag4] = true;
	SetResultValue(0);
}

// Checks Ankh
Script "DnD Ankh Checker" (void) {
	while(1) {
		if(PlayerInGame(PlayerNumber()) && !CheckInventory("ParsingData")) {
			// ankh check
			if(!CheckInventory("P_Invulnerable") && GetActorProperty(0, APROP_HEALTH) == 1 && !CheckInventory("Intervened") && IsAccessoryEquipped(ActivatorTID(), DND_ACCESSORY_ANGELICANKH) && CheckInventory("CanIntervene")) {
				GiveInventory("Intervention", 1);
				GiveInventory("Intervened", 1);
				TakeInventory("CanIntervene", 1);
				GiveInventory("InterventionFXSpawner", 1);
				GiveInventory("P_Invulnerable", 1);
				ACS_ExecuteAlways(921, 0, 1, INTERVENTION_DURATION);
			}
		}
		Delay(const:5);
	}
}

Script "DnD Player Levelup Check" (void) {
	HandleLevelup();
}

// Weapon tip display
Script 977 (int type, int itemnum) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
	    Terminate;
	if(!type && !CheckInventory("ParsingData")) { // weapon tip
		LocalAmbientSound("Weapon/Popup", 127);
		SetHudSize(640, 480, 1);
		SetFont("MSGBOX2");
		HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVEID, CR_UNTRANSLATED, 515.0 + ScreenResOffsets[1], 120.0, 4.0, 1.0, 1.0);
		SetFont(Weapons[itemnum][WEAPON_ICON]);
		HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVEICO, CR_UNTRANSLATED, 537.1 + ScreenResOffsets[1], 80.0, 4.0, 1.0, 1.0);
		SetFont("OBJFONT");
		HudMessage(s:Weapons[itemnum][WEAPON_SLOT]; HUDMSG_FADEINOUT, SURVIVETOPTEXTID, CR_GOLD, 416.0 + ScreenResOffsets[1], 68.0, 4.0, 1.0, 1.0);

		SetHudSize(960, 600, 1);
		SetHudClipRect((632.0 + 3 * ScreenResOffsets[1] / 2) >> 16, 96, 320, 128, 320, 1);
		HudMessage(s:WeaponPickupText[itemnum]; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, 632.1 + 3 * ScreenResOffsets[1] / 2, 104.1, 4.0, 1.0, 1.0);
		SetHudClipRect(0, 0, 0, 0);
	}
}

// Checking for Bonuses
Script "DnD Bonus Detect" (void) {
	int KillBonus, ItemBonus, SecretBonus, BonusBonus;
	int curkills, curitems, cursecrets, bonusval;
	SetActivator(-1);
	Delay(const:35);

	while(1) {
		if(!GetCVar("dnd_disablelevelbonus")) {
			curkills = GetLevelInfo(LEVELINFO_KILLED_MONSTERS);
			curitems = GetLevelInfo(LEVELINFO_FOUND_ITEMS);
			cursecrets = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
			
			if(GetLevelInfo(LEVELINFO_TOTAL_MONSTERS)) {
				if(!KillBonus && curkills >= GetLevelInfo(LEVELINFO_TOTAL_MONSTERS)) {
					DistributeBonus(BONUS_KILL);
					KillBonus = 1;
				}
			}
			else
				KillBonus = 2; // means there were no monsters at all

			if(GetLevelInfo(LEVELINFO_TOTAL_ITEMS)) {
				if(!ItemBonus && curitems >= GetLevelInfo(LEVELINFO_TOTAL_ITEMS)) {
					DistributeBonus(BONUS_ITEM);
					ItemBonus = 1;
				}
			}
			else
				ItemBonus = 2; // means there were no items at all
			
			if(GetLevelInfo(LEVELINFO_TOTAL_SECRETS)) { // if there are some secrets
				if(!SecretBonus && cursecrets >= GetLevelInfo(LEVELINFO_TOTAL_SECRETS)) {
					DistributeBonus(BONUS_SECRET);
					SecretBonus = 1;	
				}
			}
			else
				SecretBonus = 2;
			
			// if there was at least some bonus involved!
			if(KillBonus && ItemBonus && SecretBonus && !BonusBonus && (KillBonus + ItemBonus + SecretBonus != 6)) {
				Delay(4);
				DistributeBonus(BONUS_BONUS);
				BonusBonus = 1;
			}
		}
		Delay(const:17);
	}
}

Script "DnD Bonus Message State" (int bonustype) CLIENTSIDE {
	for(int i = 0; i < DND_BONUS_SCREENTIME; ++i)
		Delay(const:35);
	DnD_StateChecker[bonustype + 1] = 0;
};

Script "DnD Bonus Message Show" (int bonustype) CLIENTSIDE {
	// add 1 to skip playerjoin state
	DnD_StateChecker[bonustype + 1] = 1;
	ACS_NamedExecuteAlways("DnD Bonus Message State", 0, bonustype);
	Delay(const:3);
	int y = DnD_BonusMessageY(bonustype);
	ShowBonusMessage(bonustype, y);
}

Script "DnD Monster Scanner Picker" ENTER {
	int this = ActivatorTID();
	int monhp, monlvl, monsterid, mmaxhp, healthbarcolor, nameskip, monprop;
	bool monelite = false;
	int tic = 0;
	while(true) {
		SetActivatorToTarget(this);
		int montid = ActivatorTID();
		// clean-up later
		if(!CheckInventory("EnemyInDisguise") && (CheckActorProperty(0, APROP_Friendly, 0) || CheckInventory("FriendlyInDisguise")))
			healthbarcolor = 1;
		else if(CheckActorProperty(0, APROP_Friendly, 1) || CheckInventory("EnemyInDisguise"))
			healthbarcolor = 0;
		if(ActivatorTID() == this || CheckInventory("EnemyInDisguise")) {
			// player has no targets
			SetActivator(this);
			SetInventory("TargetMaximumHealth", 0);
			SetInventory("TargetCurrentHealth", 0);
			SetInventory("TargetLevel", 0);
			SetInventory("TargetIsWhat", 0);
			SetInventory("TargetIsElite", 0);
			SetInventory("TargetProperties", 0);
		}
		else {
			// this is known to us anyway
			monhp = GetActorProperty (0, APROP_Health);
			// this part retrieves data from server
			// if not a pet
			bool pet_state = false;
			if(!IsPet(montid)) {
				mmaxhp = MonsterProperties[montid - DND_MONSTERTID_BEGIN].maxhp;
				monlvl = MonsterProperties[montid - DND_MONSTERTID_BEGIN].level;
				monsterid = MonsterProperties[montid - DND_MONSTERTID_BEGIN].id;
				nameskip = MonsterProperties[montid - DND_MONSTERTID_BEGIN].nameskip;
				monelite = MonsterProperties[montid - DND_MONSTERTID_BEGIN].isElite;
				monprop = MonsterProperties[montid - DND_MONSTERTID_BEGIN].properties;
			}
			else {
				mmaxhp = PetMonsterProperties[montid - DND_PETTID_BEGIN].maxhp;
				monlvl = PetMonsterProperties[montid - DND_PETTID_BEGIN].level;
				monsterid = PetMonsterProperties[montid - DND_PETTID_BEGIN].id;
				nameskip = PetMonsterProperties[montid - DND_PETTID_BEGIN].nameskip;
				monelite = PetMonsterProperties[montid - DND_PETTID_BEGIN].isElite;
				monprop = PetMonsterProperties[montid - DND_PETTID_BEGIN].properties;
				pet_state = true;
			}
			SetActivator(this);
			// this part uses the inventory method to avoid having to constantly sync variables between clients
			SetInventory("TargetMaximumHealth", mmaxhp);
			SetInventory("TargetCurrentHealth", monhp);
			SetInventory("TargetHealthBarColor", healthbarcolor);
			SetInventory("TargetLevel", monlvl);
			SetInventory("TargetIsWhat", monsterid);
			SetInventory("TargetIsElite", monelite);
			SetInventory("TargetProperties", monprop);
			if(!(tic % 2))
				ACS_NamedExecuteWithResult("DnD Sync Monster Traits To Client", montid, pet_state);
			SetCVarString(Strparam(s:"DND_NAMETAGS", i:PlayerNumber()), GetActorProperty(montid, APROP_NAMETAG));
			tic = (tic + 1) % 2;
		}
		// fixes initialization bug
		SetActivator(this);
		Delay(const:1);
		
	}
}

Script "DnD Monster Kill Ice Chunks" (int r, int h) CLIENTSIDE {
	int numChunks = Max(5, (r * h) / 32);
	for(int i = Max(24, numChunks + Random(0, numChunks / 4 - 1)); i >= 0; --i) {
		int xo = GetActorX(0) + r * random(-1.0, 1.0);
		int yo = GetActorY(0) + r * random(-1.0, 1.0);
		int zo = GetActorZ(0) + h * random(0, 1.0);

		SpawnForced("IceChunkCS", xo, yo, zo, DND_ICECHUNK_TID);
		SetActorVelocity(DND_ICECHUNK_TID, random(-1.0, 1.0), random(-1.0, 1.0), ((zo - GetActorZ(0)) / h) * 4, 0, 0);
		Thing_ChangeTID(DND_ICECHUNK_TID, 0);
	}

	SetResultValue(0);
}

Script "DnD Reset Monster Trait CS" (int id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;

	if(client_trait_list.tid != id) {
		client_trait_list.count = 0;
		client_trait_list.tid = id;
	}
	SetResultValue(0);
}

Script "DnD Sync Monster Trait CS" (int index, int v1, int v2, int v3) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;

	client_trait_list.list[index] 		= 	v1;
	client_trait_list.list[index + 1] 	= 	v2;
	client_trait_list.list[index + 2] 	= 	v3;
	// not important as long as it can be 0 and something more than 1
	client_trait_list.count += (v1 + v2 + v3) * (client_trait_list.count < 15);
	SetResultValue(0);
}

Script "DnD Sync Monster Trait CS Single" (int index, int v) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;

	client_trait_list.list[index] = v;
	// not important as long as it can be 0 and something more than 1
	client_trait_list.count += v;
	SetResultValue(0);
}

Script "DnD Sync Monster Traits To Client" (int id, int isPet) {
	ACS_NamedExecuteWithResult("DnD Reset Monster Trait CS", id);
	int i;
	if(!isPet) {
		id -= DND_MONSTERTID_BEGIN;
		for(i = 0; i < MAX_MONSTER_TRAITS - 3; i += 3)
			ACS_NamedExecuteWithResult("DnD Sync Monster Trait CS", i, MonsterProperties[id].trait_list[i], MonsterProperties[id].trait_list[i + 1], MonsterProperties[id].trait_list[i + 2]);
		// get remaining
		while(i < MAX_MONSTER_TRAITS) {
			ACS_NamedExecuteWithResult("DnD Sync Monster Trait CS Single", i, MonsterProperties[id].trait_list[i]);
			++i;
		}
	}
	else {
		id -= DND_PETTID_BEGIN;
		for(i = 0; i < MAX_MONSTER_TRAITS; ++i)
			if(PetMonsterProperties[id].trait_list[i])
				ACS_NamedExecuteWithResult("DnD Sync Monster Trait CS", i, PetMonsterProperties[id].trait_list[i], PetMonsterProperties[id].trait_list[i + 1], PetMonsterProperties[id].trait_list[i + 2]);
		while(i < MAX_MONSTER_TRAITS) {
			ACS_NamedExecuteWithResult("DnD Sync Monster Trait CS Single", i, PetMonsterProperties[id].trait_list[i]);
			++i;
		}
	}
	SetResultValue(0);
}

Script "DnD Monster Scanner" ENTER CLIENTSIDE {
	int mmaxhp, hdisp, monhp, monlevel, monid;
	bool isPet = false;
	while(true) {
		// if we have any shared items in our player queue to turn, do turn them
		mmaxhp = CheckInventory("TargetMaximumHealth");
		if(mmaxhp && GetCVar("dnd_monsterbars")) {
			monhp = CheckInventory("TargetCurrentHealth");
			monlevel = CheckInventory("TargetLevel");
			monid = CheckInventory("TargetIsWhat");
			isPet = client_trait_list.list[DND_PET];
			hdisp = (monhp * 100 / mmaxhp);
			int i, j = 0.0;
			if(CheckInventory("TargetHealthBarColor"))
				SetFont("MNRHPBAR");
			else
				SetFont("MNGHPBAR");
			
			SetHudSize(800, 600, 0);
			HudMessage(s:"a"; 1, MONSTER_BARID, CR_UNTRANSLATED, 400.0, 27.0, 1);
			if(!isPet) {
				if(!CheckInventory("TargetProperties"))
					SetFont(MonsterTypeInfo[GetMonsterType(monid)][MOSNTER_TYPE_INFO_ICON]);
				else {
					SetFont(MonsterTypeInfo[InferMonsterPower(CheckInventory("TargetProperties"))][MOSNTER_TYPE_INFO_ICON]);
				}
			}
			else
				SetFont(MonsterTypeInfo[GetPetMonsterType(monid)][MOSNTER_TYPE_INFO_ICON]);
			HudMessage(s:"a"; 1, MONSTER_TYPEICONID, CR_UNTRANSLATED, 270.0, 27.0, 1);
			HudMessage(s:"a"; 1, MONSTER_TYPEICONID - 1, CR_UNTRANSLATED, 540.0, 27.0, 1);
			// inner text
			SetFont ("MONFONT");
			HudMessage(s:"Lvl: ", i:monlevel, s:"  ", i:monhp, s:"/", i:mmaxhp; 1, MONSTER_TEXTID, CR_WHITE, 400.0, 27.0, 1);
			str prefix = "";
			if(CheckInventory("TargetIsElite"))
				prefix = "\cfElite ";
			if(client_trait_list.list[DND_LEGENDARY])
				HudMessage(s:prefix, s:GetCVarString(Strparam(s:"DND_NAMETAGS", i:PlayerNumber())); 1, MONSTER_NAMEID, CR_RED, 404.4, 10.0, 1);
			else if(IsMonsterIdBoss(monid))
				HudMessage(s:prefix, s:GetCVarString(Strparam(s:"DND_NAMETAGS", i:PlayerNumber())); 1, MONSTER_NAMEID, CR_ORANGE, 404.4, 10.0, 1);
			else
				HudMessage(s:prefix, s:GetCVarString(Strparam(s:"DND_NAMETAGS", i:PlayerNumber())); 1, MONSTER_NAMEID, CR_WHITE, 404.4, 10.0, 1);
				
			for (i = 0; i <= hdisp && i <= 100; ++i) {
				j = j + 2.0;
				if(CheckInventory("TargetHealthBarColor"))
					SetFont("FILLCRIT");
				else
					SetFont("FILLNORM");
				if(monhp)
					HudMessage(s:"a"; 1, MONSTER_BARFILLID + i, CR_GREEN, 303.0 + j, 27.0, 1);
			}
			i = j = 0;
			// show monster traits
			// legendary monsters show no traits at all
			if(client_trait_list.list[DND_LEGENDARY]) {
				SetFont ("MONFONT");
				HudMessage(s:"\c[D1]Legendary Monster"; 1, MONSTER_TRAITID + j, CR_WHITE, 404.4, 44.0 + 8.0 * j, 1);
			}
			else {
				if(client_trait_list.count) {
					SetFont ("MONFONT");
					for(i = 0; i < MAX_MONSTER_TRAITS; ++i) {
						if(client_trait_list.list[i]) {
							HudMessage(s:GetTraitColorCode(i), s:MonsterTraits[i]; 1, MONSTER_TRAITID + j, CR_WHITE, 404.4, 44.0 + 8.0 * j, 1);
							++j;
						}
					}
				}
			}
		}
		Delay(const:1);
	}
}

// Calculate chance of item drop, drop if needed (out of 100)
Script "DnD Item Dropchance" (int basechance) {
	SetActivatorToTarget(0);
	basechance <<= 16;
	basechance /= 100;
	SetResultValue(RunDefaultDropChance(ActivatorTID() - P_TIDSTART, CheckInventory("MonsterIsElite"), basechance));
}

// Some Generic Chat Log Script
Script "DnD Message Logger" (int type, int id, int id_is_special) CLIENTSIDE {
	if(PlayerNumber() != ConsolePlayerNumber()) Terminate;
	if(!type)
		Log(s:TemporaryWeaponMsg[id - TEMPBEGIN]);
	else if(type == 1)
		Log(s:WeaponMsg[id]);
    else if(type == 2) {
		if(id_is_special)
			Log(s:ResearchPrefix, s:Research_Label[id >> 16], s:"!");
		else
			Log(s:ResearchPrefix, s:Research_Label[id], s:"!");
	}
	else if(type == 3)
		Log(s:SharedItemMessage[id]);
	else if(type == 4)
		Log(s:"\ccHealth pickup : \c[Y5]Demon Essence\c-");
	else
		Log(s:ChestKeyText[id]);
}

// Pickup check for the temporary weapons
Script 986 (int wepnum, int type) {
	int who = ActivatorTID();
	if(type) {
		SetActivatorToTarget(0);
		who = ActivatorTID();
	}
	wepnum -= TEMPBEGIN;
	int t = 0, j = 0;
	for(int i = 0; i < MAXTEMPWEPS; ++i) {
		// gross hack, fix later
		j = i;
		if(i > DND_TEMPAMMO_BLADEHITS)
			++j;
		if(i == wepnum) {   
			// do we have max ammo on this weapon
			if(CheckActorInventory(who, TemporaryAmmos[j]) == GetAmmoCapacity(TemporaryAmmos[j]))
			  ++t;
		}
		else if(CheckActorInventory(who, TemporaryWeapons[i][TEMPWEP_NAME])) { // do I have any temp weapon
			if(!CheckActorInventory(who, TemporaryAmmos[j])) // hack to prevent a desync problem
				TakeActorInventory(who, TemporaryWeapons[i][TEMPWEP_NAME], 1);
			else
				++t;
		}
	}
	SetResultValue(!t);
}

Script "DnD On Respawn" RESPAWN {
	Thing_ChangeTID(0, P_TIDSTART + PlayerNumber());
	TakeInventory("PowerReflection", 1);
	TakeInventory("DnD_PDead", 1);
	RestoreRPGStat(RES_PERK_SHARP | RES_PERK_ENDURANCE | RES_ACCURACY | RES_EXPLOSIONRADIUS | RES_ALLRESISTS);
	ACS_NamedExecuteAlways("DnD Health Pickup", 0, 100, 4); // full heal
	// if game mode is coop, we don't want any sort of reset on death here! make sure it's not coop
	/*if(GetCVar("Survival")) {
		if(CheckInventory("CurrentLives"))
			TakeInventory("CurrentLives", 1);
		else {
			Reset_RPGInfo(RESET_LEVEL | RESET_CREDIT | RESET_STATS | RESET_PERKS);
			StatListOpened[PlayerNumber()] = 0;
			ResetWeaponMods(PlayerNumber());
			ResetPlayerBonuses(PlayerNumber());
		}
	}*/
	
	// for properly setting up taltos translucency when spawn protection is on
	while(GetActorProperty(0, APROP_INVULNERABLE) && !CheckInventory("P_Invulnerable"))
		Delay(const:5);
	if(CheckInventory("TaltosUp"))
		GiveInventory("TaltosEffect", 1);
		
	ACS_NamedExecuteAlways("DnD Punisher Perk50 Display", 0, true);
}

Script 988 (int wepslot, int type) {
	int res = 0;
	if(!type) {
		if(CheckSlotWeapon(wepslot))
			res = 1;
	}
	else if(type == 1) {
		if(GetCVar("sv_weaponstay"))
			res = 1;
	}
	SetResultValue(res);
}

// Clear upon leaving
Script "DnD On Disconnect" (int pnum) DISCONNECT {
	//Just to make sure a rare lvl 1 char load bug doesn't happen
	PlayerLoaded[pnum] = 0;
	PlayerWillBeSaved[pnum] = false;
	PlayerTransferred[pnum] = false;

	ACS_NamedExecuteAlways("DnD Class Select Cleanup", 0);
	// if someone quit during countdown just remove this
	HudMessage(s:""; HUDMSG_PLAIN, DND_HARDCORE_SCREENID, CR_RED, 320.0, 240.0, 1);
	StatListOpened[pnum] = 0;
	PlayerCanLoad[pnum] = 0;
	BreakTradesBetween(pnum);
	
	// if player was in middle of saving, don't accidently interfere if player leaves early
	// save accumulated stats when player leaves
	// things saved are in DnD_Activity.h
	ACS_NamedExecuteAlways("DnD Save Player Orb and Stat Data", 0, pnum);
	PlayerDied[pnum] = 0;
}

// End of level checks
Script "DnD On Unloading" UNLOADING {
	int tid;
	MapInfo[DND_MAPINFO_MAPCHANGED] = true;
	//ResetFieldInventory(); //Field items are global, but new items simply replace old ones no questions asked, so no need to clear this.
	BreakAllTrades();
	for(int i = 0; i < MAXPLAYERS; ++i) {
		tid = P_TIDSTART + i;
	    if(PlayerWillBeSaved[i] && GetActorProperty(tid, APROP_HEALTH) > 0) { //Now using PlayerWillBeSaved, because some servers might use multiple lives setting.
		    GiveActorInventory(tid, "LevelToken", 1);
			StatListOpened[i] = 0;
            GiveActorInventory(tid, "Budget", (1 + HardcoreSet) * ((MapDifficulty + 1) + DND_BUDGET_BASE));
			GiveActorInventory(tid, "RoundsSurvived", 1);
		}
		// Check quests
		if(active_quest_id != -1)
			CheckMapExitQuest(i, active_quest_id);
	}
}

// Enter level checks
Script "DnD Player Setup" ENTER {
	ACS_NamedExecuteAlways("DnD Class Select Cleanup", 0);
	
	Thing_ChangeTID(0, P_TIDSTART + PlayerNumber());
	SetInventory("SphereMade", 0);
	SetInventory("OrbUseType", 0);
	SetInventory("OrbResult", 0);
	// reset anything related to kill sprees on entering a new map
	SetInventory("SpreeXP", 0);
	SetInventory("DnD_SpreeTimer", 0);
	SetInventory("DnD_SpreeCountdownRunning", 0);
	SetInventory("DnD_MultikillCounter", 0);
	SetInventory("LevelExp", 0);
	SetInventory("LevelCredit", 0);
	SetInventory("AllMapOnlyOnce", 0);
	SetInventory("Punisher_Perk50_Counter", 0);
	// now everyone has this, no need to buy
	GiveInventory("Ability_MonsterInfo", 1);
	CleanPetStuff();
	//SetInventory("MapDifficultyClientside", MapDifficulty); //Already to be set somewhere else.
	SetInventory("DnD_MasterHealerQuest_HealAmount", 0); // reset this upon map restart
	SetInventory("DnD_BoughtArmor", 0);
	int pnum = PlayerNumber(), curlvl, i = 0;
	int temp = 0;
	bool wait_other_players = false;
	SetInventory("PlayersNotReady", PlayerCount());
	SetInventory("PlayerIsLoggedIn", PlayerIsLoggedIn(pnum)); //Only used to let player know if he's logged in at start (clientside doesn't have this function).
	GiveInventory("ParsingData", 1);
	ResetAllSpellCooldowns(); // reset all leftover cooldowns
	
	// begin hardcore countdown
	if(HardcoreSet && (GetCVar("dnd_mode") >= DND_MODE_SOFTCORE)) {
		GiveInventory("P_Frozen", 1);
		GiveInventory("DontAttack", 1);
		while(GetGameModeState() == GAMESTATE_COUNTDOWN)
			Delay(const:17);
		SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
		SetPlayerProperty(0, 2, PROP_INVULNERABILITY);

		PlayerWillBeSaved[pnum] = true;
		// display countdown timer
		if (!PlayerLoaded[pnum]) {
			PlayerCanLoad[pnum] = 1;
			SetInventory("CanLoad", 1);
			
			// Place resetting things from loading here, because char creation also needs them (otherwise new player gets stuff from loaded player that left game).
			// reset weapons
			// take all weapons
			for(i = 0; i < MAXWEPS; ++i)
				TakeInventory(Weapons[i][WEAPON_NAME], 1);
			for(i = 1; i <= 9; ++i)
				TakeInventory(StrParam(s:"H_WeaponSlot", d:i), 1);

			// take all abilities
			for(i = 0; i < MAXABILITIES; ++i)
				SetInventory(AbilityInfo[i], 0);
			
			// reset currently acquired inventory
			for(i = 0; i < MAX_INVENTORY_BOXES; ++i) {
				PlayerInventoryList[pnum][i].topleftboxid = 0;
				PlayerInventoryList[pnum][i].item_type = DND_ITEM_NULL;
			}

			ResetPlayerInventory(pnum);
			
			// remove whatever feature this player had on them prior to loading (just in case)
			for(i = 0; i < MAX_CHARMS_EQUIPPABLE; ++i)
				if(Charms_Used[pnum][i].item_type != DND_ITEM_NULL)
					RemoveItemFeatures(i, DND_SYNC_ITEMSOURCE_CHARMUSED);
			ResetPlayerCharmsUsed(pnum);
			
			ACS_NamedExecuteAlways("DND Hardcore Timer", 0);
		}
		else
			PlayerCanLoad[pnum] = 0; //it's in else part, because loop might end early otherwise.
		
		// 0 means they are ready
		int players_not_ready = PlayersNotReadyForHardcore();
		while(players_not_ready && i < (DND_HARDCORE_LOADTIME << 1) && PlayerInGame(pnum)) {
			//Update logged in status to client as needed by hardcode timer.
			if (CheckInventory("PlayerIsLoggedIn") != PlayerIsLoggedIn(pnum))
				SetInventory("PlayerIsLoggedIn", PlayerIsLoggedIn(pnum));
			// we loaded, reduce on wait time
			if(!CheckInventory("CanLoad")) {
				PlayerCanLoad[pnum] = 0;
				// message the players to wait for an amount of players to ready up (also update not ready count)
				players_not_ready = PlayersNotReadyForHardcore();
				if (players_not_ready > 0) //This is actually possible, even here!
					ACS_NamedExecuteAlways("DND Wait For Other Players Message", 0, players_not_ready);
			}
			++i;
			if ((i == (DND_HARDCORE_LOADTIME << 1)) && PlayerIsLoggedIn(pnum) && CheckInventory("CanLoad"))
				if (ACS_NamedExecuteWithResult("DnD Load Character Check", pnum, 0) == 11) //DND_CHARLOADED
					ACS_ExecuteAlways(1001,0,0);
				else if (ACS_NamedExecuteWithResult("DnD Create Character Check", pnum, 0) == 1) //DND_LOGIN_CREATECHAROK
					ACS_ExecuteAlways(1003,0,0);
			Delay(const:18);
		}
	}
	
	if(!PlayerInGame(pnum)) {
		PlayerCanLoad[pnum] = 0;
		Terminate;
	}
	SetInventory("PlayersNotReady", 0);
	
	++DnD_StateChecker[DND_STATECHECK_PLAYERJOIN];
	
	// Checks if we should set the lives to the inventory or not (also includes one time execute things)
	// when player joins for the first time - when loading char, this section gets skipped
	if(CheckInventory("SetMyLives")) {
		// can only reflect once per map
		SetInventory("ReflectCount", 0);
		SetInventory("Intervened", 0);
		SetInventory("CanIntervene", 1);
		TakeInventory("SetMyLives", 1);
		SetInventory("ShowingMenu", 0);
		Reset_RPGInfo(RESET_LEVEL | RESET_CREDIT | RESET_STATS | RESET_PERKS);
		StatListOpened[pnum] = 0;
		GiveInventory(" Fists ", 1);
		GiveInventory(" Pistol ", 1);
		if(GetCVar("dnd_allresearchesfound"))
			GiveAndDoAllResearch();
		ACS_NamedExecuteAlways("DND Menu Cleanup", 0);
	}
	
	if(PlayerInGame(pnum)) {
		curlvl = GetStat(STAT_LVL);
		PlayerInformationInLevel[PLAYERLEVELINFO_LEVEL] += curlvl;
		++PlayerInformationInLevel[PLAYERLEVELINFO_COUNTATSTART];
		if(PlayerInformationInLevel[PLAYERLEVELINFO_MAXLEVEL] < curlvl)
			PlayerInformationInLevel[PLAYERLEVELINFO_MAXLEVEL] = curlvl;
		if(PlayerInformationInLevel[PLAYERLEVELINFO_MINLEVEL] > curlvl)
			PlayerInformationInLevel[PLAYERLEVELINFO_MINLEVEL] = curlvl;
	}
	
	ClearQuestCheckers();
	
	if(HardcoreSet) {
		ACS_NamedExecuteAlways("DND Hardcore Monster Message", 0);
		// wait for monsters to appear
		Delay(17 * (DND_MAX_MONSTERDELAY + 1));
	}
	
	// Load period is finished, now check for level stats
	ACS_NamedExecute("DnD Bonus Detect", 0);
	PlayerDied[pnum] = 0;
	PlayerTransferred[pnum] = false;
	TakeInventory("DnD_PDead", 1);
	SpawnedChests = 1;
	SetInventory("CanLoad", 0); //Usually it is 0 at this point, but make sure it is anyways.
	PlayerCanLoad[pnum] = 0;
	SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
	SetPlayerProperty(0, 0, PROP_INVULNERABILITY);
	TakeInventory("P_Frozen", 1);
	GiveInventory("DontAttackRemove", 1);

	// force sync client stuff
	GiveInventory("DnD_SyncMe", 1);
	ACS_NamedExecuteAlways("DnD Force Sync Player Bonuses", 0);
	
	// if map changed, reset accessory stuff
	if(MapInfo[DND_MAPINFO_MAPCHANGED]) {
		SetInventory("ReflectCount", 0);
		SetInventory("Intervened", 0);
		SetInventory("P_Invulnerable", 0);
	}
	TakeInventory("PowerReflection", 1);
	// order of the above reset is important
	if(!GetCVar("sv_maxlives"))
		SetInventory("CurrentLives", 0);
	else
		SetInventory("CurrentLives", GetCvar("sv_maxlives") - 1);
	
	RestoreRPGStat(RES_PERK_SHARP | RES_PERK_ENDURANCE | RES_ACCURACY | RES_EXPLOSIONRADIUS | RES_ALLRESISTS);
	
	// a little hack to prevent ankh going off when finishing maps with 1 hp
	if(GetActorProperty(0, APROP_HEALTH) == 1 && CheckInventory("CanIntervene"))
		HealThing(1);
	
	// Give Temporal Sphere
	if(CheckInventory("Ability_Temporal") && !CheckInventory("TemporalSphere"))
        GiveInventory("TemporalSphere", 1);
	
	if(CheckInventory("QuestCompletionToken"))
		ACS_NamedExecuteAlways("DND Quest Complete", 0);

	// for properly setting up taltos translucency when spawn protection is on
	while(GetActorProperty(0, APROP_INVULNERABLE) && !CheckInventory("P_Invulnerable"))
		Delay(const:7);
	if(CheckInventory("TaltosUp"))
		GiveInventory("TaltosEffect", 1);
	TakeInventory("QuestWasPicked", 1); // helps sync clientside variable Quest_Pick_Done
	while(!Quest_Pick_Done)
		Delay(const:10);
	
	GiveInventory("QuestWasPicked", 1);
	if(active_quest_id != -1) {
		SetInventory("ActiveQuestID", active_quest_id + 1);
		ACS_NamedExecuteAlways("DND Announcer", 0, DND_ANNOUNCER_QUEST);
	}
	else
		SetInventory("ActiveQuestID", 0);
		
	// moved here to attempt to fix the reflect pendant issue
	// just in case
	if(DnD_StateChecker[DND_STATECHECK_PLAYERJOIN] >= PlayerCount())
		MapInfo[DND_MAPINFO_MAPCHANGED] = false;
	
	while(CheckInventory("TipBoxOpen"))
		Delay(const:17);
	// give some time for completion thing to get through
	SetInventory("QuestCompletionToken", 0);
	if(HardcoreSet && !CheckInventory("HardcoreDebuff"))
		GiveInventory("HardcoreDebuff", 1);
		
	if(isPlayerClass(DND_PLAYER_DOOMGUY) && CheckInventory("Doomguy_Perk25"))
		MapInfo[DND_MAPINFO_HASDOOMGUY] = true;
	
	SetInventory("DnD_PTotalLevel", PlayerInformationInLevel[PLAYERLEVELINFO_LEVEL]);
	// for zombie quest to work
	TakeInventory("DnD_ShotUndead", 1);
	TakeInventory("ParsingData", 1);
	if(!(HardcoreSet && (GetCVar("dnd_mode") >= DND_MODE_SOFTCORE)))
		ACS_NamedExecuteAlways("DnD Ankh Checker", 0);
}

Script "Force Sync Player Global Data" (void) {
	SyncAllItemData(DND_SYNC_ITEMSOURCE_CHARMUSED);
	SyncAllItemData(DND_SYNC_ITEMSOURCE_PLAYERINVENTORY);
	SyncAllItemData(DND_SYNC_ITEMSOURCE_STASH);
	SyncAllClientsideVariables();
}

// Control for ammo capacity
Script 992 (int t, int simple) {
	SetResultValue(CheckAmmoPickup(t, simple));
}

Script "DnD On Player Enter CS" ENTER CLIENTSIDE {
	ResetPlayerScriptChecks();
	if(ConsolePlayerNumber() != PlayerNumber()) 
		Terminate;
	if(GetCVar("dnd_showmapinfo"))
		SetInventory("ShowMapInfo", 1);
		
	ACS_NamedExecuteAlways("DnD Punisher Perk50 Display", 0, true);
	// Set the ammo capacity
	// SetAmmoCapacity("ExpVisual", LevelCurve[CheckInventory("Level") - 1]);
}

Script "DND Monster Damage Scale" (int flags) {
	if(flags & 1) // target
		SetactivatorToTarget(0);
	int this = ActivatorTID() - DND_MONSTERTID_BEGIN;
	int res = Clamp_Between(MonsterProperties[this].level, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 0.01, 1.0);
	if(MonsterProperties[this].isElite)
		res = FixedMul(res, 1.0 + GetEliteBonusDamage());
	if(MonsterProperties[this].trait_list[DND_EXTRASTRONG])
		res = FixedMul(res, 1.0 + DND_ELITE_EXTRASTRONG_BONUS);
	if(MonsterProperties[this].level > 50)
		res = FixedMul(res, 1.0 + DND_AFTER50_INCREMENT_DAMAGE);
	if(flags & DND_WDMG_ISRIPPER)
		res >>= 1;
	SetResultValue(res >> 16);
}

// saved here for future in case damage values fuck up
Script "DND Monster Damage Scale2" (int dmg, int flags) {
	if(flags & 1) // target
		SetactivatorToTarget(0);
	int this = ActivatorTID() - DND_MONSTERTID_BEGIN;
	int res = Clamp_Between(MonsterProperties[this].level, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 0.01, 1.0);
	if(MonsterProperties[this].isElite)
		res = FixedMul(res, 1.0 + GetEliteBonusDamage());
	if(MonsterProperties[this].trait_list[DND_EXTRASTRONG])
		res = FixedMul(res, 1.0 + DND_ELITE_EXTRASTRONG_BONUS);
	if(MonsterProperties[this].level > 50)
		res = FixedMul(res, 1.0 + DND_AFTER50_INCREMENT_DAMAGE);
	SetResultValue((dmg * res) >> 16);
}

// A generic checker function
Script 994 (int type, int extra) {
	int res = 0;
	if(type == 1) {
		if(!extra) { // attack check
			if(CheckInventory("FireLeft") && CheckInventory("AkimboClipLeft"))
				res = 2;
			if(!CheckInventory("FireLeft") && CheckInventory("AkimboClipRight"))
				res = 3;
			// force reload when out of ammo
			if(!res || (!CheckInventory("AkimboClipLeft") && !CheckInventory("AkimboClipRight")))
				res = 1;
		}
		else { // reload check
			if(CheckInventory("Clip")) {
				int cap = GetAmmoCapacity("AkimboClipLeft");
				res = CheckInventory("AkimboClipLeft") < cap || CheckInventory("AkimboClipRight") < cap;
			}
		}
	}
	else if(type == 3)
		res = GetPlayerInput(-1, INPUT_BUTTONS) & BT_ALTATTACK;
	else if(type == 4)
		res = Clamp_Between(GetCVar("dnd_respawn_count"), 1, 0x7FFFFFFF);
	else if(type > 4 && type < 9) { // keep until cleanup
		if(GetCVar("dnd_monsterscale")) {
			int bonus = 0;
			if(type == 5) {
				bonus = (MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[DND_EXTRASTRONG]) ? DND_ELITE_EXTRASTRONG_BONUS : 0;
				res = (Clamp_Between(MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].level, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 0.01, 1.0));
				if(MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].isElite)
					res = FixedMul(res, 1.0 + DND_ELITE_DMGSCALE + bonus);
				res >>= 16;
			}
			else if(type == 6) {
				SetActivatorToTarget(0);
				bonus = (MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[DND_EXTRASTRONG]) ? DND_ELITE_EXTRASTRONG_BONUS : 0;
				res = (Clamp_Between(MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].level, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 0.01, 1.0));
				if(MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].isElite)
					res = FixedMul(res, 1.0 + DND_ELITE_DMGSCALE + bonus);
				res >>= 16;
			}
			else if(type == 7) {
				bonus = (MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].trait_list[DND_EXTRASTRONG]) ? DND_ELITE_EXTRASTRONG_BONUS : 0;
				res = (Clamp_Between(extra, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 0.01, 1.0));
				if(MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].isElite)
					res = FixedMul(res, 1.0 + DND_ELITE_DMGSCALE + bonus);
				res >>= 16;
			}
			else if(type == 8)
				res = MonsterProperties[ActivatorTID() - DND_MONSTERTID_BEGIN].level;
		}
	}
	else if(type == 9)
		res = GetPlayerInput(-1, INPUT_BUTTONS) & BT_RELOAD;
	else if(type == 10) { // checks shell clip size
		str tocheck = "ShellSize_8N";
		str ammotype = "Shell";
		str weptype = "SpecialAmmoMode_3";
		if(extra == 1)
			tocheck = "ShellSize_8";
		else if(extra == 2)
			tocheck = "ShellSize_10";
		else if(extra == 3)
			tocheck = "ShellSize_12";
		else if(extra == 4) {
			tocheck = "ShellSize_2";
				weptype = "SpecialAmmoMode_3X";
		}
		ammotype = SpecialAmmoNames[CheckInventory(weptype)][SPECIALAMMO_NAME];
		res = CheckInventory(ammotype) > CheckInventory(tocheck);
	}
    else if(type == 11) // has research?
        res = CheckResearchStatus(extra) == RES_NA;
    else if(type == 12)
        res = CheckInventory("LightningStacks");
    else if(type == 13) {
        // check riotgun mode switch possibility
        int norm = !!CheckInventory("RiotgunShell"), nitro = !!CheckInventory("NitroShell"), explo = !!CheckInventory("ExplodingShell");
        // only let switching if more than 1 is available
        res = norm || explo || nitro;
    }
	else if(type == 14)
		res = GetActorProperty(0, APROP_INVULNERABLE);
	SetResultValue(res);
}

Script "DnD Check Special Match" (int multispecial) {
	int sp = GetActorProperty(0, APROP_MASS), res = 0;
	int who = 0;
	SetActivatorToTarget(0);
	who = ActivatorTID();
	if(!multispecial)
		res = who - P_TIDSTART == sp - 1;
	else {
		// 256 means anyone can pick or see w.e
		if((sp & 0xFFFF) == 256)
			res = 1;
		else {
			res = who - P_TIDSTART == (sp & 0xFFFF) - 1;
			if(multispecial & DND_SPECIAL_RESEARCH)
				res = res && !CheckActorResearchStatus(who, sp >> 16);
		}
	}
	//printbold(d:res);
	SetResultValue(res);
}

Script "DnD Blood Rune" (void) {
	str togive = "FakeBloodPower";
	if(CheckInventory("Ability_Arcanery"))
		togive = "FakeBloodPowerBetter";
	ActivatorSound("items/bloodrun", 127);
	GiveInventory(togive, 1);
}

// Custom Powerup script
Script "DnD Player On Hit" (int power) {
	int this, temp;
	
	if(!CheckInventory("Armor"))
		SetInventory("DnD_ArmorType", 0);
		
	if(CheckInventory("HateCheck")) {
		this = ActivatorTID();
		SetActivator(0, AAPTR_TARGET);
		if(ActivatorTID() != this)
			GiveInventory("HateWeakness", 1);
	}
	// necro chance
	if(GetArmorType("NecroArmor", PlayerNumber()) && !CheckInventory("NecroSpikeCooldown") && !random(0, 2)) {
		GiveInventory("NecroSpikeShooter", 1);
		GiveInventory("NecroSpikeCooldown", 1);
	}
	// player heal on hit check
	temp = GetPlayerAttributeValue(PlayerNumber(), INV_EX_CHANCE_HEALMISSINGONPAIN);
	if(temp) {
		// roll chance
		// upper 16 bits hold the chance
		if(random(1, 100) <= (temp >> 16)) {
			// heal for missing health
			GiveInventory("VeilHealFXSpawner", 1); // use same fx as veil for now
			ACS_NamedExecuteAlways("DnD Health Pickup", 0, ((temp & 0xFFFF) * GetMissingHealth()) / 100);
		}
	}
	
	// monster might be thief, check it
	temp = GetActorProperty(0, APROP_TARGETTID);
	if(MonsterProperties[temp - DND_MONSTERTID_BEGIN].trait_list[DND_THIEF]) {
		// get current weapon's ammo and steal it
		str cur_ammo = "";
		do {
			cur_ammo = GetWeaponAmmoType(GetCurrentWeaponID(), random(0, 1));
		} while(cur_ammo == " ");
		TakeInventory(cur_ammo, CheckInventory(cur_ammo) * DND_ELITE_THIEFRATE / 100);
	}

	// marine is unaffected by curses at lvl 50
	if(MonsterProperties[temp - DND_MONSTERTID_BEGIN].trait_list[DND_HEXFUSION] && random(1, 100) <= DND_HEXFUSION_CHANCE && !CheckInventory("Marine_Perk50"))
		ApplyRandomCurse();
}

// Backpack / Research script
Script 996 (int type, int id) {
    if(!type) {
		if (CheckInventory("BackpackCounter") < DND_MAX_BACKPACK) {
			// give additional ones for db save
			int add_backpack_amount = 1;
			if(GetCVar("dnd_firstbackpackold"))
				add_backpack_amount += 4;
			//Respect the max backpack amount
			SetInventory("BackpackCounter", Min(CheckInventory("BackpackCounter") + add_backpack_amount, DND_MAX_BACKPACK));

			SetAllAmmoCapacities();
			//ACS_ExecuteAlways(993, 0, 1); //Why did this call script 993?
		}
		int i,j;
		//Give base 1/20 of initial ammo on backpack pickup.
		for(i = 0; i < MAX_SLOTS - 1; ++i) //Except souls
			for(j = 0; j < MAX_AMMOTYPES_PER_SLOT && AmmoInfo[i][j].initial_capacity != -1; ++j)
				GiveInventory(AmmoInfo_Str[i][j][AMMOINFO_NAME], ((AmmoInfo[i][j].container_value / 5) + (AmmoInfo[i][j].container_value / 5) * (GetPlayerAttributeValue(PlayerNumber(), INV_AMMOGAIN_INCREASE) + (CheckInventory("Perk_Munitionist") * DND_MUNITION_GAIN))/100));
    }
    else if(type == 1) {
        // give research
        GiveResearch(id, false);
    }
}

// Dash Script
Script 997 (void) NET {
	bool soundplayed = 0;
	int input;
	int angle;
	int velX;
	int velY;
	int velZ;
	Delay(3);
	if(CheckInventory("Ability_Dash") && !CheckInventory("DashDelay") && GetActorVelZ(0) >= 0.0 && !CheckInventory("DashDisabled") && !CheckInventory("P_Frozen") && GetActorProperty(0, APROP_HEALTH) > 0) {
		for(int i = 0; i < 4; ++i) {
			input = GetPlayerInput(-1, INPUT_BUTTONS);
			//oldInput = GetPlayerInput(-1, INPUT_OLDBUTTONS);
			if(IsButtonHeld(input, settings[i][0])) {
			//if(IsButtonPressed(input, oldInput, settings[i][0])){
				angle = GetActorAngle(0) + settings[i][1];
				
				if(GetActorZ(0) - GetActorFloorZ(0) > 0) {
					velX = FixedMul(cos(angle), SD_DASHSPEED);
					velY = FixedMul(sin(angle), SD_DASHSPEED);
					velZ = -GetActorVelZ(0) + SD_DASHJUMP;
				}
				
				else {
					velX = FixedMul(cos(angle), SD_DASHSTRONG);
					velY = FixedMul(sin(angle), SD_DASHSTRONG);
					velZ = 0.0;
				}
				
				SetActorVelocity(0, velX, velY, velZ, true, false);
				if(!soundplayed) {
					ActivatorSound("Player/Dash", SD_SOUNDVOLUME);
					soundplayed = 1;
				}
				GiveInventory("DashEffect", 1);
				GiveInventory("DashDelay", 1);
			}
		}
		soundplayed = 0;
	}
}

// reload script -- rewrite sometime
Script 998 (int wepnum, int side, int extra) {
	int base, amt;
	str totake, baseammo = "Clip";
	if(!wepnum) {
		base = GetAmmoCapacity("MGClip");
		totake = "MGClip";
	}
	else if(wepnum == 1) {
		base = GetAmmoCapacity("AkimboClipLeft");
		if(!side)
			totake = "AkimboClipLeft";
		else
			totake = "AkimboClipRight";
	}
	else if(wepnum == 2) {
		base = GetAmmoCapacity("MGClip2");
		totake = "MGClip2";
	}
	else if(wepnum == 3) {
		base = GetAmmoCapacity("MGClip4");
		totake = "MGClip4";
	}
	else if(wepnum == 4) {
        if(side) {
			if(extra == -1)
				extra = CheckInventory("SpecialAmmoMode_4");
            int need = GetAmmoCapacity("RiotgunClip") - CheckInventory("RiotgunClip");
            if(need) {
                if(CheckInventory(SpecialAmmoNames[extra][SPECIALAMMO_NAME]) >= need)
                    GiveInventory("RiotgunClip", need);
                else
                    SetInventory("RiotgunClip", CheckInventory(SpecialAmmoNames[extra][SPECIALAMMO_NAME]));
            }
            Terminate;
        }
        else {
            base = GetAmmoCapacity("MGClip5");
            totake = "MGClip5";
        }
	}
	else if(wepnum == 5) {
		base = GetAmmoCapacity("AcidClip");
		baseammo = "AcidAmmo";
		totake = "AcidClip";
	}
	else if(wepnum == 6) {
		base = GetAmmoCapacity("MGClip6");
		baseammo = "FusionCell";
		totake = "MGClip6";
	}
	else if(wepnum == 7) {
		base = GetAmmoCapacity("MGClip7");
		totake = "MGClip7";
	}
	
	amt = base - CheckInventory(totake);
	
	if(CheckInventory(baseammo) < base) {
		GiveInventory(totake, CheckInventory(baseammo));
		TakeInventory(baseammo, amt);
	}
	else {
		TakeInventory(baseammo, amt);
		GiveInventory(totake, amt);
	}
}

// Regeneration
Script "DnD Periodic Regeneration" ENTER {
	int cur, amt, lim, pnum = PlayerNumber(), this = ActivatorTID();
	while(PlayerInGame(pnum)) {
		if(isAlive()) {
			if(CheckInventory("Ability_Regeneration") && !IsAccessoryEquipped(this, DND_ACCESSORY_GRYPHONBOOTS)) {
				cur = GetActorProperty(0, APROP_HEALTH);
				// if we got the quest, our lim is half our cap, otherwise 1/3rd the cap
				lim = GetSpawnHealth();
				if(CheckInventory("DnD_QuestReward_RegenCap"))
					lim /= 2;
				else
					lim /= 3;
				lim += GetPlayerAttributeValue(pnum, INV_REGENCAP_INCREASE);
				amt = lim * DND_REGEN_PERCENT / 100;
				
				// cyborg perk
				if(CheckInventory("Cyborg_Perk25")) {
					amt *= DND_CYBORG_CYBER_MULT;
					amt /= DND_CYBORG_CYBER_DIV;
				}
				
				if(!CheckInventory("RegenStopper") && cur < lim) {
					if(cur > lim - amt)
						GiveInventory("HealthBonusX", amt);
					else
						GiveInventory("HealthBonusX", lim - cur);
					GiveInventory("RegenEffect", 1);
					LocalAmbientSound("ability/regen", 127);
				}
			}
		
			cur = GetArmorType("CyberneticArmor", pnum);
			if(cur && !IsAccessoryEquipped(this, DND_ACCESSORY_GRYPHONBOOTS)) {
				lim = GetArmorSpecificCap(DND_CYBERNETICARMOR_AMOUNT);
				lim += GetPlayerAttributeValue(pnum, INV_REGENCAP_INCREASE);
				amt = lim * DND_REGEN_PERCENT / 100;
				lim >>= 1; // half limit for this armor
				
				// cyborg perk
				if(CheckInventory("Cyborg_Perk25")) {
					amt *= DND_CYBORG_CYBER_MULT;
					amt /= DND_CYBORG_CYBER_DIV;
				}
				
				if(cur && cur < lim && !CheckInventory("P_Damaged")) {
					GiveInventory("NewArmorBonus", Min(amt, lim - cur));
					GiveInventory("CyberneticEffect", 1);
					LocalAmbientSound("items/armorbonus", 127);
				}
				
				if(active_quest_id == QUEST_10SPREES && !IsQuestComplete(this, QUEST_10SPREES) && CheckInventory("DnD_BerserkQuest_SpreeCounter") >= DND_QUEST_BERSERK_SPREEREQ)
					CompleteQuest(this, QUEST_10SPREES);
			}
		}
		Delay(35);
	}
}

// for elites with pierce armor flag
Script "DND Pierce Check" () {
	int owner = GetActorProperty(0, APROP_TARGETTID);
	if(CheckFlag(owner, "PIERCEARMOR"))
		SetActorFlag(0, "PIERCEARMOR", 1);
}

Script "DND Riotgun Decide" (void) {
	// check riotgun mode switch clip
	str mode = "RiotgunShell";
	if(CheckInventory("SpecialAmmoMode_4") == AMMO_EXPLOSIVESHELL)
		mode = "ExplodingShell";
	else if(CheckInventory("SpecialAmmoMode_4") == AMMO_NITROGENSHELL)
		mode = "NitroShell";
	// either clip full or special ammo clip full
	if((CheckInventory("RiotgunClip") == GetAmmoCapacity("RiotgunClip") || CheckInventory("RiotgunClip") == CheckInventory(mode)) && CanSwitchMode(AMMO_TYPE_SHELL2, SPWEP_MG))
		SetInventory("RiotgunReloadModeDecide", 2); // mode switch
	else if(CheckInventory("RiotgunClip") < GetAmmoCapacity("RiotgunClip") && CheckInventory(mode) > CheckInventory("RiotgunClip"))
		SetInventory("RiotgunReloadModeDecide", 1); // reload
}

Script "DND Elite Special FX" (void) CLIENTSIDE {
	int i, waitcounter = 0;
	// to ensure things are synced properly between clients
	while(IsAlive()) {
		for(i = 0; i < DND_ELITE_FX_DENSITY; ++i) {
			//printbold(s:"DND Elite Special FX - Density Effect: TID: ", d:ActivatorTID(), s:", i: ", d: i);
			if (!IsAlive()) //Mob might actually die while this is running.
				Terminate; //Could have used break but it's faster to just Terminate.
			GiveInventory("EliteFXSpawner", 1);
			Delay(1);
		}
		Delay(8);
	}
	Terminate;
}

Script 1000 (int isSoftcore) {
	int i;
	// casual mode has higher drop rates
	if(isSoftcore != 2) {
		for(i = 0; i < MAXFLAGS; ++i)
			ConsoleCommand(StrParam(s:FlagCheckList[i], s: " ", d:FlagAcceptedValues[i]));
		for(i = 0; i < MAXDNDFLAGS; ++i)
			ConsoleCommand(StrParam(s:DNDFlagCheckList[i], s: " ", d:DNDFlagAcceptedValues[i]));
		// handle fixed point shit here because getcvar is stupid with them
		ConsoleCommand("sv_coop_damagefactor 1.0");
		ConsoleCommand("dnd_monster_dmgscalepercent 0.04");
		ConsoleCommand("dnd_researchdroprate 0.00249");
	}
	if(isSoftcore < 2) {
		if(isSoftcore) {
			ConsoleCommand("dnd_mode 1"); //Softcore
		}
		else {
			ConsoleCommand("dnd_mode 2"); //Hardcore
		}
		ConsoleCommand("authhostname auth.zandronum.com:16666");
	}
	else if(isSoftcore < 4) {
		// softcore == 2 => casual mode, default settings
		// beginner mode, force smart monster spawner
		// 4 or 5 are simulated softcore / hardcore for singleplayer or local servers -- no database but ruleset is the same
		if(isSoftcore == 3) {
			ConsoleCommand("dnd_allresearchesfound 0");
			ConsoleCommand("dnd_usesmartmonsterspawner 1");
		}
	}
	ConsoleCommand("map map01");
}

Script "DND Announcer" (int num, int extra, int to) CLIENTSIDE {
	if(to)
		SetActivator(to + P_TIDSTART - 1);
	while(CheckInventory("TipBoxOpen"))
		Delay(const:35);
	GiveInventory("TipBoxOpen", 1); // just in case this wasn't given before
	if(num != DND_ANNOUNCER_TRADEREQUEST)
		LocalAmbientSound("Quest/Announce", 127);
	if(num == DND_ANNOUNCER_LEGENDARYMONSTER)
		AmbientSound("LegendaryHere", 127);
	SetHudSize(640, 480, 1);
	SetFont("QUESTPOP");
	if(num != DND_ANNOUNCER_LEGENDARYMONSTER)
		HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVETOPTEXTID, CR_UNTRANSLATED, 570.0 + ScreenResOffsets[1], 80.0, 4.0, 1.0, 1.0);
	else
		HudMessageBold(s:"A"; HUDMSG_FADEINOUT, SURVIVETOPTEXTID, CR_UNTRANSLATED, 570.0 + ScreenResOffsets[1], 80.0, 4.0, 1.0, 1.0);
	SetFont("OBJFONT");
	SetHudSize(960, 600, 1);
	if(num == DND_ANNOUNCER_QUEST)
		HudMessage(s:"New Quest! Press \cvview quest\c- key!"; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, 740.1 + 3 * ScreenResOffsets[1] / 2, 140.1, 4.0, 1.0, 1.0);
	else if(num == DND_ANNOUNCER_ATTRIBPOINT)
		HudMessage(s:"You have unspent attribute points!\n    Spend them in \cvDnD Menu!\c-"; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, 730.1 + 3 * ScreenResOffsets[1] / 2, 140.1, 4.0, 1.0, 1.0);
	else if(num == DND_ANNOUNCER_NEWCLASSPERK)
		HudMessage(s:"New class perk unlocked! Go to\n\cvDnD Menu\c- help section for info!"; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, 730.1 + 3 * ScreenResOffsets[1] / 2, 140.1, 4.0, 1.0, 1.0);
	else if(num == DND_ANNOUNCER_LEGENDARYMONSTER) // this one is called from the monster spawner and thus must be hudmessagebold
		HudMessageBold(s:"A legendary monster now walks\nthis land... Be wary.\c-"; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, 730.1 + 3 * ScreenResOffsets[1] / 2, 140.1, 4.0, 1.0, 1.0);
	else if(num == DND_ANNOUNCER_RESEARCHDISCOVER)
		HudMessage(s:"You have discovered the following\nresearch: \cd", s:Research_Label[extra], s:"\c-!"; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, 730.1 + 3 * ScreenResOffsets[1] / 2, 140.1, 4.0, 1.0, 1.0);
	else if(num == DND_ANNOUNCER_TRADEREQUEST) {
		LocalAmbientSound("TradeRequest", 127);
		HudMessage(s:"You have a trade request from:\n", n:extra + 1; HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, 730.1 + 3 * ScreenResOffsets[1] / 2, 140.1, 4.0, 1.0, 1.0);
	}
}

Script 1002 (void) NET CLIENTSIDE {
	int qid = CheckInventory("ActiveQuestID") - 1;
	if(qid < 0 || !CheckInventory("QuestWasPicked"))
		Log(s:"No active quest found!");
	else {
		if(CheckInventory("TipBoxOpen"))
			Terminate;
		GiveInventory("TipboxOpen", 1);
		LocalAmbientSound("Quest/View", 127);
		SetHudSize(640, 480, 1);
		SetFont("QSTBOX2");
		HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVEID, CR_UNTRANSLATED, 496.0 + ScreenResOffsets[1], 136.0, 4.0, 1.0, 1.0);
		SetHudSize(960, 600, 1);
		SetFont("OBJFONT");
		HudMessage
		(
			s:"\cf", s:Quest_Description[qid][QUEST_NAME];
			HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, 576.1 + 3 * ScreenResOffsets[1] / 2, 112.1, 4.0, 1.0, 1.0
		);
		// requirement
		SetHudClipRect((576.0 + 3 * ScreenResOffsets[1] / 2) >> 16, 128, 384, 64, 384, 1);
		HudMessage
		(
			s:"\c-\c[Y5]REQ: \c-", s:Quest_Description[qid][QUEST_REQ];
			HUDMSG_FADEINOUT, UPGRADETEXTID, CR_WHITE, 576.1 + 3 * ScreenResOffsets[1] / 2, 136.1, 4.0, 1.0, 1.0
		);
		// reward
		SetHudClipRect((576.0 + 3 * ScreenResOffsets[1] / 2) >> 16, 176, 384, 64, 384, 1);
		HudMessage
		(
			s:"\c-\cdREW: \c-", s:Quest_Description[qid][QUEST_REW];
			HUDMSG_FADEINOUT, SURVIVEICO, CR_WHITE, 576.1 + 3 * ScreenResOffsets[1] / 2, 184.1, 4.0, 1.0, 1.0
		);
		SetHudClipRect(0, 0, 0, 0, 0);
		// progress
		if(Quest_List[qid].qflag & QTYPE_TRACKABLE) {
			int progress = Clamp_Between((100 * CheckInventory(Quest_Checkers[qid])) / GetQuestProgressRequirement(qid), 0, 100);
			str color = "\cg";
			if(progress == 100)
				color = "\cd";
			else if(progress > 75)
				color = "\cf";
			else if(progress > 50)
				color = "\ck";
			else if(progress > 25)
				color = "\ci";
			HudMessage
			(
				s:"Progress: ", s:color, d:progress, s:"%\c-";
				HUDMSG_FADEINOUT, SURVIVETOPTEXTID, CR_WHITE, 576.1 + 3 * ScreenResOffsets[1] / 2, 232.1, 4.0, 1.0, 1.0
			);
		}
		Delay(35 * 5);
		LocalAmbientSound("Quest/Close", 127);
		SetHudClipRect(0, 0, 0, 0, 0);
	}
}

// a fancy ammo pickup script to make it easier to add new ammo types to slots
Script "DND Ammo Container Pickup" (int ctype, int basic_kind) {
	HandleAmmoContainerPickup(ctype, basic_kind);
}

Script "DND Quest Complete" (int isFail) CLIENTSIDE {
	while(CheckInventory("ShowingMenu"))
		Delay(const:35);
	int qid = CheckInventory("QuestCompletionToken") - 1;
	if(qid < 0)
		Terminate;
	int addx = 0.0;
	if(qid == QUEST_SPEND25K) // fixes a weird display bug
		addx = -40.0;
	while(ScreenResOffsets[0] == -1)
		Delay(const:17);
	GiveInventory("TipBoxOpen", 1);
	SetHudSize(640, 480, 1);
	SetFont("QUESTBOX");
	HudMessage(s:"A"; HUDMSG_FADEINOUT, SURVIVEID, CR_UNTRANSLATED, 512.0 + ScreenResOffsets[1] + addx, 120.0, 3.0, 1.0, 1.0);
	SetHudSize(960, 600, 1);
	SetFont("OBJFONT");
	if(!isFail) {
		LocalAmbientSound("Quest/Done", 127);
		HudMessage
		(
			s:"\cf", s:Quest_Description[qid][QUEST_NAME],
			s:"\c-\n\c[Y5]Quest completed!";
			HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, 624.1 + 3 * ScreenResOffsets[1] / 2, 104.1, 3.0, 1.0, 1.0
		);
	}
	else {
		LocalAmbientSound("Quest/Fail", 127);
		HudMessage
		(
			s:"\cf", s:Quest_Description[qid][QUEST_NAME],
			s:"\c-\n\c[B1]Quest failed!";
			HUDMSG_FADEINOUT, SURVIVETEXTID, CR_WHITE, 624.1 + 3 * ScreenResOffsets[1] / 2, 104.1, 3.0, 1.0, 1.0
		);
	}
}

// Used in Select statement of weapons, caches the weapon damage numbers this weapon can cause
Script "DND Weapon Damage Cache" (int dmg_id, int dmg, int dmg_rand, int wepid) {
	CachePlayerDamage(PlayerNumber(), dmg, wepid, dmg_id, dmg_rand);
	SetResultValue(0);
}

Script "DND Weapon Damage Retrieve" (int dmgid, int talent_type, int flags) {
	bool isSpecial = flags & DND_WDMG_ISSPECIALAMMO;
	int wepid = dmgid >> 16;
	dmgid &= 0xFFFF;
	
	AdjustDamageRetrievePointers(flags);

	int pnum = PlayerNumber();
	int res = ScaleCachedDamage(wepid, pnum, dmgid, talent_type, flags, isSpecial);
	
	// special weapons checks -- these are added on top of everything else as the last thing, before crits
	// they are also dynamic and cant be cached...
	if(wepid == DND_WEAPON_LIGHTNINGGUN)
		res = res * (100 + DND_LIGHTNINGGUN_DMGPERSTACK * CheckInventory("LightningStacks")) / 100;
	else if(wepid == DND_WEAPON_DUSKBLADE)
		res = res * (100 + DND_DUSKBLADE_DMGPERSTACK * CheckInventory("SwordHitCharge")) / 100;
	
	if(PlayerCritState[pnum][DND_CRITSTATE_CONFIRMED])
		res = ConfirmedCritFactor(res);
	else
		res = HandleWeaponCrit(res, wepid, pnum, dmgid, isSpecial);
	
	SetResultValue(res);
}

Script "tester shit" (void) {
	printbold(s:"haha yes");
	SetResultValue(0);
}

// Used mainly for non-weapons (like artifacts and so on)
Script "DND Player Damage Scale" (int dmg, int talent_type, int flags) {
	int temp, temp2;
	
	AdjustDamageRetrievePointers(flags);
	
	int pnum = PlayerNumber();
	bool isSpell = flags & DND_WDMG_ISSPELL;
	if(isSpell) {
		// we take id of spell from the table as input, then read its damage
		temp2 = dmg;
		dmg = SpellDamageTable[dmg].dmg;
	}
	
	dmg += MapTalentToFlatBonus(pnum, talent_type, flags);
		
	if(talent_type == TALENT_MELEE || flags & DND_WDMG_HASSTRSCALING)
		dmg = dmg * (100 + DND_STR_GAIN * GetStrength()) / 100;
	if(flags & DND_WDMG_ISOCCULT || talent_type == TALENT_OCCULT) // is occult (add demon bane bonus)
		dmg = dmg * (100 + DND_DEMONBANE_GAIN * IsAccessoryEquipped(ActivatorTID(), DND_ACCESSORY_DEMONBANE)) / 100;
	if(flags & DMG_WDMG_ISARTIFACT)
		dmg = dmg * (100 + DND_ARTIFACT_GAIN * CheckInventory("Ability_Arcanery")) / 100;
	if(flags & DMG_WDMG_NECROBULK)
		dmg = dmg * (100 + DND_NECRO_BULKSCALE * GetBulkiness()) / 100;
	// talent bonus
	if(flags & DND_WDMG_ISOCCULT || talent_type == TALENT_OCCULT || isSpell)
		dmg = dmg * (100 + (TALENT_INCREASE + TALENT_PER_INT * GetIntellect()) * CheckInventory(TalentNames[talent_type][TALENT_TAG])) / 100;
	else
		dmg = dmg * (100 + (TALENT_INCREASE + TALENT_PER_DEX * GetDexterity()) * CheckInventory(TalentNames[talent_type][TALENT_TAG])) / 100;
	
	temp = GetPlayerAttributeValue(pnum, INV_EX_DAMAGEPER_FLATHEALTH);
	temp = GetPlayerAttributeValue(pnum, INV_EX_DAMAGEPER_FLATHEALTH);
	if(temp) {
		temp = GetFlatHealthDamageFactor(temp);
		dmg = dmg * (100 + temp) / 100;
	}
		
	temp =  GetDataFromOrbBonus(pnum, OBI_DAMAGETYPE, talent_type) + 
			GetPlayerAttributeValue(pnum, INV_DAMAGEPERCENT_INCREASE) +
			MapTalentToPercentBonus(pnum, talent_type) +
			Player_Elixir_Bonuses[pnum].damage_type_bonus[talent_type];
	if(temp)
		dmg = dmg * (100 + temp) / 100;
		
	// finally crit chance
	if(CheckCritChance(-1)) {
		dmg = dmg * GetCritModifier() / 100;
		HandleHunterTalisman();
	}
	
	// final additions
	if(flags & DMG_WDMG_ISARTIFACT && CheckInventory("DnD_QuestReward_ExtraArtiDmg"))
		dmg = dmg * (100 + DND_QUEST_ARTIBONUS) / 100;
	
	if(isSpell) {
		if(SpellDamageTable[temp2].dmg_low)
			dmg *= random(SpellDamageTable[temp2].dmg_low, SpellDamageTable[temp2].dmg_high);
	}
	
	//printbold(s:"scaled player damage ", d:dmg);
	
	SetResultValue(dmg);
}

// idk why parameters are reversed here compared to below... ugh
Script "DND Armor Pickup Check" (int amount, int armor_type) {
	if (CheckInventory("CanLoad"))
		SetResultValue(-1);
	else
		// decide if armor is higher tier if amount doesn't satisfy
		SetResultValue(
			!CheckInventory("StatbuffCounter_ForbidArmor") && 
				(
					(CheckInventory("DnD_ArmorType") && CheckInventory("Armor") < GetArmorSpecificCap(ArmorBaseAmounts[CheckInventory("DnD_ArmorType") - 1])) || 
					IsArmorTierHigher(armor_type, CheckInventory("DnD_ArmorType") - 1)
				)
		);
}

Script "DND Armor Give" (int armor_type, int amount) {
	if(!CheckInventory("StatbuffCounter_ForbidArmor"))
		HandleArmorPickup(armor_type, amount, 0);
}

Script "DND Get Talent" (int talent_type) {
	SetResultValue(GetTalent(talent_type));
}

Script "DND Acid Rifle Bolt Stick" (int type) {
	int res = 0;
	int tracer = GetActorProperty(0, APROP_TRACERTID);
	if(!type)
		res = GetActorProperty(tracer, APROP_HEIGHT) >> 16;
	else
		res = IsActorAlive(tracer);
	SetResultValue(res);
}

Script "DND Demon Seal FX Spawn" (int tracer) CLIENTSIDE {
	Spawn("DemonSealDebuffFXSpawner", GetActorX(tracer), GetActorY(tracer), GetActorZ(tracer), 0);
}

Script "DND Demon Seal FX" (void) {
	int tracer = ActivatorTID();
	if(!CheckActorInventory(tracer, "DemonSealDamageDebuff")) {
		GiveActorInventory(tracer, "DemonSealDamageDebuff", 1);
		GiveActorInventory(tracer, "DemonSealResistDebuff", 1);
		if(isActorAlive(tracer)) {
			PlaySound(tracer, "DemonSeal/debuff", 6, 0.9, 0, 1.0);
			// loops at 4.8 seconds, zandro doesnt know how to stop looping this sound for whatever reason...
			//PlaySound(tracer, "DemonSeal/debuffloop", 7, 0.5, 0, 1.3);
		}
		while(isActorAlive(tracer) && CheckActorInventory(tracer, "DemonSealDamageDebuff")) {
			ACS_NamedExecuteAlways("DND Demon Seal FX Spawn", 0, tracer);
			Delay(1);
		}
		//StopSound(tracer, 7);
	}
}

Script "DND Desolator FX Spawn" (int tracer) CLIENTSIDE {
	Spawn("DesolatorDebuffFXSpawner", GetActorX(tracer), GetActorY(tracer), GetActorZ(tracer), 0);
}

Script "DND Desolator Debuff FX" (int tracer) {
	while(isActorAlive(tracer) && CheckActorInventory(tracer, "DesolatorStackTimer")) {
		ACS_NamedExecuteAlways("DND Desolator FX Spawn", 0, tracer);
		TakeActorInventory(tracer, "DesolatorStackTimer", 1);
		Delay(const:1);
	}
	TakeActorInventory(tracer, "DesolatorStackCounter", 99);
}

Script "DND Trail Spawner" (int actortype, int density, int target) CLIENTSIDE {
	int ptid = !target ? GetActorProperty(0, APROP_TARGETTID) : target;
	if(DnD_TrailDef[actortype].waittime)
		Delay(DnD_TrailDef[actortype].waittime);
	
    int plX; int plY;  int plZ;
    int grX; int grY;  int grZ;
    int vX;  int vY;   int vZ;
    int nX;  int nY;   int nZ;
    int bX;  int bY;   int bZ;
    int magnitude;
    int pointCount;
    int pointOffset;
	
    plX = GetActorX(0); 
	grX = GetActorX(ptid);
	
    plY = GetActorY(0);
	grY  = GetActorY(ptid);
    
	plZ = GetActorZ(0) + (GetActorProperty(0, APROP_HEIGHT) >> 1) + DnD_TrailDef[actortype].offset_z; 
	grZ  = GetActorZ(ptid) + (GetActorProperty(ptid, APROP_HEIGHT) >> 1);
	
    vX   = grX - plX;       vY   = grY - plY;       vZ   = grZ - plZ;

    magnitude = magnitudeThree(vX >> 16, vY >> 16, vZ >> 16);

    pointCount  = magnitude / density;
    pointOffset = magnitude - (pointCount * density);

	int maxdiff = DnD_TrailDef[actortype].maxdiff;
    if (magnitude != 0) {
        nX = vX / magnitude; nY = vY / magnitude; nZ = vZ / magnitude;

        int i; int j;
        for (i = 1; i < pointCount; i++) {
            j = (i * density) + pointOffset;

			bX = (nX * j) + plX;
			bY = (nY * j) + plY;
			bZ = (nZ * j) + plZ;
			
			if(maxdiff) {
				bX += (random(0, 1) ? (random(-maxdiff, maxdiff) << 16) : 0);
				bY += (random(0, 1) ? (random(-maxdiff, maxdiff) << 16) : 0);
				bZ += (random(0, 1) ? (random(-maxdiff, maxdiff) << 16) : 0);
			}

			Spawn(DnD_TrailDef[actortype].actor, bX, bY, bZ, 0, VectorAngle(-vX, -vY) >> 8);
        }
    }
}

// currently does 90 degree scan from players fov
Script "DnD Do Scan Attack" (int dmg, int damage_type, int tracer_count, int flags) {
	// scan field of view
	// check all monsters
	static dist_tid_pair_T tlist[MAXPLAYERS][DND_MAXSCANTRACER];
	
	int scan_id = tracer_count >> 16;
	tracer_count &= 0xFFFF;
	
	int scan_dist = ScanAttackData[scan_id].max_dist;
	int scan_fov = ScanAttackData[scan_id].fov;
	
	int dist = scan_dist, i, j, k, temp;
	
	int tcount = 0;
	int tidlim = 0;
	int owner = (flags & DND_DAMAGEFLAG_SELFORIGIN) ? ActivatorTID() : GetActorProperty(0, APROP_TARGETTID);
	int pnum = owner - P_TIDSTART;
	
	// init list
	for(i = 0; i < DND_MAXSCANTRACER; ++i) {
		tlist[pnum][i].tid = 0;
		tlist[pnum][i].dist = scan_dist;
	}
	
	// face player to the originator temporarily to get projection to there
	int prev_ang = GetActorAngle(owner);
	// use angle of the ball
	if(!(flags & DND_DAMAGEFLAG_SELFORIGIN))
		SetActorAngle(owner, GetActorAngle(0));
	
	//printbold(s:"starting scan from ", d:owner, s: " with dmg ", d:dmg, s: " scan id: ", d:scan_id);
	// pick tracer_count closest enemies
	for(i = DND_MONSTERTID_BEGIN; i < DnD_TID_List[DND_TID_MONSTER]; ++i) {
		if(IsActorAlive(i) && CheckFlag(i, "SHOOTABLE")) {
			dist = fdistance(owner, i);
			//printbold(s:"Checking ", s:GetActorClass(i));
			if(dist < scan_dist && MaxAngleDiff(owner, i, scan_fov) && CheckSight(owner, i, 0)) {
				//printbold(s:"approved ", s:GetActorClass(i), s: " ", d:i);
				// insert sorted
				temp = tcount;
				// while our calc dist > alloc dist, keep going -- we add things to the end
				// if we come by a point where we are smaller, shift things
				for(j = 0; j < temp && dist > tlist[pnum][j].dist; ++j);

				// we know where to add, check if we must shift (if we should)
				if(j < temp) {
					// less, so that means we are in-between things
					// push everything for insertion
					// this is needed to move in 0 index shifts
					if(temp == DND_MAXSCANTRACER)
						--temp;
					
					for(k = temp; k > j; --k) {
						// slide data
						tlist[pnum][k].dist = tlist[pnum][k - 1].dist;
						tlist[pnum][k].tid = tlist[pnum][k - 1].tid;
					}
				}
				
				tlist[pnum][j].dist = dist;
				tlist[pnum][j].tid = i;
				
				if(tcount < tracer_count)
					++tcount;
			}
		}
	}
	
	// fix angle
	SetActorAngle(owner, prev_ang);
	
	if(tcount) {
		int actor_flags = ScanActorFlags();
		
		// damage credit
		SetActivator(owner);
		
		for(i = 0, j = 0; i < DND_MAXSCANTRACER; ++i) {
			if(tlist[pnum][i].tid) {
				// distance reduces damage for scans, closer = better -- gives percentage
				// curr formula: factor = 100 * ((max_scan_dist - curr_dist) / max_scan_dist)^2 -- returns a percentage
				if(flags & DND_DAMAGEFLAG_DISTANCEGIVESDAMAGE) {
					tlist[pnum][i].dist = FixedDiv((scan_dist - tlist[pnum][i].dist), scan_dist);
					tlist[pnum][i].dist = FixedMul(tlist[pnum][i].dist, tlist[pnum][i].dist);
					tlist[pnum][i].dist *= 100;
					tlist[pnum][i].dist >>= 16;
					if(!tlist[pnum][i].dist)
						tlist[pnum][i].dist = 1;
					temp = (dmg * tlist[pnum][i].dist) / 100;
				}
				else
					temp = dmg;
				
				HandleDamageDeal(owner, tlist[pnum][i].tid, temp, damage_type, flags, GetActorX(owner), GetActorY(owner), GetActorZ(owner), actor_flags);
				SpawnForced(ScannerAttackParticles[scan_id], GetActorX(tlist[pnum][i].tid), GetActorY(tlist[pnum][i].tid), GetActorZ(tlist[pnum][i].tid) + ScanAttackData[scan_id].spawn_offZ, 0);
				
				//printbold(s:"do scan damage of ", d:temp, s: " dist: ", d:tlist[pnum][i].dist, s: " to ", s:GetActorClass(tlist[pnum][i].tid), s:" ", d:tlist[pnum][i].tid, s:" -- j = ", d:j, s: " / ", d:tcount, s: " index: ", d:i);
				// abort if we reached our tracer cap
				++j;
				if(j == tcount)
					break;
			}
		}
		//printbold(s:"complete? ", d:j, s: " vs ", d:tcount);
	}
}

Script "DND Thunderstaff Bolts" (void) {
	int dist = INT_MAX, i, j, k, temp;
	// scan all monsters for the item ThunderTarget -- that implies they are candidates having passed range check
	static dist_tid_pair_T tlist[MAXPLAYERS][DND_THUNDERSTAFF_MAXTARGETS];
	
	int owner = GetActorProperty(0, APROP_TARGETTID);
	int pnum = owner - P_TIDSTART;
	
	// init list
	for(i = 0; i < DND_THUNDERSTAFF_MAXTARGETS; ++i) {
		tlist[pnum][i].tid = 0;
		tlist[pnum][i].dist = INT_MAX;
	}
	int tcount = 0;
	int tidlim = 0;
	// pick N closest targets as a list of targets to hit
	for(i = DND_MONSTERTID_BEGIN; i < DnD_TID_List[DND_TID_MONSTER]; ++i) {
		if(CheckActorInventory(i, "ThunderTarget") && IsActorAlive(i) && CheckFlag(i, "SHOOTABLE")) {
			dist = fdistance(0, i);
			// insert sorted
			if(tcount < DND_THUNDERSTAFF_MAXTARGETS)
				temp = tcount;
			else
				temp = DND_THUNDERSTAFF_MAXTARGETS;
			// while our calc dist > alloc dist, keep going -- we add things to the end
			// if we come by a point where we are smaller, shift things
			for(j = 0; j < temp && dist > tlist[pnum][j].dist; ++j);

			// we know where to add, check if we must shift (if we should)
			if(j < temp) {
				// less, so that means we are in-between things
				// push everything for insertion
				// this is needed to move in 0 index shifts
				if(temp == DND_THUNDERSTAFF_MAXTARGETS)
					--temp;
				
				for(k = temp; k > j; --k) {
					// slide data
					tlist[pnum][k].dist = tlist[pnum][k - 1].dist;
					tlist[pnum][k].tid = tlist[pnum][k - 1].tid;
				}
			}
			
			tlist[pnum][j].dist = dist;
			tlist[pnum][j].tid = i;
			
			if(tcount < DND_THUNDERSTAFF_MAXTARGETS)
				++tcount;
		}
	}
	
	if(tcount) {
		int actor_flags = ScanActorFlags();
	
		for(i = 0; i < DND_THUNDERSTAFF_MAXTARGETS; ++i) {
			if(tlist[pnum][i].tid)
				ACS_NamedExecuteAlways("DND Trail Spawner", 0, DND_TRAILACTOR_THUNDERZAP, 16, tlist[pnum][i].tid);
		}
		
		int px = GetActorX(0);
		int py = GetActorY(0);
		int pz = GetActorZ(0);
		
		// damage credit
		SetActivatorToTarget(0);
		dist = ACS_NamedExecuteWithResult("DND Weapon Damage Retrieve", DND_DMGID_1 | (DND_WEAPON_THUNDERSTAFF << 16), TALENT_ELEMENTAL, DND_WDMG_LIGHTNINGDAMAGE);
		for(i = 0; i < DND_THUNDERSTAFF_MAXTARGETS; ++i) {
			if(tlist[pnum][i].tid)
				HandleDamageDeal(owner, tlist[pnum][i].tid, dist, DND_DAMAGETYPE_LIGHTNING, 0, px, py, pz, actor_flags);
		}
	}
}

Script "DND ThunderStaff FX Spawn" (int target) CLIENTSIDE {
	SpawnForced("ThunderStaffLightningFX", GetActorX(target), GetActorY(target), GetActorFloorZ(target));
}

Script "DND Thunder Ring" (int radius) CLIENTSIDE {
	int tid = ActivatorTID(), i; // Owner TID
	int newtid = tid + DND_THUNDER_RING_TIDSTART + 32 * ((tid + 1) % 100);
	
	for(i = 0; i < 32; ++i)
		Thing_Remove(newtid + i);
	
	int cx, cy, cz, r_add, angadd = 0;
	int pang = GetActorAngle(tid) >> 8;
	cz = GetActorZ(tid);
	
	for(i = 0; i < 32; ++i) {
		cx = GetActorX(tid) + radius * cos(pang << 8) / 32;
		cy = GetActorY(tid) + radius * sin(pang << 8) / 32;
		pang += 8;
		Spawn("ThunderStaffRingFX", cx, cy, cz + 26.825, newtid + i, 0);
		SetActivator(newtid + i);
		SetPointer(AAPTR_TARGET, tid);
		SetActivator(tid);
	}
	Delay(const:1);
	while(CheckInventory("ThunderRangeCounter") && IsAlive() && !CheckInventory("ThunderStopRing")) {
		r_add = DND_THUNDER_RADIUSPERCOUNT * CheckInventory("ThunderRangeCounter");
		pang = 0;
		for(i = 0; i < 32; ++i) {
			pang += 8;
			if(GetActorFloorZ(newtid + i) > GetActorZ(tid))
				cz = GetActorFloorZ(newtid + i);
			cx = GetActorX(tid) + (radius + r_add) * cos((pang << 8) + angadd);
			cy = GetActorY(tid) + (radius + r_add) * sin((pang << 8) + angadd);
			SetActorPosition(newtid + i, cx, cy, cz + 26.825, 0);
		}
		angadd += 0.025;
		angadd %= 1.0;
		Delay(const:1);
	}
	for(i = 0; i < 32; ++i)
		SetActorState(newtid + i, "Fade");
}

Script "DND Thunderstaff Lightning" (void) {
	int i, this = ActivatorTID();
	int dmg = ACS_NamedExecuteWithResult("DND Weapon Damage Retrieve", DND_DMGID_2 | (DND_WEAPON_THUNDERSTAFF << 16), TALENT_ELEMENTAL, DND_WDMG_LIGHTNINGDAMAGE) << 1;
	int tidlim = 0;
	
	for(i = DND_MONSTERTID_BEGIN; i < DnD_TID_List[DND_TID_MONSTER]; ++i) {
		if(CheckActorInventory(i, "ThunderStrike") && IsActorAlive(i) && CheckFlag(i, "SHOOTABLE")) {
			ACS_NamedExecuteAlways("DND ThunderStaff FX Spawn", 0, i);
			SpawnForced("ThunderstaffExp", GetActorX(i), GetActorY(i), GetActorFloorZ(i) + 16.0, DND_THUNDERSTAFF_DAMAGERTID);
			HandleDamageDeal(this, i, dmg, DND_DAMAGETYPE_LIGHTNING, 0, 0, 0, 0, DND_ACTORFLAG_NOPUSH);
			SetActivator(DND_THUNDERSTAFF_DAMAGERTID);
			SetPointer(AAPTR_TARGET, this);
			SetActorProperty(DND_THUNDERSTAFF_DAMAGERTID, APROP_TARGETTID, this);
			Thing_ChangeTID(DND_THUNDERSTAFF_DAMAGERTID, 0);
			SetActivator(this);
		}
	}
}

Script "DND Thunder Range" (void) {
	SetResultValue(DND_THUNDERSTAFF_BASERANGE + DND_THUNDER_RADIUSPERCOUNT * CheckInventory("ThunderRangeCounter"));
}

Script "DND HeavyGL Check" (int x, int y, int z) {
	int res = 1;
	if (!(GetActorZ(0) - GetActorFloorZ(0) > 4.0))
		res = sqrt(x*x + y*y + z*z);
	SetResultValue(res);
}

Script "DND Orb Use Message" (int affluence) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	Delay(5);
	HandleOrbUseMessage(CheckInventory("OrbUseType") - 1, CheckInventory("OrbResult"), affluence);
}

Script "DND Orb Use Message (Server)" (void) {
	ACS_NamedExecuteAlways("DND Orb Use Message", 0, GetAffluenceBonus());
}

Script "DND Orb Use" (int orbtype, int extra) {
	HandleOrbUse(orbtype, extra);
	LocalAmbientSound("Items/OrbUse", 127);
	ACS_NamedExecuteAlways("DND Orb Use Message", 0, GetAffluenceBonus());
	ACS_NamedExecuteAlways("DnD Force Damage Cache Recalculation", 0, PlayerNumber());
	Delay(2);
	if(orbtype != DND_ORB_AFFLUENCE)
		SetInventory("AffluenceCounter", 0);
}

Script "DnD Timed Monster" (int time, int isPet) {
	int cnt = 0;
	while(cnt++ != time)
		Delay(const:35);
	if(!isPet)
		SetActorState(0, "Remove");
	else
		Thing_Damage(0, 0x7FFFFFFF);
}

Script "DnD Overheat Reduction" (int index, int rate) {
	int d = (rate & 0xFFFF0000) >> 16;
	rate &= 0x0000FFFF;
	// prevent multiple copies, also dont keep this busy if we got no overheat bonus
	if(!IsSet(PlayerRunsOverheat[PlayerNumber()], index) && !CheckInventory("DnD_QuestReward_GodSlayerBonus")) {
		PlayerRunsOverheat[PlayerNumber()] = SetBit(PlayerRunsOverheat[PlayerNumber()], index);
		while(CheckInventory(WeaponOverheatItems[index])) {
			if(CheckInventory("DnD_OverheatCanReduce"))
				TakeInventory(WeaponOverheatItems[index], rate);
			Delay(d);
		}
		PlayerRunsOverheat[PlayerNumber()] = ClearBit(PlayerRunsOverheat[PlayerNumber()], index);
	}
}

Script "DND Hardcore Timer" (void) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	SetFont("BIGFONT");
	SetHudSize(640, 480, 0);
	for(int i = 0; i < DND_HARDCORE_LOADTIME << 1 && PlayerInGame(PlayerNumber()) && CheckInventory("CanLoad"); ++i) {
		if (CheckInventory("PlayerIsLoggedIn"))
			HudMessage(s:"You have \cd", d:DND_HARDCORE_LOADTIME - i / 2, s:"\c- seconds to load your character!\n\crIgnore or skip with \"\cjskipload\c-\cr\" command to load or create new auto-saved char (slot \cd0\c-\cr).\c-\n"; HUDMSG_PLAIN, DND_HARDCORE_SCREENID, CR_RED, 320.4, 240.0, 0);
		else
			HudMessage(s:"You have \cd", d:DND_HARDCORE_LOADTIME - i / 2, s:"\c- seconds to login to load your character!\n\crIgnore or skip with \"\cjskipload\c-\cr\" command to use none.\c-\n\n\csAn auto-saved char will not be created until login!\c-"; HUDMSG_PLAIN, DND_HARDCORE_SCREENID, CR_RED, 320.4, 240.0, 0);

		Delay(TICRATE / 2);
	}
}

Script "DND Wait For Other Players Message" (int players_not_ready) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	SetFont("BIGFONT");
	SetHudSize(640, 480, 0);
	if (players_not_ready == 1)
		HudMessage(s:"Waiting for \cd", d:players_not_ready, s:"\c- player to load character..."; HUDMSG_PLAIN, DND_HARDCORE_SCREENID, CR_RED, 320.4, 240.0, 0);
	else
		HudMessage(s:"Waiting for \cd", d:players_not_ready, s:"\c- players to load character..."; HUDMSG_PLAIN, DND_HARDCORE_SCREENID, CR_RED, 320.4, 240.0, 0);
}

Script "DND Hardcore Monster Message" (void) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	Delay(const:1);
	SetFont("BIGFONT");
	SetHudSize(640, 480, 0);
	HudMessage(s:"Loading monsters..."; HUDMSG_PLAIN, DND_HARDCORE_SCREENID, CR_RED, 320.4, 240.0, 0);
	Delay(const:17 * (DND_MAX_MONSTERDELAY + 2)); // Add 3 seconds to it to allow player script to finish first.
	HudMessage(s:""; HUDMSG_PLAIN, DND_HARDCORE_SCREENID, CR_RED, 320.0, 240.0, 1);
}

// skip wait for load on this guy
Script 1004 (void) NET {
	int pnum = PlayerNumber();
	if (PlayerInGame(pnum) && CheckInventory("CanLoad"))
	{
		if (PlayerIsLoggedIn(pnum))
		{
			if (ACS_NamedExecuteWithResult("DnD Load Character Check", pnum, 0) == 11) //DND_CHARLOADED
				ACS_ExecuteAlways(1001,0,0);
			else if (ACS_NamedExecuteWithResult("DnD Create Character Check", pnum, 0) == 1) //DND_LOGIN_CREATECHAROK
				ACS_ExecuteAlways(1003,0,0);
		}
		else {
			SetInventory("CanLoad", 0);
			PlayerCanLoad[pnum] = 0;
		}
	}
}

Script "DnD User Dash Status Receive" (int status) NET {
	SetActorInventory(ActivatorTID(), "DashDisabled", !status);
}

Script "DnD Drop Orb" (void) {
	SpawnOrbForAll(1);
}

Script "DnD Play Local Item Drop Sound" (int who, int droptype) CLIENTSIDE {
	if(ConsolePlayerNumber() != who)
		Terminate;
	switch(droptype) {
		case DND_ITEM_CHARM:
			PlaySound(0, "Items/CharmDrop", 4);
		break;
		case DND_ITEM_ORB:
			PlaySound(0, "Items/OrbDrop", 5);
		break;
		
	}
}

Script "DnD Chest Opened" (int ctype) {
	HandleChestDrops(ctype);
}

Script "DnD Check Special GameMode" (void) {
	SetResultValue(HardcoreSet);
}

Script "DnD Talisman Mark Timer" (int counter) {
	GiveInventory("HunterTalismanMarkBool", 1);
	for(int i = 0; i < counter && isAlive(); ++i)
		Delay(35);
	TakeInventory("HunterTalismanMarkBool", 1);
}

Script "DnD Talisman Mark" (void) CLIENTSIDE {
	int this = ActivatorTID();
	Spawn("HunterTalismanFX", GetActorX(0), GetActorY(0), GetActorZ(0) + 48.0, DND_TALISMAN_MARK);
	SetActivator(DND_TALISMAN_MARK);
	SetPointer(AAPTR_TARGET, this);
	SetActorProperty(0, APROP_TARGETTID, this);
	Thing_ChangeTID(DND_TALISMAN_MARK, 0);
}

Script "DnD Chest Dropping Item" (void) {
	HandleChestSpawn();
}

Script "DnD Give Research" (int sp) {
	SetActivator((sp & 0xFFFF) + P_TIDSTART);
	GiveInventory("ResearchSoundPlayer", 1);
	ACS_NamedExecuteAlways("DnD Message Logger", 0, 2, sp, 1);
	GiveResearch(sp >> 16, false);
}

Script "DnD Orb Message" (int id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	Log(s:StrParam(s:"\ccOrb pickup    : \c[Y5]", s:InventoryInfo[id + ORBS_BEGIN][SITEM_TAG], s:"!\c-"));
}

Script "DnD Elixir Message" (int id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	ActivatorSound("Items/ElixirPick", 127);
	Log(s:StrParam(s:"\ccElixir pickup : \c[Y5]", s:InventoryInfo[id + ELIXIR_BEGIN][SITEM_TAG], s:"!\c-"));
}

Script "DnD Stacked Item Pickup" (int sp, int type) {
	if((sp & 0xFFFF) == 255)
		SetActivatorToTarget(0);
	else
		SetActivator((sp & 0xFFFF) + P_TIDSTART);
	if(type == DND_STACKEDITEM_ORB) {
		ACS_NamedExecuteAlways("DnD Orb Message", 0, Inventories_On_Field[sp >> 16].item_subtype);
		GiveInventory("OrbSoundPlayer", 1);
	}
	else if(type == DND_STACKEDITEM_CHESTKEY) {
		ACS_NamedExecuteAlways("DnD Chestkey Message", 0, Inventories_On_Field[sp >> 16].item_subtype);
		GiveInventory("ChestkeySoundPlayer", 1);
	}
	else if(type == DND_STACKEDITEM_ELIXIR) {
		ACS_NamedExecuteAlways("DnD Elixir Message", 0, Inventories_On_Field[sp >> 16].item_subtype);
		GiveInventory("ElixirSoundPlayer", 1);
	}
	HandleStackedPickup(sp >> 16);
}

Script "DnD Drop Research" (void) {
	SpawnResearch();
}

// From HardDoom v83
Script "DnD Footstep Sound" ENTER CLIENTSIDE {
	int DelayTime, StepVolume, x;
	bool SoundPlayed = 0;
	while(1) {
		Delay(const:1);
		x = min(GetPVelocity(), 9);
		DelayTime = 16 - GetPVelocity() / 2;
		StepVolume = 7 * x;
		if(GetActorZ(0) - GetActorFloorZ(0) == 0) {
			// we don't have floor specific step sounds
			/*for(i=0; i<MaxStepSounds; i++) {
					if(CheckActorFloorTexture(0, StepSound[i][0])) {
						ActivatorSound(StepSound[i][1], StepVolume);
						SoundPlayed = 1;
					}
			}
			if(SoundPlayed == 0)*/
				ActivatorSound(DefStepSound, StepVolume);
		}
		SoundPlayed = 0;
		Delay(DelayTime);
	}
}

Script "DnD Weapon Can Switch Mode" (int ammo_category, int weptype) {
	SetResultValue(CanSwitchMode(ammo_category, weptype));
}

Script "DnD Get Target" (void) {
	SetActivatorToTarget(0);
	SetResultValue(ActivatorTID());
}

Script "DnD Get Target of Target" (void) {
	SetActivatorToTarget(0);
	SetActivatorToTarget(0);
	SetResultValue(ActivatorTID());
}

Script "DnD Get Master of Target" (void) {
	SetActivatorToTarget(0);
	SetResultValue(GetActorProperty(0, APROP_MASTERTID));
}

Script "target test" (void) {
	printbold(s:"target test before: ", s:GetActorClass(GetActorProperty(0, APROP_TARGETTID)), s:" ", d:GetActorProperty(0, APROP_TARGETTID));
	SetActivator(0, AAPTR_TARGET);
	printbold(s:"target test mid: ", s:GetActorClass(GetActorProperty(0, APROP_TARGETTID)), s:" ", d:GetActorProperty(0, APROP_TARGETTID));
	SetActivator(0, AAPTR_TARGET);
	printbold(s:"target test after: ", s:GetActorClass(0), s:" ", d:ActivatorTID());
}

Script "DnD Target Fix" (void) {
	// if none assigned
	if(!GetActorProperty(0, APROP_TARGETTID)) {
		int tid = ACS_NamedExecuteWithResult("DnD Get Target of Target");
		SetActorProperty(0, APROP_TARGETTID, tid);
		SetPointer(AAPTR_TARGET, tid);	
	}
	SetResultValue(0);
}

Script "DnD Player Pain Sound" (void) CLIENTSIDE {
	int ptype = CheckInventory("DnD_Character");
	// special pain sound range handling for hobo, punisher and marine
	if(ptype >= 2 && ptype <= 4 || ptype == 6)
		HandlePlayerPainSound(ptype);
}

Script "DnD Research Fancy Message" (int res_id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	Log(s:ResearchPrefix, s:Research_Label[res_id], s:"!");
	LocalAmbientSound("items/research", 127);
	ACS_NamedExecuteAlways("DND Announcer", 0, DND_ANNOUNCER_RESEARCHDISCOVER, res_id);
}

Script "DnD Is Demon" (void) {
	SetActivator(0, AAPTR_TRACER);
	SetResultValue(ActivatorTID() && IsDemon());
}

Script "DnD Is Demon - Self" (void) {
	SetResultValue(ActivatorTID() && IsDemon());
}

Script "DnD Give Ammo" (int slot, int ammotype, int amount) {
	GiveAmmo(amount, slot, ammotype);
}

Script "DnD Give Ammo To Target" (int slot, int ammotype, int amount) {
	SetActivatorToTarget(0);
	GiveAmmo(amount, slot, ammotype);
}

Script "DnD Emerald Death" (void) {
	int this = ActivatorTID();
	SetActivatorToTarget(0);
	int target = ActivatorTID();
	if(CheckInventory("NetherCheck"))
		Spawn("EmeraldDeathActor_FullDMG", GetActorX(this), GetActorY(this), GetActorZ(this) + GetActorProperty(this, APROP_HEIGHT) / 2, target + DND_EMERALD_TIDADD);
	else
		Spawn("EmeraldDeathActor", GetActorX(this), GetActorY(this), GetActorZ(this) + GetActorProperty(this, APROP_HEIGHT) / 2, target + DND_EMERALD_TIDADD);
	SetActivator(target + DND_EMERALD_TIDADD);
	SetPointer(AAPTR_TARGET, target);
	Thing_ChangeTID(0, 0);
}

Script "DnD Charm Message" (int id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	Log(s:StrParam(s:"\ccCharm pickup:   \c[Y5]", s:Charm_TypeName[id], s:"!\c-"));
}

Script "DnD Charm Pickup" (int sp) {
	if((sp & 0xFFFF) == 255)
		SetActivatorToTarget(0);
	else
		SetActivator((sp & 0xFFFF) + P_TIDSTART);
	ACS_NamedExecuteAlways("DnD Charm Message", 0, Inventories_On_Field[sp >> 16].item_subtype);
	GiveInventory("CharmSoundPlayer", 1);
	HandleCharmPickup(sp >> 16);
}

// if we have enough space and we pressed use
Script "DnD Player Has Spot For Item" (int sp) {
	if (GetGameModeState() == GAMESTATE_INPROGRESS) {
		if((sp & 0xFFFF) == 255)
			SetActivatorToTarget(0);
		else
			SetActivator((sp & 0xFFFF) + P_TIDSTART);
		//if (!CheckInventory("CanLoad")) { //BUG: This check is needed to prevent grabbing items before loading char, but had to comment because of extreme lag.
			int pnum = PlayerNumber();
			bool spot = 0;
			if(Inventories_On_Field[sp >> 16].item_stack)
				spot = GetFreeSpotForItemWithStack(sp >> 16, pnum, DND_SYNC_ITEMSOURCE_FIELD) != -1;
			else
				spot = GetFreeSpotForItem(sp >> 16, pnum, DND_SYNC_ITEMSOURCE_FIELD) != -1;
			bool res = CheckInventory("DnD_PressedUse") && !CheckInventory("DnD_WaitNextItemPick") && spot;
			if(res)
				GiveInventory("DnD_WaitNextItemPick", 1);
			SetResultValue(res);
		//}
	}
	else
		SetResultValue(false);
}

// Player picks up item
Script "DnD Preview Item" (int sp, int target) CLIENTSIDE {
	if((sp & 0xFFFF) == 255) {
		SetActivatorToTarget(0);
		if(!ActivatorTID())
			SetActivator(target);
	}
	else
		SetActivator((sp & 0xFFFF) + P_TIDSTART);
		
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	int field_index = sp >> 16;
	DrawInventoryInfo_Field(field_index, DND_SYNC_ITEMSOURCE_FIELD, 24.4, 80.1, false);
}

Script "DnD Chestkey Message" (int id) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	Log(s:StrParam(s:"\ccBonus pickup  : \c[Y5]", s:InventoryInfo[id + CHESTKEY_BEGIN][SITEM_TAG], s:"!\c-"));
}

Script "DnD Try Open Chestkey" (int keytype) {
	int res = -1;
	if ((GetGameModeState() == GAMESTATE_INPROGRESS) && (!CheckActorInventory(GetActorProperty(0, APROP_TARGETTID), "CanLoad"))) {
		res = CheckPlayerInventoryList(GetActorProperty(0, APROP_TARGETTID) - P_TIDSTART, DND_ITEM_CHESTKEY, keytype);
		if(res != -1) {
			SetActivatorToTarget(0);
			UsePlayerItem(PlayerNumber(), res);
		}
	}
	SetResultValue(res != -1);
}

Script "DnD Pellet Count" (int base, int flags) {
	if(flags & DND_WDMG_USETARGET)
		SetactivatorToTarget(0);
	int pnum = PlayerNumber();
	int res = 100 + GetPlayerAttributeValue(pnum, INV_PELLET_INCREASE);
	
	if(CheckInventory("Hobo_Perk50"))
		res += DND_HOBO_SHOTGUNPELLETBONUS;
		
	// dummy crit call here to obtain crit status item
	HandleWeaponCrit(0, CheckInventory("DnD_WeaponID"), pnum, 0, false);
	PlayerCritState[pnum][DND_CRITSTATE_NOCALC] = true;
	
	SetResultValue(res * base / 100); 
}

Script "DnD Explosion Radius Retrieve" (int flags) {
	if(flags & DND_WDMG_USETARGET)
		SetactivatorToTarget(0);
	else if(flags & DND_WDMG_USEMASTER) {
		if(flags & DND_WDMG_SETMASTER) // this is a hack
			SetPointer(AAPTR_TARGET, GetActorProperty(0, APROP_MASTERTID));
		SetActivator(GetActorProperty(0, APROP_MASTERTID));
	}
	else if(flags & DND_WDMG_USETARGETSMASTER) {
		SetActivator(ACS_NamedExecuteWithResult("DnD Get Master of Target"));
	}
	SetResultValue(GetPlayerAttributeValue(PlayerNumber(), INV_EXPLOSION_RADIUS));
}

// after 16th bit there can be extra info
// never put AMMO_CLIP as 16 bit onwards
Script "DnD Ammo Gain Chance" (int slot, int ammo, int amount) {
	// ammo gain triggering means we made an attack
	ACS_NamedExecuteAlways("DnD On Attack", 0);
	if(random(1, 100) <= GetPlayerAttributeValue(PlayerNumber(), INV_AMMOGAIN_CHANCE)) {
		if(slot != DND_AMMOSLOT_MAGAZINE)
			GiveInventory(AmmoInfo_Str[slot][ammo][AMMOINFO_NAME], amount);
		else if(slot != DND_AMMOSLOT_SPECIAL)
			GiveInventory(ClipAmmoTypes[ammo], amount);
		else if(slot != DND_AMMOSLOT_TEMPORARY)
			GiveInventory(SpecialAmmoInfo_Str[ammo][AMMOINFO_NAME], amount);
		else
			GiveInventory(TemporaryAmmos[ammo], amount);
	}
}

// in here because dnd_mons.bcs can't access values of the variables used below
Script "DnD Warmaster Rage" (void) {
	while(!CheckInventory("WarmasterActive"))
		Delay(const:17);
	int i, tidlim, dist;
	while(CheckInventory("WarmasterActive")) {
		bool found = false;
		// try to see if there's at least one monster that is closest to this
		for(i = DND_MONSTERTID_BEGIN; i < DnD_TID_List[DND_TID_MONSTER] && !found; ++i) {
			if(IsActorAlive(i)) {
				dist = fdistance(0, i);
				// no self find
				if(dist >= 2.0 && dist <= WARMASTER_DIST)
					found = true;
			}
		}
		
		if(found)
			GiveInventory("WarmasterRage", 1);
		else
			TakeInventory("WarmasterRage", 1);
		Delay(35);
	}
}

Script "DnD Get Aspect For Inventory View" (void) CLIENTSIDE {
	SetResultValue(ScreenResOffsets[2]);
}

Script "DnD Elixir Use Message" (int eid) CLIENTSIDE {
	if(ConsolePlayerNumber() != PlayerNumber())
		Terminate;
	LocalAmbientSound("Items/ElixirPick", 127);
	Log(s:InventoryInfo[eid + ELIXIR_BEGIN][SITEM_DESC]);
}

Script "DnD Elixir Use" (int eid) {
	ACS_NamedExecuteAlways("DnD Elixir Use Message", 0, eid);
	ACS_NamedExecuteAlways("DnD Force Damage Cache Recalculation", 0, PlayerNumber());
	HandleElixirUse(eid);
}

Script "DnD DeathRay Marker TID" (void) {
	Thing_ChangeTID(0, GetActorProperty(0, APROP_TARGETTID) + DEATHRAY_MARKER_TID_ADD);
}

Script "DnD DeathRay Laser Aim" (int adj) {
	int target = GetActorProperty(0, APROP_TARGETTID) + DEATHRAY_MARKER_TID_ADD;
	if(!ThingCount(T_NONE, target))
		terminate;
	int xdiff = GetActorX(target) - GetActorX(0);
	int ydiff = GetActorY(target) - GetActorY(0);
	SetActorProperty(0, APROP_HEALTH, target);
	SetActorProperty(0, APROP_MASS, (360 * VectorAngle(xdiff, ydiff)) >> 16);
	SetActorPitch(0, VectorPitch(0, target, xdiff, ydiff, adj));
}

Script "DnD Deathray Laser Trail" (int density, int target) CLIENTSIDE {
	int oX = GetActorX(0);
	int oY = GetActorY(0);
	int oZ = GetActorZ(0);

    int grX; int grY;  int grZ;
    int vX;  int vY;   int vZ;
    int nX;  int nY;   int nZ;
    int bX;  int bY;   int bZ;
    int magnitude;
    int pointCount;
    int pointOffset;
	
    grX = GetActorX(target);
    grY = GetActorY(target);
    grZ = GetActorZ(target);
	
    vX   = grX - oX;
	vY   = grY - oY;
	vZ   = grZ - oZ;
	
    magnitude = magnitudeThree(vX >> 16, vY >> 16, vZ >> 16);
    pointCount  = magnitude / density;
    pointOffset = magnitude - (pointCount * density);

    if (magnitude != 0) {
        nX = vX / magnitude; nY = vY / magnitude; nZ = vZ / magnitude;

        int i; int j;
        for (i = 1; i < pointCount; i++) {
            j = (i * density) + pointOffset;
            bX = (nX * j) + oX;
            bY = (nY * j) + oY;
            bZ = (nZ * j) + oZ;

            Spawn("DeathRayLaserTrail", bX, bY, bZ);
        }
    }
}

Script "DnD Force Sync Player Bonuses" (void) {
	Delay(TICRATE * 5);
	if(CheckInventory("DnD_SyncMe"))
		SyncAllClientsideVariables();
}

Script "DnD Force Damage Cache Recalculation" (int pnum) {
	ForcePlayerDamageCaching(pnum);
}

Script "DnD Pet Monster Scale" (int petid) {
	GivePetTID();
	
	int base, add, level, temp, master = GetActorProperty(0, APROP_MASTERTID), this = ActivatorTID();
	base = GetActorProperty(0, APROP_HEALTH);
	
	add = 0, level = CheckActorInventory(master, "Level");
	if(level > 1) {
		add = (base * Clamp_Between(GetCVar("dnd_monster_hpscalepercent"), 1, 100)) / 100;
		if(level > 75)
			temp = DND_AFTER75_INCREMENT;
		else if(level > 50)
			temp = DND_AFTER50_INCREMENT;
		else
			temp = 1;
		// we are in boost range for hp
		if(temp != 1) {
			if(add > 100) {
				add /= 100;
				add *= 100 + temp;
			}
			else {
				add *= 100 + temp;
				add /= 100;
			}
		}
		add += SKILL_ZOMBIE_HP_PER_INT * GetActorIntellect(master);
			
		// first overflow check
		if(add < (INT_MAX - base) / (level - 1))
			add *= level - 1;
		else
			add = INT_MAX - base;
	}
	SetActorProperty(0, APROP_HEALTH, base + add);
	ScaleMonsterMass(level);
	PetMonsterProperties[this - DND_PETTID_BEGIN].id = petid;
	PetMonsterProperties[this - DND_PETTID_BEGIN].basehp = base;
	PetMonsterProperties[this - DND_PETTID_BEGIN].maxhp = base + add;
	PetMonsterProperties[this - DND_PETTID_BEGIN].level = level;
}

Script "DnD Master Skill Info" (int skill_id) {
	int res = 0;
	int master = GetActorProperty(0, APROP_MASTERTID);
	switch(skill_id) {
		case SKILLINFO_ZOMBIEPETTIMER:
			res = SKILL_ZOMBIE_DURATION + GetActorIntellect(master) / ZOMBIE_INT_TIMER_FACTOR;
		break;
	}
	SetResultValue(res);
}

Script "DND Pet Monster Damage Scale" (int base, int rnd, int flags) {
	if(flags & 1) // target
		SetactivatorToTarget(0);
	int this = ActivatorTID();
	int master = GetActorProperty(0, APROP_MASTERTID);
	int res = 1.0 + Clamp_Between(PetMonsterProperties[this - DND_PETTID_BEGIN].level, 1, DND_MAX_MONSTERLVL) * Clamp_Between(GetCVar("dnd_monster_dmgscalepercent"), 0.01, 1.0);
	if(PetMonsterProperties[this - DND_PETTID_BEGIN].level > 50)
		res = FixedMul(res, 1.0 + DND_AFTER50_INCREMENT_DAMAGE);
	if(flags & DND_WDMG_ISRIPPER)
		res >>= 1;
	res += GetPetDamageFactor(base, master);
	// we don't need monster id from here onwards
	base &= 0xFFFF;
	// apply the monster's base damage first
	res *= base;
	res >>= 16;
	// now get player damage bonus stuff included
	SetActivator(master);
	int pnum = PlayerNumber();
	res += MapTalentToFlatBonus(pnum, TALENT_OCCULT, flags);
	res = res * (100 + DND_DEMONBANE_GAIN * IsAccessoryEquipped(ActivatorTID(), DND_ACCESSORY_DEMONBANE)) / 100;
	// talent bonus
	res = res * (100 + (TALENT_INCREASE + TALENT_PER_INT * GetIntellect()) * CheckInventory(TalentNames[TALENT_OCCULT][TALENT_TAG])) / 100;
	int temp = GetPlayerAttributeValue(pnum, INV_EX_DAMAGEPER_FLATHEALTH);
	if(temp) {
		temp = GetFlatHealthDamageFactor(temp);
		res = res * (100 + temp) / 100;
	}
		
	temp =  GetDataFromOrbBonus(pnum, OBI_DAMAGETYPE, TALENT_OCCULT) + 
			GetPlayerAttributeValue(pnum, INV_DAMAGEPERCENT_INCREASE) +
			MapTalentToPercentBonus(pnum, TALENT_OCCULT) +
			Player_Elixir_Bonuses[pnum].damage_type_bonus[TALENT_OCCULT];
	if(temp)
		res = res * (100 + temp) / 100;
		
	// finally crit chance
	if(CheckCritChance(-1)) {
		res = res * GetCritModifier() / 100;
		HandleHunterTalisman();
	}
	res *= random(rnd & 0xFFFF, rnd >> 16);
		
	//printbold(d:res);
	SetResultValue(res);
}

Script "DnD Take Summon Check" (int monsterID) {
	switch(monsterID) {
		case MONSTER_PET_ZOMBIE:
			SetActivator(0, AAPTR_MASTER);
			TakeInventory(StrParam(s:"PetDamageReduction_", d:CheckInventory("PetCounter")), 1);
			TakeInventory("SummonedZombiePets", 1);
			TakeInventory("PetCounter", 1);
			if(CheckInventory("PetCounter"))
				GiveInventory(StrParam(s:"PetDamageReduction_", d:CheckInventory("PetCounter")), 1);
		break;
	}
}

Script "DnD On Pet Summon" (void) {
	// check for damage shared buff
	if(CheckInventory("StatbuffCounter_PainSharedWithPets")) {
		// a bit of delay to register the pet summoning
		Delay(const:10);
		if(CheckInventory("PetCounter"))
			GiveInventory(StrParam(s:"PetDamageReduction_", d:CheckInventory("PetCounter")), 1);
	}
}

Script "DnD Pet Distance Move" (void) {
	int master = GetActorProperty(0, APROP_MASTERTID), dx, dy, dz;
	while(IsAlive()) {
		if(!CheckInventory("MovePetCooldown")) {
			dx = GetActorX(0) - GetActorX(master);
			dy = GetActorY(0) - GetActorY(master);
			dz = GetActorZ(0) - GetActorZ(master);
			if(fdistance_delta(dx, dy, dz) > DND_PET_MOVEDIST) {
				GiveInventory("MovePetCooldown", 1);
				Thing_Move(0, master, 1);
				SetActorAngle(0, GetActorAngle(master));
				GiveInventory("PetTargetClear", 1);
			}
		}
		Delay(35);
	}
}

Script "DnD Give Soul Ammo" (int amt) {
	GiveAmmo(amt, DND_AMMOSLOT_SOULS, 0);
}

// called whenever player makes an attack, melee weapons or weapon attacks that use no ammo need to call this explicitly
// reason is this is embedded in ammo gain chance script for ease
Script "DnD On Attack" (void) {
	// elemental bulwark check
	if(CheckInventory("IATTR_ChanceToCastElementalSpell") >= random(1, 100) && !CheckInventory("RandomElementalSpellCooldown")) {
		GiveInventory("RandomElementalSpellCooldown", 1);
		CastRandomElementalSpell();
	}
}

Script "DnD Face Tracer" (void) {
	int target = GetActorProperty(0, APROP_TRACERTID);
	int xdiff = GetActorX(target) - GetActorX(0);
	int ydiff = GetActorY(target) - GetActorY(0);
	SetActorProperty(0, APROP_SCORE, (360 * VectorAngle(xdiff, ydiff)) >> 16);
	SetActorPitch(0, VectorPitch(0, target, xdiff, ydiff, 8.0));
}

Script "DnD Class Select" (void) NET CLIENTSIDE {
	// close the previous menu
	ConsoleCommand("closemenu");
	
	int cpnum = ConsolePlayerNumber();
	
	// don't allow duplicates to be run
	if(GetUserCVar(cpnum, "dnd_onclassmenu"))
		Terminate;
	
	int ctype = GetUserCVar(cpnum, "dnd_playerclass");
	
	SetUserCVar(cpnum, "dnd_classmenu_button", 0);
	SetUserCVar(cpnum, "dnd_onclassmenu", true);
	
	ACS_NamedExecuteAlways("DnD Class Select Screen", 0);
	ACS_NamedExecuteAlways("DnD Class Select Info", 0, ctype);
	ACS_NamedExecuteAlways("DnD Class Select Animated", 0);
	
	int bpress, obpress, dir = 0;
	while(PlayerIsSpectator(cpnum)) {
		bpress = GetPlayerInput(-1, INPUT_BUTTONS);
		obpress = GetPlayerInput(-1, INPUT_OLDBUTTONS);

		// left move
		if(isButtonPressed(bpress, obpress, settings[1][0])) {
			dir = -1;
			ACS_NamedExecuteAlways("DnD Class Select Arrow Press", 0, DND_CLASSMENU_LEFTBUTTON_BIT);
		}
		if(isButtonPressed(bpress, obpress, settings[3][0])) {
			dir = 1;
			ACS_NamedExecuteAlways("DnD Class Select Arrow Press", 0, DND_CLASSMENU_RIGHTBUTTON_BIT);
		}
		if(isButtonPressed(bpress, obpress, BT_USE | BT_ATTACK)) {
			// terminate this, we made our choice
			LocalAmbientSound("RPG/MenuChoose", 127);
			SetUserCVar(cpnum, "dnd_playerclass", ctype);
			ConsoleCommand(StrParam(s:"menu_joinclassidx ", d:ctype));
			ConsoleCommand("menu_joingamewithclass");
			break;
		}
		if(isButtonPressed(bpress, obpress, BT_ALTATTACK)) {
			// clean this, we can exit
			LocalAmbientSound("RPG/MenuClose", 127);
			break;
		}
		
		if(dir != 0) {
			LocalAmbientSound("RPG/MenuMove", 127);
			ctype += dir;
			
			if(ctype < 0)
				ctype = MAXPLAYERCLASSES - 1;
			else if(ctype > MAXPLAYERCLASSES - 1)
				ctype = 0;
			
			// update
			ACS_NamedExecuteAlways("DnD Class Select Info", 0, ctype);
		}
		
		// reset
		dir = 0;
		Delay(const:1);
	}
	SetUserCVar(cpnum, "dnd_onclassmenu", false);
	ACS_NamedExecuteAlways("DnD Class Select Cleanup", 0);
}

Script "DnD Class Select Arrow Press" (int mode) CLIENTSIDE {
	int cpnum = ConsolePlayerNumber();
	int bn = GetUserCVar(cpnum, "dnd_classmenu_button");
	if(bn & mode)
		Terminate;
	bn |= mode;
	SetUserCVar(cpnum, "dnd_classmenu_button", bn);
}

Script "DnD Class Select Screen" (void) CLIENTSIDE {
	int cpnum = ConsolePlayerNumber();
	
	SetHUDSize(600, 450, 1);
	SetFont("BIGFONT");
	HudMessage(s:"\cjSELECT YOUR CHARACTER"; HUDMSG_PLAIN, DND_CLASSMENU_SELECTID, -1, 300.0, 80.0, 0.0);
	
	SetHUDSize(320, 240, 1);
	setFont("DNDCHRSL");
	HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_BACKGROUND, -1, 160.0, 120.0, 0.0);
}

Script "DnD Class Select Animated" (int doDelay) CLIENTSIDE {
	int cpnum = ConsolePlayerNumber();
	bool larr_inc = false, rarr_inc = false;
	int larr_timer = 0, rarr_timer = 0;
	int select_alpha = 0, select_alpha_val = 0;
	
	while(GetUserCVar(cpnum, "dnd_onclassmenu")) {
		// handle button press detection
		if(GetUserCVar(cpnum, "dnd_classmenu_button") & DND_CLASSMENU_LEFTBUTTON_BIT) {
			larr_timer = 0;
			larr_inc = true;
			SetUserCVar(cpnum, "dnd_classmenu_button", GetUserCVar(cpnum, "dnd_classmenu_button") ^ DND_CLASSMENU_LEFTBUTTON_BIT);
		}
		if(GetUserCVar(cpnum, "dnd_classmenu_button") & DND_CLASSMENU_RIGHTBUTTON_BIT) {
			rarr_timer = 0;
			rarr_inc = true;
			SetUserCVar(cpnum, "dnd_classmenu_button", GetUserCVar(cpnum, "dnd_classmenu_button") ^ DND_CLASSMENU_RIGHTBUTTON_BIT);
		}
	
		SetHudSize(320, 240, 1);
		
		// display arrows
		if(larr_inc)
			SetFont("CHSLARR2");
		else
			SetFont("CHSLARR1");
		HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_CLASSCURSOR_LEFTID, -1, 34.0, 66.0, 0.0);
		
		if(rarr_inc)
			SetFont("CHSRARR2");
		else
			SetFont("CHSRARR1");
		HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_CLASSCURSOR_RIGHTID, -1, 284.0, 66.0, 0.0);
		
		SetHudSize(600, 450, 1);
		SetFont("SMALLFONT");
		
		// display press w.e keys text
		select_alpha_val = cos((select_alpha > 70 && select_alpha < 110 ? 70 : select_alpha) * 1.0 / 180);
		if(select_alpha_val < 0)
			select_alpha_val *= -1;
		HudMessage(s:"\c[L7]Press \ci", k:"+use", s:" \c[L7]or \ci", k:"+altattack", s: " \c[L7]to select!"; HUDMSG_PLAIN | HUDMSG_ALPHA, DND_CLASSMENU_BOTTOMTEXTID, -1, 300.4, 376.1, 0.0, select_alpha_val);
		
		Delay(const:1);
		
		// alpha increment
		select_alpha = (select_alpha + 2) % 180;

		// button timers
		if(larr_inc) {
			larr_timer++;
			if(larr_timer >= DND_CLASSMENU_BUTTON_DELAY) {
				larr_timer = 0;
				larr_inc = false;
			}
		}
		
		if(rarr_inc) {
			rarr_timer++;
			if(rarr_timer >= DND_CLASSMENU_BUTTON_DELAY) {
				rarr_timer = 0;
				rarr_inc = false;
			}
		}
	}
}

Script "DnD Class Select Info" (int ctype) CLIENTSIDE {
	SetHUDSize(600, 450, 1);
	SetFont("SMALLFONT");
	SetHudClipRect(100, 84, 384, 384, 336, 1);
	
	HudMessage(s:"\c[J7]", s:DnD_ClassInfo[ctype][DND_CLASSTEXT_TITLE]; HUDMSG_PLAIN, DND_CLASSMENU_CLASSID, -1, 300.4, 96.1, 0.0);
	HudMessage(s:"\cj", s:DnD_ClassInfo[ctype][DND_CLASSTEXT_EXP]; HUDMSG_PLAIN, DND_CLASSMENU_CLASSEXPID, -1, 128.1, 192.1, 0.0);
	
	// perks
	HudMessage(s:DnD_ClassInfo[ctype][DND_CLASSTEXT_PERK_L5]; HUDMSG_PLAIN, DND_CLASSMENU_CLASSPERK5ID, CR_GREEN, 128.1, 256.1, 0.0);
	HudMessage(s:DnD_ClassInfo[ctype][DND_CLASSTEXT_PERK_L25]; HUDMSG_PLAIN, DND_CLASSMENU_CLASSPERK25ID, CR_ORANGE, 128.1, 296.1, 0.0);
	HudMessage(s:DnD_ClassInfo[ctype][DND_CLASSTEXT_PERK_L50]; HUDMSG_PLAIN, DND_CLASSMENU_CLASSPERK50ID, CR_RED, 128.1, 336.1, 0.0);
	
	SetHudClipRect(0, 0, 0, 0, 0, 0);
	
	// show the class images
	SetFont(DnD_ClassInfo[ctype][DND_CLASSTEXT_MUG]);
	HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_MUGIMG, -1, 288.4, 112.1, 0.0);
	SetFont(DnD_ClassInfo[ctype][DND_CLASSTEXT_FRAMELEFT]);
	HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_LEFTIMG, -1, 80.4, 208.1, 0.0);
	SetFont(DnD_ClassInfo[ctype][DND_CLASSTEXT_FRAMERIGHT]);
	HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_RIGHTIMG, -1, 512.4, 208.1, 0.0);
	
	// prev and next class images
	SetFont(DnD_ClassInfo[(ctype - 1 < 0) ? MAXPLAYERCLASSES - 1 : ctype - 1][DND_CLASSTEXT_FRAMELEFT]);
	HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_PREVCLASS_IMGID, -1, 112.4, 96.1, 0.0);
	SetFont(DnD_ClassInfo[(ctype + 1 > MAXPLAYERCLASSES - 1) ? 0 : ctype + 1][DND_CLASSTEXT_FRAMERIGHT]);
	HudMessage(s:"A"; HUDMSG_PLAIN, DND_CLASSMENU_NEXTCLASS_IMGID, -1, 480.4, 96.1, 0.0);
}

Script "DnD Class Select Cleanup" (void) CLIENTSIDE {
	HudMessage(s:""; HUDMSG_PLAIN, DND_CLASSMENU_BACKGROUND, -1, 0, 0, 1.0);
	for(int i = 0; i < DND_CLASSMENU_IDCOUNT; ++i)
		HudMessage(s:""; HUDMSG_PLAIN, DND_CLASSMENU_SELECTID + i, -1, 0, 0, 1.0);
}

Script "DnD Doomguy Soul Pickup" (int val) {
	val = Clamp_Between(val / DND_DOOMGUY_HEALDIV, 1, DND_DOOMGUY_MAXHEAL);
	// setactivatortotarget is SHIT
	SetActivator(0, AAPTR_TARGET);
	ACS_NamedExecuteAlways("DnD Health Pickup", 0, val, 0, 0);
}

Script "DnD Init Shared Translation" (void) {
	Thing_SetTranslation(0, TRANSLATION_ICE);
	Delay(const:17);
	Thing_SetTranslation(0, DND_NO_TRANSLATION);
}

Script "DnD Disable Pickup" (int tid) {
	Thing_SetSpecial(tid, 0, 0, 0, 0);
	Thing_SetTranslation(tid, TRANSLATION_ICE);
	Delay(const:SHARED_ITEM_ACTIVITY_DELAY);
	// these are hardcoded into the engine, won't ever change prob.
	Thing_SetSpecial(tid, 226, DND_SHARED_ITEM_SCRIPT, 0, tid);
	Thing_SetTranslation(tid, DND_NO_TRANSLATION);
}

Script "DnD Budget Giver" (int amt) {
	GiveBudget(amt);
}

Script "DnD Punisher Perk50 Display" (int reset) CLIENTSIDE {
	if(PlayerNumber() != ConsolePlayerNumber() || !isPlayerClass(DND_PLAYER_PUNISHER))
		Terminate;
	Delay(const:5);
	int tmp = 0;
	if(CheckInventory("Punisher_Perk50")) {
		SetFont("OBJFONT");
		SetHudSize(900, 600, 1);
		int x = (GetHudRight(900) << 16) - 5.8;
		if(CheckInventory("DnD_Kills") >= DND_PUNISHER_KILLSPER) {
			if(!reset)
				HudMessage(s:"\c[I7]", f:ftrunc(100 * (DND_PUNISHER_DMGINC * (CheckInventory("DnD_Kills") / DND_PUNISHER_KILLSPER))), s:"%\c- more damage"; HUDMSG_PLAIN, PUNISHERPERKID1, -1, x, 450.0, 0.0);
			else // clear because we died
				HudMessage(s:""; HUDMSG_PLAIN, PUNISHERPERKID1, -1, x, 450.0, 0.0);
		}
		tmp = Clamp_Between(DND_PUNISHER_KILLSPER - CheckInventory("Punisher_Perk50_Counter"), 0, DND_PUNISHER_KILLSPER);
		HudMessage(s:"Kill \c[I7]", d:tmp, s:"\c- for buff"; HUDMSG_PLAIN, PUNISHERPERKID2, -1, x, 480.0, 0.0);
	}
}

Script 1006 (int pnum) NET CLIENTSIDE {
	if(PlayerInGame(pnum)) {
		int tid = pnum + P_TIDSTART;
		int this = ActivatorTID();
		int i, j, temp, itype, cnt, val;
		
		Log(s:"\n================================\n====== DnD Player Lookup ======\n================================\n");
		SetActivator(tid);
		Log(s:"\cdPlayer: \c-", n:pnum + 1, s:"\n\cdLevel: \c-", d:CheckInventory("Level"));
		Log(s:"\cdClass: \c-", s:"\c[J7]", s:DnD_ClassInfo[CheckInventory("DnD_Character") - 1][DND_CLASSTEXT_TITLE]);
		Log(s:"\cdHealth: \c-", d:GetActorProperty(0, APROP_HEALTH), s: " / ", d:GetSpawnHealth());
		Log(s:"\cdArmor: \c-", d:CheckInventory("Armor"), s: " / ", d:GetArmorCap(true));
		
		Log(s:"\n--------------------------------\n------- Stat Allocation -------\n--------------------------------\n");
		Log(s:"\c[Y5]Strength: \c-", d:GetStrength(), s:"\n\c[Y5]Dexterity: \c-", d:GetDexterity(), s:"\n\c[Y5]Bulkiness: \c-", d:GetBulkiness());
		Log(s:"\c[Y5]Charisma: \c-", d:GetCharisma(), s:"\n\c[Y5]Vitality: \c-", d:GetVitality(), s:"\n\c[Y5]Intellect: \c-", d:GetIntellect());
		
		Log(s:"\n--------------------------------\n------- Perk Allocation -------\n--------------------------------\n");
		for(i = 0; i < DND_MAX_PERKS; ++i)
			Log(s:"\c[Y5]", s:StatLabels[DND_PERK_BEGIN + i], s:": \c-", d:CheckInventory(StatNames[DND_PERK_BEGIN + i]));
		
		Log(s:"\n--------------------------------\n------- Accessories -------\n--------------------------------\n");
		for(j = 0, i = 0; i < MAX_ACCESSORY && j < 2; ++i) {
			if(IsAccessoryEquipped(0, 1 << i)) {
				Log(s:"\c[Y5]Accessory ", d:(j + 1), s:": \c[C5]", s:AccessoryInfo[i][ACCESSORY_TAG]);
				++j;
			}
		}
		if(!j)
			Log(s:"\c[Y5]Accessory 1: \cuN/A\n\c[Y5]Accessory 2: \cuN/A");
		else if(j == 1)
			Log(s:"\c[Y5]Accessory 2: \cuN/A");
			
		Log(s:"\n--------------------------------\n------- Weapons Owned -------\n--------------------------------\n");
		for(i = 0; i < MAXWEPS; ++i)
			if(CheckInventory(Weapons[i][WEAPON_NAME]))
				Log(s:"\cd* \c[Y5]", s:Weapons[i][WEAPON_TAG], s:" - \cjSlot ", s:Weapons[i][WEAPON_SLOT]);
				
		Log(s:"\n--------------------------------\n------- Charms Used -------\n--------------------------------\n");
		for(i = 0; i < MAX_CHARMS_EQUIPPABLE; ++i) {
			itype = Charms_Used[pnum][i].item_type;
			if(itype != DND_ITEM_NULL) {
				if(itype == DND_ITEM_CHARM) {
					Log(s:Charm_Tiers[GetItemSyncValue(DND_SYNC_ITEMLEVEL, i, pnum, DND_SYNC_ITEMSOURCE_CHARMUSED) / CHARM_ATTRIBLEVEL_SEPERATOR], s: " ", s:Charm_TypeName[GetItemSyncValue(DND_SYNC_ITEMSUBTYPE, i, pnum, DND_SYNC_ITEMSOURCE_CHARMUSED)], s:" Charm");
					temp = GetItemSyncValue(DND_SYNC_ITEMSATTRIBCOUNT, i, pnum, DND_SYNC_ITEMSOURCE_CHARMUSED);
					for(j = 0; j < temp; ++j)
						Log(s:"    ", s:ItemAttributeString(GetItemSyncValue(DND_SYNC_ITEMATTRIBUTES_ID, i, j | pnum, DND_SYNC_ITEMSOURCE_CHARMUSED), GetItemSyncValue(DND_SYNC_ITEMATTRIBUTES_VAL, i, j | pnum, DND_SYNC_ITEMSOURCE_CHARMUSED)));
				}
				else if(itype > UNIQUE_BEGIN) {
					temp = itype & 0xFFFF;
					itype >>= UNIQUE_BITS;
					--itype;
					// itype holds unique position, temp is the actual item type
					Log(s:"\c[A1]", s:UniqueItemNames[itype], s:"\c- - \c[D1]Unique ", s:Charm_TypeName[GetItemSyncValue(DND_SYNC_ITEMSUBTYPE, i, pnum, DND_SYNC_ITEMSOURCE_CHARMUSED)], s:" Charm");
					cnt = GetItemSyncValue(DND_SYNC_ITEMSATTRIBCOUNT, i, pnum, DND_SYNC_ITEMSOURCE_CHARMUSED);
					// itype will count the skipped properties (the helper attributes)
					itype = 0;
					for(j = 0; j < cnt; ++j) {
						temp = GetItemSyncValue(DND_SYNC_ITEMATTRIBUTES_ID, i, j | pnum, DND_SYNC_ITEMSOURCE_CHARMUSED);
						val = GetItemSyncValue(DND_SYNC_ITEMATTRIBUTES_VAL, i, j | pnum, DND_SYNC_ITEMSOURCE_CHARMUSED);
						if(val > 0) {
							// dont show this, skip to next attribute's detail
							if(temp == INV_EX_CHANCE) {
								++j;
								++itype;
								Log(s:"    ", s:ExoticAttributeString(GetItemSyncValue(DND_SYNC_ITEMATTRIBUTES_ID, i, j | pnum, DND_SYNC_ITEMSOURCE_CHARMUSED), val, GetItemSyncValue(DND_SYNC_ITEMATTRIBUTES_VAL, i, j | pnum, DND_SYNC_ITEMSOURCE_CHARMUSED)));
							}
							else
								Log(s:"    ", s:ExoticAttributeString(temp, val, 0));
						}
						else if(!val) {
							// unique item doesn't have numeric attribute to show
							Log(s:"    ", s:ExoticAttributeString(temp, val, 0));
						}
						else
							Log(s:"    - ", s:ExoticAttributeString(temp, val, 0));
					}
				}
			}
			else
				Log(s:"\cuN/A");
		}
		
		SetActivator(this);
	}
	else
		Log(s:"\cgERROR: \cjPlayer isn't currently playing!");
}

Script "DnD Monster Health Regen Script" (int style, int amount, int period) {
	// how many periods will be waited for this to end?
	int duration = style >> 16;
	int mid = ActivatorTID() - DND_MONSTERTID_BEGIN;
	style &= 0xFFFF;
	if(style == DND_MHR_DURATION) {
		while(duration) {
			if(!CheckInventory("MonsterRegenPause")) {
				HealMonster(mid, amount);
				--duration;
			}
			Delay(period);
		}
	}
	else if(style == DND_MHR_PERIODIC) {
		while(isAlive()) {
			if(!CheckInventory("MonsterRegenPause"))
				HealMonster(mid, amount);
			Delay(period);
		}
	}
}

// Needs to be here as it loops through monster tid variable which is changed through this part
Script "DnD Tcherno Corpse Explode" (void) {
	for(int i = DND_MONSTERTID_BEGIN; i < DnD_TID_List[DND_TID_MONSTER]; ++i) {
		if(!isActorAlive(i) && fdistance(0, i) <= DREAMER_CORPSEEXPLOSION_DIST) {
			GiveActorInventory(i, "TchernoCorpseExploder", 1);
			ACS_NamedExecuteAlways("DnD Tcherno Corpse Explode Gib Giver", 0, i);
		}
	}
}

Script "DnD Tcherno Corpse Explode Gib Giver" (int i) CLIENTSIDE {
	Delay(const:TICRATE);
	GiveActorInventory(i, "TchernoCorpseExploder_Gibber", 1);
}

Script "DnD Item Linger Check" (int sp) {
	int counter = 0;
	sp >>= 16;
	while(counter < DND_ITEM_LINGER_TIME) {
		++counter;
		Delay(const:TICRATE);
		// if this is picked up, terminate early
		if(Inventories_On_Field[sp].item_type == DND_ITEM_NULL)
			Terminate;
	}
	// not picked until now, remove it
	RemoveItemFromWorld(sp);
	Thing_Remove(0);
}

Script "DnD Store Projectile Owner" (void) {
	SetActorProperty(0, APROP_SCORE, GetActorProperty(0, APROP_TARGETTID));
	//printbold(s:"storing owner ", d:GetActorProperty(0, APROP_SCORE));
	SetResultValue(0);
}

/*Script 69 (void) NET {
	SetInventory("Level", 98);
	SetInventory("Exp", GetExpLimit() / 2);
	SetInventory("LevelExpCap", GetExpLimit());
	CalculateExpRatio();
}

Script 70 (void) NET {
	GiveInventory("Exp", 63107200);
	GiveInventory("LevelUpChecker", 1);
	CalculateExpRatio();
}*/