#library "DND_DB"
#nocompact
#include "zcommon.h"

#include "DnD_Common.h"
#include "DnD_MenuConstants.h"
#include "DnD_Weapons.h"
#include "DnD_Research.h"
#include "DnD_DatabaseRows.h"
#include "DnD_TempWeps.h"
#include "DnD_Stat.h"
#include "DnD_Orbs.h"

#define DND_MAX_CHARS 5

enum {
	DND_LOGIN_NOCHAR,
	DND_LOGIN_CREATECHAROK,
	DND_LOGIN_CHARINUSE,
	DND_LOGIN_NOCHARINUSE,
	DND_LOGIN_NOTINGAME,
	DND_LOGIN_NOTHARDCORE,
	DND_LOGIN_INCOUNTDOWN,
	DND_LOGIN_NOTLOGGED,
	DND_LOGIN_NOTIME,
	DND_LOGIN_CHARNOTINRANGE,
	DND_LOGIN_TRANSFSAMESLOT,
	DND_CHARLOADED,
	DND_LOGIN_CHARTRANSFERRED,
};

enum {
	DND_PINVFLAGS_CHARMUSED = 1,
	DND_PINVFLAGS_INVENTORY = 2,
	DND_PINVFLAGS_STASH = 4,
	DND_PINVFLAGS_ALL = 7
};

/*

-- PLAYER STUFF SAVE --

* Save weapons in three ints, use bits. There are enough weapons to fit in 96 bits.
* Save artifacts and accessories the same way, each occupying an int. For artifacts having more than 1 carryable value, use 2-3 bits.
* Save player stats like this => 8 bits from an int for each stat, 4 stats can fit in this way. Rest of the stats can occupy their place similarly.
* Save backpack counts to the 5th stat's int, starting from bit 8. Max backpack count is < 64, so 6 bits is enough.
* Save all perk counts into an int. Max perk count is 10, so 4 bits needed. 8 perks, so 32 bits is enough.
* Save health and armor into one int. Health max can be around 65536, so assume 16 bits. Armor can be max around same so both can fit.
* Save armor type as a new int with each bit as an armor type.
* For every weapon ammo, safest way to go is use an int for each type. Their limits are dynamic and annoying to use bits with.
* For Talents, each talent can go up to 100. 8 bits per talent. Store 4 talent per int. We need 2 ints because we got 6 talents.
* For exp, level and credit use one int each.
* For abilities use one int, each ability occupies one bit.
* For researches, things are a bit tricky. A research can be 0 (NA), 1 (KNOWN) or 2 (DONE). We need 2 bits to state the value of a research.
* Finally for leftover stat and perk points, use one int. A player can have at most 1023 stats, so 10 bits. Assuming the same for perks, 10 more bits for that.
* For budget, use an int's first 10 bits. (Budget limit is 1000)
*!! For orbs, each take 8 bits. Can support 8 different types of orbs in 2 ints.
* For weapons that the orbs are used, for compat with weapon mods (extra stats etc.) we must store each weapon data individually. For each weapon, do the following:
	- Weapon enhancement %, from 0 - 25, in first 5 bits.
	- Rest of the 27 bits will be used for mod saving.
* Format for saving player inventory:
	- Use DND_DB_PLAYERINVENTORY, append inventory index.
	- Save every field of an inventory_T for this spot by appending the said field to the one above.
	- Do not save pointers to width/height, we'll reconstruct those while loading the items.
	- We are also not saving topleftboxid field, as it corresponds to the inventory index we're loading.
*/

void ResetPlayer() {
	int i;
	SetInventory("ReflectCount", 0);
	SetInventory("Intervened", 0);
	SetInventory("CanIntervene", 1);
	TakeInventory("SetMyLives", 1);
	SetInventory("ShowingMenu", 0);
	
	// take all weapons
	for(i = 0; i < MAXWEPS; ++i)
		TakeInventory(Weapons[i][WEAPON_NAME], 1);
	for(i = 1; i <= 9; ++i)
		TakeInventory(StrParam(s:"H_WeaponSlot", d:i), 1);
	
	// take all abilities
	for(i = 0; i < MAXABILITIES; ++i)
		SetInventory(AbilityInfo[i], 0);
	
	// take all research stuff
	for(i = 0; i < RESEARCH_BITSETS; ++i) {
		SetInventory(StrParam(s:"Research_Done_", d:i + 1), 0);
		SetInventory(StrParam(s:"Research_Discovered_", d:i + 1), 0);
	}
	ACS_NamedExecuteAlways("DND Menu Cleanup", 0);
}

void RestoreResearchItems() {
	if(CheckResearchStatus(RES_DOUBLESPECIALCAP) == RES_DONE)
		DoubleSpecialAmmoCapacity();
		
}

str GetCharField(str fname, int char_id) {
	return StrParam(s:"C", d:char_id, s:"_", s:fname);
}

void SavePlayerInventoryStuff(int pnum, int char_id, int tid, str pacc, int flags) {
	int i, j, temp;
	// Inventory related stuff
	// save inventory state of player
	if(flags & DND_PINVFLAGS_INVENTORY) {
		for(i = 0; i < MAX_INVENTORY_BOXES; ++i) {
			// we got the main item pointer here
			if(PlayerInventoryList[pnum][i].topleftboxid - 1 == i) {
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_WIDTH), char_id), pacc, PlayerInventoryList[pnum][i].width);
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_HEIGHT), char_id), pacc, PlayerInventoryList[pnum][i].height);
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_IMAGE), char_id), pacc, PlayerInventoryList[pnum][i].item_image);
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_TYPE), char_id), pacc, PlayerInventoryList[pnum][i].item_type);
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_SUBTYPE), char_id), pacc, PlayerInventoryList[pnum][i].item_subtype);
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_LEVEL), char_id), pacc, PlayerInventoryList[pnum][i].item_level);
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_STACK), char_id), pacc, PlayerInventoryList[pnum][i].item_stack);
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBCOUNT), char_id), pacc, PlayerInventoryList[pnum][i].attrib_count);
				for(j = 0; j < PlayerInventoryList[pnum][i].attrib_count; ++j) {
					SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBVAL, s:"_", d:j), char_id), pacc, PlayerInventoryList[pnum][i].attributes[j].attrib_val);
					SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBID, s:"_", d:j), char_id), pacc, PlayerInventoryList[pnum][i].attributes[j].attrib_id);
				}
			}
			else {
				// clean whatever state existed here previously
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_WIDTH), char_id), pacc, 0);
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_HEIGHT), char_id), pacc, 0);
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_IMAGE), char_id), pacc, 0);
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_TYPE), char_id), pacc, DND_ITEM_NULL);
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_SUBTYPE), char_id), pacc, 0);
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_LEVEL), char_id), pacc, 0);
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_STACK), char_id), pacc, 0);
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBCOUNT), char_id), pacc, 0);
				for(j = 0; j < PlayerInventoryList[pnum][i].attrib_count; ++j) {
					SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBVAL, s:"_", d:j), char_id), pacc, 0);
					SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBID, s:"_", d:j), char_id), pacc, 0);
				}
			}
		}
	}
	if(flags & DND_PINVFLAGS_CHARMUSED){
		// save charms used
		for(i = 0; i < MAX_CHARMS_EQUIPPABLE; ++i) {
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_WIDTH), char_id), pacc, Charms_Used[pnum][i].width);
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_HEIGHT), char_id), pacc, Charms_Used[pnum][i].height);
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_IMAGE), char_id), pacc, Charms_Used[pnum][i].item_image);
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_TYPE), char_id), pacc, Charms_Used[pnum][i].item_type);
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_SUBTYPE), char_id), pacc, Charms_Used[pnum][i].item_subtype);
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_LEVEL), char_id), pacc, Charms_Used[pnum][i].item_level);
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_STACK), char_id), pacc, Charms_Used[pnum][i].item_stack);
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBCOUNT), char_id), pacc, Charms_Used[pnum][i].attrib_count);
			for(j = 0; j < Charms_Used[pnum][i].attrib_count; ++j) {
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBVAL, s:"_", d:j), char_id), pacc, Charms_Used[pnum][i].attributes[j].attrib_val);
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBID, s:"_", d:j), char_id), pacc, Charms_Used[pnum][i].attributes[j].attrib_id);
			}
		}
	}
	if(flags & DND_PINVFLAGS_STASH) {
		// save state of player's stash (this is shared between all accounts so no charfield)
		SetDBEntry(DND_DB_STASH_PAGES, pacc, CheckActorInventory(tid, "DnD_PlayerInventoryPages"));
		for(i = 0; i < CheckActorInventory(tid, "DnD_PlayerInventoryPages"); ++i) {
			for(j = 0; j < MAX_INVENTORY_BOXES; ++j) {
				if(PlayerStashList[pnum][i][j].topleftboxid - 1 == j) {
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_WIDTH), pacc, PlayerStashList[pnum][i][j].width);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_HEIGHT), pacc, PlayerStashList[pnum][i][j].height);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_IMAGE), pacc, PlayerStashList[pnum][i][j].item_image);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_TYPE), pacc, PlayerStashList[pnum][i][j].item_type);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_SUBTYPE), pacc, PlayerStashList[pnum][i][j].item_subtype);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_LEVEL), pacc, PlayerStashList[pnum][i][j].item_level);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_STACK), pacc, PlayerStashList[pnum][i][j].item_stack);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBCOUNT), pacc, PlayerStashList[pnum][i][j].attrib_count);
					for(temp = 0; temp < PlayerStashList[pnum][i][j].attrib_count; ++temp) {
						SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBVAL, s:"_", d:temp), pacc, PlayerStashList[pnum][i][j].attributes[temp].attrib_val);
						SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBID, s:"_", d:temp), pacc, PlayerStashList[pnum][i][j].attributes[temp].attrib_id);
					}
				}
				else {
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_WIDTH), pacc, 0);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_HEIGHT), pacc, 0);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_IMAGE), pacc, 0);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_TYPE), pacc, DND_ITEM_NULL);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_SUBTYPE), pacc, 0);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_LEVEL), pacc, 0);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_STACK), pacc, 0);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBCOUNT), pacc, 0);
					for(temp = 0; temp < PlayerStashList[pnum][i][j].attrib_count; ++temp) {
						SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBVAL, s:"_", d:temp), pacc, 0);
						SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBID, s:"_", d:temp), pacc, 0);
					}
				}
			}
		}
	}
}

void SavePlayerItem(int pnum, int char_id, int itemid, int source) {
	if(HardcoreSet && (GetCVar("dnd_mode") >= DND_MODE_SOFTCORE) && PlayerIsLoggedIn(pnum)) {
		BeginDBTransaction();
		int tid = pnum + P_TIDSTART, i, j, k, temp;
		char_id = Clamp_Between(char_id, 0, DND_MAX_CHARS - 1); // DnD_CharacterID defaults to 1 if no cmds are used.
		str pacc = GetPlayerAccountName(pnum);
		
		int w = GetItemSyncValue(DND_SYNC_ITEMWIDTH, itemid, -1, source);
		int h = GetItemSyncValue(DND_SYNC_ITEMHEIGHT, itemid, -1, source);
		int page = source >> 16;
		source &= 0xFFFF;
		if(source == DND_SYNC_ITEMSOURCE_PLAYERINVENTORY) {
			for(i = 0; i < w; ++i) {
				for(j = 0; j < h; ++j) {
					temp = itemid + i + j * MAXINVENTORYBLOCKS_VERT;
					// save item stuff
					SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:temp, s:DND_DB_PLAYERINVENTORYFIELD_WIDTH), char_id), pacc, PlayerInventoryList[pnum][itemid].width);
					SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:temp, s:DND_DB_PLAYERINVENTORYFIELD_HEIGHT), char_id), pacc, PlayerInventoryList[pnum][itemid].height);
					SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:temp, s:DND_DB_PLAYERINVENTORYFIELD_IMAGE), char_id), pacc, PlayerInventoryList[pnum][itemid].item_image);
					SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:temp, s:DND_DB_PLAYERINVENTORYFIELD_TYPE), char_id), pacc, PlayerInventoryList[pnum][itemid].item_type);
					SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:temp, s:DND_DB_PLAYERINVENTORYFIELD_SUBTYPE), char_id), pacc, PlayerInventoryList[pnum][itemid].item_subtype);
					SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:temp, s:DND_DB_PLAYERINVENTORYFIELD_LEVEL), char_id), pacc, PlayerInventoryList[pnum][itemid].item_level);
					SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:temp, s:DND_DB_PLAYERINVENTORYFIELD_STACK), char_id), pacc, PlayerInventoryList[pnum][itemid].item_stack);
					SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:temp, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBCOUNT), char_id), pacc, PlayerInventoryList[pnum][itemid].attrib_count);
					for(k = 0; k < PlayerInventoryList[pnum][itemid].attrib_count; ++k) {
						SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:temp, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBVAL, s:"_", d:k), char_id), pacc, PlayerInventoryList[pnum][itemid].attributes[k].attrib_val);
						SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:temp, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBID, s:"_", d:k), char_id), pacc, PlayerInventoryList[pnum][itemid].attributes[k].attrib_id);
					}
				}
			}
		}
		else if(source == DND_SYNC_ITEMSOURCE_STASH) {
			for(i = 0; i < w; ++i) {
				for(j = 0; j < h; ++j) {
					temp = itemid + i + j * MAXINVENTORYBLOCKS_VERT;
					// save item stuff
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:page, s:"_", d:temp, s:DND_DB_PLAYERINVENTORYFIELD_WIDTH), pacc, PlayerStashList[pnum][page][temp].width);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:page, s:"_", d:temp, s:DND_DB_PLAYERINVENTORYFIELD_HEIGHT), pacc, PlayerStashList[pnum][page][temp].height);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:page, s:"_", d:temp, s:DND_DB_PLAYERINVENTORYFIELD_IMAGE), pacc, PlayerStashList[pnum][page][temp].item_image);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:page, s:"_", d:temp, s:DND_DB_PLAYERINVENTORYFIELD_TYPE), pacc, PlayerStashList[pnum][page][temp].item_type);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:page, s:"_", d:temp, s:DND_DB_PLAYERINVENTORYFIELD_SUBTYPE), pacc, PlayerStashList[pnum][page][temp].item_subtype);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:page, s:"_", d:temp, s:DND_DB_PLAYERINVENTORYFIELD_LEVEL), pacc, PlayerStashList[pnum][page][temp].item_level);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:page, s:"_", d:temp, s:DND_DB_PLAYERINVENTORYFIELD_STACK), pacc, PlayerStashList[pnum][page][temp].item_stack);
					SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:page, s:"_", d:temp, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBCOUNT), pacc, PlayerStashList[pnum][page][temp].attrib_count);
					for(k = 0; k < PlayerStashList[pnum][page][temp].attrib_count; ++k) {
						SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:page, s:"_", d:temp, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBVAL, s:"_", d:k), pacc, PlayerStashList[pnum][page][temp].attributes[k].attrib_val);
						SetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:page, s:"_", d:temp, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBID, s:"_", d:k), pacc, PlayerStashList[pnum][page][temp].attributes[k].attrib_id);
					}
				}
			}
		}
		else {
			// charms used
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:itemid, s:DND_DB_PLAYERINVENTORYFIELD_WIDTH), char_id), pacc, Charms_Used[pnum][itemid].width);
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:itemid, s:DND_DB_PLAYERINVENTORYFIELD_HEIGHT), char_id), pacc, Charms_Used[pnum][itemid].height);
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:itemid, s:DND_DB_PLAYERINVENTORYFIELD_IMAGE), char_id), pacc, Charms_Used[pnum][itemid].item_image);
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:itemid, s:DND_DB_PLAYERINVENTORYFIELD_TYPE), char_id), pacc, Charms_Used[pnum][itemid].item_type);
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:itemid, s:DND_DB_PLAYERINVENTORYFIELD_SUBTYPE), char_id), pacc, Charms_Used[pnum][itemid].item_subtype);
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:itemid, s:DND_DB_PLAYERINVENTORYFIELD_LEVEL), char_id), pacc, Charms_Used[pnum][itemid].item_level);
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:itemid, s:DND_DB_PLAYERINVENTORYFIELD_STACK), char_id), pacc, Charms_Used[pnum][itemid].item_stack);
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:itemid, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBCOUNT), char_id), pacc, Charms_Used[pnum][itemid].attrib_count);
			for(j = 0; j < Charms_Used[pnum][itemid].attrib_count; ++j) {
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:itemid, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBVAL, s:"_", d:j), char_id), pacc, Charms_Used[pnum][itemid].attributes[j].attrib_val);
				SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:itemid, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBID, s:"_", d:j), char_id), pacc, Charms_Used[pnum][itemid].attributes[j].attrib_id);
			}
		}
		EndDBTransaction();
	}
}

void SavePlayerData(int pnum, int char_id) {
	int temp, tid = pnum + P_TIDSTART, i, j;
	char_id = Clamp_Between(char_id, 0, DND_MAX_CHARS-1); // DnD_CharacterID defaults to 1 if no cmds are used.
	str pacc = GetPlayerAccountName(pnum);
	// save weapons
	for(i = 0; i < MAXWEPS; ++i) {
		j = i / 32;
		if(CheckActorInventory(tid, Weapons[i][WEAPON_NAME])) {
			temp = SetBit(temp, i - 32 * j);
		}
		if(j != (i + 1) / 32 || i == MAXWEPS - 1) { // ie. our j changed or we hit maxweps
			// send temp over
			SetDBEntry(GetCharField(StrParam(s:DND_DB_WEAPONINT, d:j + 1), char_id), pacc, temp);
			temp = 0;
		}
	}
	
	for(i = 0; i < MAXTEMPAMMO; ++i)
		SetDBEntry(GetCharField(StrParam(s:DND_DB_TEMPAMMO, d:i), char_id), pacc, CheckActorInventory(tid, TemporaryAmmos[i]));
	
	// save stats of player (can fit 4 stats in one int, using 7 bits)
	temp = CheckActorInventory(tid, "PSTAT_Strength");
	temp |= (0xFF & CheckActorInventory(tid, "PSTAT_Dexterity")) << 8;
	temp |= (0xFF & CheckActorInventory(tid, "PSTAT_Bulkiness")) << 16;
	temp |= (0xFF & CheckActorInventory(tid, "PSTAT_Charisma")) << 24;
	// send temp over
	SetDBEntry(GetCharField(DND_DB_STATS_1, char_id), pacc, temp);
	
	// save vitality, backpack count and active accessory
	temp = CheckActorInventory(tid, "PSTAT_Vitality");
	// backpack covers 6 bits max (count = 55 < 63)
	temp |= CheckActorInventory(tid, "BackpackCounter") << 8; // for backpack
	// send temp over
	SetDBEntry(GetCharField(DND_DB_STATS_2, char_id), pacc, temp);
	
	// save intellect
	temp = CheckActorInventory(tid, "PSTAT_Intellect");
	temp <<= 16;
	temp |= CheckActorInventory(tid, "TalentPoint");
	SetDBEntry(GetCharField(DND_DB_STATS_3, char_id), pacc, temp);
	
	// save perks (use 4 bits per perk, max is 10 for a perk)
	temp = CheckActorInventory(tid, "Perk_Sharpshooting");
	temp |= (0xF & CheckActorInventory(tid, "Perk_Endurance")) << 4;
	temp |= (0xF & CheckActorInventory(tid, "Perk_Wisdom")) << 8;
	temp |= (0xF & CheckActorInventory(tid, "Perk_Greed")) << 12;
	temp |= (0xF & CheckActorInventory(tid, "Perk_Medic")) << 16;
	temp |= (0xF & CheckActorInventory(tid, "Perk_Munitionist")) << 20;
	temp |= (0xF & CheckActorInventory(tid, "Perk_Deadliness")) << 24;
	temp |= (0xF & CheckActorInventory(tid, "Perk_Savagery")) << 28;
	// send temp over
	SetDBEntry(GetCharField(DND_DB_PERKS, char_id), pacc, temp);
	
	// save perks - 2
	temp = CheckActorInventory(tid, "Perk_Luck");
	SetDBEntry(GetCharField(DND_DB_PERKS2, char_id), pacc, temp);
	
	// save health and armor
	temp = GetActorProperty(tid, APROP_HEALTH);
	temp <<= 16;
	temp |= CheckActorInventory(tid, "Armor");
	SetDBEntry(GetCharField(DND_DB_HEALTHARMOR, char_id), pacc, temp);
	
	// save armor type
	temp = 0;
	for(i = 0; i < MAXARMORS; ++i) {
		if(i >= 1 && i <= 4) { // green to red armor have variations that don't spawn
			if(GetArmorType(ArmorTypes[i], pnum) || GetArmorType(StrParam(s:ArmorTypes[i], d:2), pnum)) {
				temp = SetBit(temp, i);
				break;
			}
		}
		else {
			if(GetArmorType(ArmorTypes[i], pnum)) {
				temp = SetBit(temp, i);
				break;
			}
		}
	}
	// send temp over
	SetDBEntry(GetCharField(DND_DB_ARMORTYPE, char_id), pacc, temp);
	
	// save ammo counts
	for(i = 0; i < MAX_SLOTS; ++i)
		for(j = 0; j < MAX_AMMOTYPES_PER_SLOT && AmmoInfo[i][j].initial_capacity != -1; ++j) {
			temp = CheckActorInventory(tid, AmmoInfo_Str[i][j][AMMOINFO_NAME]);
			// send temp over
			SetDBEntry(StrParam(s:GetCharField(DND_DB_AMMO, char_id), s:AmmoInfo_Str[i][j][AMMOINFO_NAME]), pacc, temp);
		}
		
	for(i = 0; i < MAX_SPECIAL_AMMOS; ++i) {
		temp = CheckActorInventory(tid, SpecialAmmoInfo_Str[i][AMMOINFO_NAME]);
		// send temp over
		SetDBEntry(StrParam(s:GetCharField(DND_DB_SPECIALAMMO, char_id), s:SpecialAmmoInfo_Str[i][AMMOINFO_NAME]), pacc, temp);
	}
	
	// save weapon clips/magazines that use them
	for(i = 0; i < MAXCLIPAMMOTYPES; ++i) {
		temp = CheckActorInventory(tid, ClipAmmoTypes[i]);
		// send temp over
		SetDBEntry(StrParam(s:GetCharField(DND_DB_AMMO, char_id), s:ClipAmmoTypes[i]), pacc, temp);
	}
	
	// save talents (8 bits per talent, can save 4 talents in one int)
	temp = 0;
	for(i = 0; i < 4; ++i)
		temp |= (0xFF & CheckActorInventory(tid, TalentNames[i][TALENT_TAG])) << (8 * i);
	// send temp over
	SetDBEntry(GetCharField(DND_DB_TALENT_1, char_id), pacc, temp);
	
	temp = 0;
	for(i = 4; i < MAX_TALENTS; ++i)
		temp |= (0xFF & CheckActorInventory(tid, TalentNames[i][TALENT_TAG])) << (8 * (i - 4));
	SetDBEntry(GetCharField(DND_DB_TALENT_2, char_id), pacc, temp);
	
	// save exp, credit and level (when loading give expvisual, amt = exp % levelcurve[level])
	temp = CheckActorInventory(tid, "Exp");
	// send temp over
	SetDBEntry(GetCharField(DND_DB_EXP, char_id), pacc, temp);
	
	temp = CheckActorInventory(tid, "Credit");
	//send temp over
	SetDBEntry(GetCharField(DND_DB_CREDIT, char_id), pacc, temp);
	
	temp = CheckActorInventory(tid, "Level");
	if(!temp)
		temp = 1; // fix level 0 saves
	// send temp over
	SetDBEntry(GetCharField(DND_DB_LEVEL, char_id), pacc, temp);
	
	// save abilities
	temp = 0;
	for(i = 0; i < MAXABILITIES; ++i) {
		if(CheckActorInventory(tid, AbilityInfo[i]))
			temp = SetBit(temp, i);
	}
	// send temp over
	SetDBEntry(GetCharField(DND_DB_ABILITY, char_id), pacc, temp);
	
	// save unspent attribute/perk points
	temp = CheckActorInventory(tid, "AttributePoint");
	temp |= (0x7FF & CheckActorInventory(tid, "PerkPoint")) << 11;
	// send temp over
	SetDBEntry(GetCharField(DND_DB_ATTRIBUTEPERK, char_id), pacc, temp);
	
	// save accessories and artifacts
	temp = 0;
	for(i = 0; i < MAX_ACCESSORY; ++i) {
		if(CheckActorInventory(tid, StrParam(s:"Accessory_", d:i + 1)))
			temp = SetBit(temp, i);
	}
	// send temp over
	SetDBEntry(GetCharField(DND_DB_ACCESSORIES, char_id), pacc, temp);
	
	// save active accessories
	SetDBEntry(GetCharField(DND_DB_ACTIVEACCESSORIES, char_id), pacc, CheckActorInventory(tid, "Accessory_Index"));
	
	temp = 0;
	// fieldkits can have 3, assume 3 bits. (Maybe in future) Portable Shields hold 3 as well. Rest are all 1. Do not save automap.
	// Take fieldkit and portable shields last
	// this guy breaks the loop sequence so take him first
	temp |= CheckActorInventory(tid, "SalvationSphere");
	for(i = 3; i < MAXARTIFACTS - 3; ++i) {
		if(CheckActorInventory(tid, ArtifactInfo[i][ARTI_NAME]))
			temp = SetBit(temp, i - 2); // because 0th bit is for salvation sphere
	}
	// last 3 won't be saved and these two arent saved yet, so anything besides these are saved until here
	temp |= CheckActorInventory(tid, "FieldKit") << (MAXARTIFACTS - 5); 
	temp |= CheckActorInventory(tid, "PortableShield") << (MAXARTIFACTS - 3);
	temp |= CheckActorInventory(tid, "StatReset") << (MAXARTIFACTS - 1);
	// send temp over
	SetDBEntry(GetCharField(DND_DB_ARTIFACTS, char_id), pacc, temp);
	
	temp = 0;
	// save researches
	for(i = 0; i < RESEARCH_BITSETS; ++i) {
		SetDBEntry(StrParam(s:GetCharField(DND_DB_RESEARCH_DISCOVERED, char_id), d:i + 1), pacc, CheckActorInventory(tid, StrParam(s:"Research_Discovered_", d:i + 1)));
		SetDBEntry(StrParam(s:GetCharField(DND_DB_RESEARCH_DONE, char_id), d:i + 1), pacc, CheckActorInventory(tid, StrParam(s:"Research_Done_", d:i + 1)));
	}
	
	// save research trackers
	for(i = 0; i < MAX_RESEARCH_TRACKERS; ++i)
		SetDBEntry(StrParam(s:GetCharField(DND_DB_RESEARCHTRACKER, char_id), d:i + 1), pacc, CheckActorInventory(tid, ResearchTrackers[i]));
	
	// save budget
	temp = CheckActorInventory(tid, "Budget");
	SetDBEntry(GetCharField(DND_DB_BUDGET, char_id), pacc, temp);
	
	// save quests
	temp = CheckActorInventory(tid, "DnD_QuestState1");
	SetDBEntry(GetCharField(DND_DB_QUESTSTATE1, char_id), pacc, temp);
	temp = CheckActorInventory(tid, "DnD_QuestState2");
	SetDBEntry(GetCharField(DND_DB_QUESTSTATE2, char_id), pacc, temp);
	
	// save player's lifetime
	temp = CheckActorInventory(tid, "RoundsSurvived");
	SetDBEntry(GetCharField(DND_DB_SURVIVECOUNT, char_id), pacc, temp);
	
	// save weapon checkers
	temp = 0;
	for(i = 0; i < MAX_WEPCONDITION_CHECKERS; ++i)
		if(CheckActorInventory(tid, WeaponConditionCheckers[i]))
			temp |= 1 << i;
	SetDBEntry(GetCharField(DND_DB_PLAYERWEPCHECKERS, char_id), pacc, temp);
	
	// save player's weapon mods
	temp = 0;
	for(i = 0; i < MAXWEPS; ++i) {
		// check mods
		// enhancement orbs used
		temp = Player_Weapon_Infos[pnum][i].enchants;
		SetDBEntry(StrParam(s:GetCharField(DND_DB_WEAPONQUALITY, char_id), d:i), pacc, temp & 0xFF);
		// orb bonus
		SetDBEntry(StrParam(s:GetCharField(DND_DB_ORBWEAPONQUALITY, char_id), d:i), pacc, GetDataFromOrbBonus(pnum, OBI_WEAPON_ENCHANT, i));
		for(j = 0; j < MAX_WEP_BONUSES; ++j) {
			temp = Player_Weapon_Infos[pnum][i].wep_bonuses[j].amt;
			SetDBEntry(StrParam(s:GetCharField(DND_DB_WEAPONBONUS, char_id), d:j, s:"_Weapon", d:i), pacc, temp);
			// orb bonus
			SetDBEntry(StrParam(s:GetCharField(DND_DB_ORBWEAPONBONUS, char_id), d:j, s:"_Weapon", d:i), pacc, GetDataFromOrbBonus(pnum, OBI_WEAPON_CRIT + j, i));
		}
		// rest of the mods
		
	}
	
	// save stored medkit
	SetDBEntry(GetCharField(DND_DB_STOREDKIT, char_id), pacc, CheckActorInventory(tid, "StoredMedkit"));
	
	// bonuses from orbs
	SetDBEntry(GetCharField(DND_DB_ORBFLATHPBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_HPFLAT, -1));
	SetDBEntry(GetCharField(DND_DB_ORBFLATARMBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_ARMORFLAT, -1));
	SetDBEntry(GetCharField(DND_DB_ORBPERCENTHPBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_HPPERCENT, -1));
	SetDBEntry(GetCharField(DND_DB_ORBPERCENTARMBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_ARMORPERCENT, -1));
	SetDBEntry(GetCharField(DND_DB_ORBGREEDBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_GREEDPERCENT, -1));
	SetDBEntry(GetCharField(DND_DB_ORBWISDOMBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_WISDOMPERCENT, -1));
	SetDBEntry(GetCharField(DND_DB_ORBSPEEDBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_SPEED, -1));
	SetDBEntry(GetCharField(DND_DB_ORBDROPCHANCEBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_DROPCHANCE, -1));
	SetDBEntry(GetCharField(DND_DB_ORBHOLDINGBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_HOLDING, -1));
	
	// bonuses from elixirs
	SetDBEntry(GetCharField(DND_DB_ELIXIRFLATHPBONUS, char_id), pacc, Player_Elixir_Bonuses[pnum].hp_flat_bonus);
	SetDBEntry(GetCharField(DND_DB_ELIXIRFLATARMORBONUS, char_id), pacc, Player_Elixir_Bonuses[pnum].armor_flat_bonus);
	SetDBEntry(GetCharField(DND_DB_ELIXIRPERCENTHPBONUS, char_id), pacc, Player_Elixir_Bonuses[pnum].hp_percent_bonus);
	SetDBEntry(GetCharField(DND_DB_ELIXIRPERCENTARMORBONUS, char_id), pacc, Player_Elixir_Bonuses[pnum].armor_percent_bonus);
	SetDBEntry(GetCharField(DND_DB_ELIXIRSPEEDBONUS, char_id), pacc, Player_Elixir_Bonuses[pnum].speed_bonus);
	SetDBEntry(GetCharField(DND_DB_ELIXIRLUCKBONUS, char_id), pacc, Player_Elixir_Bonuses[pnum].luck);
	
	// damage type bonuses
	for(i = 0; i < MAX_TALENTS; ++i) {
		SetDBEntry(StrParam(s:GetCharField(DND_DB_ORBDAMAGETYPEBONUS, char_id), d:i), pacc, GetDataFromOrbBonus(pnum, OBI_DAMAGETYPE, i));
		SetDBEntry(StrParam(s:GetCharField(DND_DB_ELIXIRDAMAGETYPEBONUS, char_id), d:i), pacc, Player_Elixir_Bonuses[pnum].damage_type_bonus[i]);
	}
	
	SavePlayerInventoryStuff(pnum, char_id, tid, pacc, DND_PINVFLAGS_ALL);
}

void SavePlayerOrbData(int pnum, int char_id) {
	int i, j;
	char_id = Clamp_Between(char_id, 0, DND_MAX_CHARS - 1);
	int temp, tid = pnum + P_TIDSTART; //DnD_CharacterID defaults to 1 if no cmds are used.
	str pacc = GetPlayerAccountName(pnum);
	
	// save stats of player (can fit 4 stats in one int, using 7 bits)
	temp = CheckActorInventory(tid, "PSTAT_Strength");
	temp |= (0xFF & CheckActorInventory(tid, "PSTAT_Dexterity")) << 8;
	temp |= (0xFF & CheckActorInventory(tid, "PSTAT_Bulkiness")) << 16;
	temp |= (0xFF & CheckActorInventory(tid, "PSTAT_Charisma")) << 24;
	// send temp over
	SetDBEntry(GetCharField(DND_DB_STATS_1, char_id), pacc, temp);
	
	// save vitality, backpack count and active accessory
	temp = CheckActorInventory(tid, "PSTAT_Vitality");
	// backpack covers 6 bits max (count = 55 < 63)
	temp |= CheckActorInventory(tid, "BackpackCounter") << 8; // for backpack
	// send temp over
	SetDBEntry(GetCharField(DND_DB_STATS_2, char_id), pacc, temp);
	
	// save intellect
	temp = CheckActorInventory(tid, "PSTAT_Intellect");
	temp <<= 16;
	temp |= CheckActorInventory(tid, "TalentPoint");
	SetDBEntry(GetCharField(DND_DB_STATS_3, char_id), pacc, temp);
	
	// save perks (use 4 bits per perk, max is 10 for a perk)
	temp = CheckActorInventory(tid, "Perk_Sharpshooting");
	temp |= (0xF & CheckActorInventory(tid, "Perk_Endurance")) << 4;
	temp |= (0xF & CheckActorInventory(tid, "Perk_Wisdom")) << 8;
	temp |= (0xF & CheckActorInventory(tid, "Perk_Greed")) << 12;
	temp |= (0xF & CheckActorInventory(tid, "Perk_Medic")) << 16;
	temp |= (0xF & CheckActorInventory(tid, "Perk_Munitionist")) << 20;
	temp |= (0xF & CheckActorInventory(tid, "Perk_Deadliness")) << 24;
	temp |= (0xF & CheckActorInventory(tid, "Perk_Savagery")) << 28;
	// send temp over
	SetDBEntry(GetCharField(DND_DB_PERKS, char_id), pacc, temp);
	
	// save perks - 2
	temp = CheckActorInventory(tid, "Perk_Luck");
	SetDBEntry(GetCharField(DND_DB_PERKS2, char_id), pacc, temp);
	
	// save health and armor
	temp = GetActorProperty(tid, APROP_HEALTH);
	temp <<= 16;
	temp |= CheckActorInventory(tid, "Armor");
	SetDBEntry(GetCharField(DND_DB_HEALTHARMOR, char_id), pacc, temp);
	
	// save armor type
	temp = 0;
	for(i = 0; i < MAXARMORS; ++i) {
		if(i >= 1 && i <= 4) { // green to red armor have variations that don't spawn
			if(GetArmorType(ArmorTypes[i], pnum) || GetArmorType(StrParam(s:ArmorTypes[i], d:2), pnum)) {
				temp = SetBit(temp, i);
				break;
			}
		}
		else {
			if(GetArmorType(ArmorTypes[i], pnum)) {
				temp = SetBit(temp, i);
				break;
			}
		}
	}
	// send temp over
	SetDBEntry(GetCharField(DND_DB_ARMORTYPE, char_id), pacc, temp);
	
	// save ammo counts
	for(i = 0; i < MAX_SLOTS; ++i)
		for(j = 0; j < MAX_AMMOTYPES_PER_SLOT && AmmoInfo[i][j].initial_capacity != -1; ++j) {
			temp = CheckActorInventory(tid, AmmoInfo_Str[i][j][AMMOINFO_NAME]);
			// send temp over
			SetDBEntry(StrParam(s:GetCharField(DND_DB_AMMO, char_id), s:AmmoInfo_Str[i][j][AMMOINFO_NAME]), pacc, temp);
		}
	
	for(i = 0; i < MAX_SPECIAL_AMMOS; ++i) {
		temp = CheckActorInventory(tid, SpecialAmmoInfo_Str[i][AMMOINFO_NAME]);
		// send temp over
		SetDBEntry(StrParam(s:GetCharField(DND_DB_SPECIALAMMO, char_id), s:SpecialAmmoInfo_Str[i][AMMOINFO_NAME]), pacc, temp);
		
	}
	
	// save weapon clips/magazines that use them
	for(i = 0; i < MAXCLIPAMMOTYPES; ++i) {
		temp = CheckActorInventory(tid, ClipAmmoTypes[i]);
		// send temp over
		SetDBEntry(StrParam(s:GetCharField(DND_DB_AMMO, char_id), s:ClipAmmoTypes[i]), pacc, temp);
	}
	
	// bonuses from orbs
	SetDBEntry(GetCharField(DND_DB_ORBFLATHPBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_HPFLAT, -1));
	SetDBEntry(GetCharField(DND_DB_ORBFLATARMBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_ARMORFLAT, -1));
	SetDBEntry(GetCharField(DND_DB_ORBPERCENTHPBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_HPPERCENT, -1));
	SetDBEntry(GetCharField(DND_DB_ORBPERCENTARMBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_ARMORPERCENT, -1));
	SetDBEntry(GetCharField(DND_DB_ORBGREEDBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_GREEDPERCENT, -1));
	SetDBEntry(GetCharField(DND_DB_ORBWISDOMBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_WISDOMPERCENT, -1));
	SetDBEntry(GetCharField(DND_DB_ORBSPEEDBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_SPEED, -1));
	SetDBEntry(GetCharField(DND_DB_ORBDROPCHANCEBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_DROPCHANCE, -1));
	SetDBEntry(GetCharField(DND_DB_ORBHOLDINGBONUS, char_id), pacc, GetDataFromOrbBonus(pnum, OBI_HOLDING, -1));
	
	// damage type bonuses
	for(i = 0; i < MAX_TALENTS; ++i)
		SetDBEntry(StrParam(s:GetCharField(DND_DB_ORBDAMAGETYPEBONUS, char_id), d:i), pacc, GetDataFromOrbBonus(pnum, OBI_DAMAGETYPE, i));
	
	for(i = 0; i < MAXWEPS; ++i) {
		// check mods
		// enhancement orbs used
		// orb bonus
		SetDBEntry(StrParam(s:GetCharField(DND_DB_ORBWEAPONQUALITY, char_id), d:i), pacc, GetDataFromOrbBonus(pnum, OBI_WEAPON_ENCHANT, i));
		for(j = 0; j < MAX_WEP_BONUSES; ++j)
			SetDBEntry(StrParam(s:GetCharField(DND_DB_ORBWEAPONBONUS, char_id), d:j, s:"_Weapon", d:i), pacc, GetDataFromOrbBonus(pnum, OBI_WEAPON_CRIT + j, i));
		// rest of the mods
		
	}
	
	temp = CheckActorInventory(tid, "Credit");
	//send temp over
	SetDBEntry(GetCharField(DND_DB_CREDIT, char_id), pacc, temp);
	
	temp = CheckActorInventory(tid, "Level");
	if(!temp)
		temp = 1; // fix level 0 saves
	// send temp over
	SetDBEntry(GetCharField(DND_DB_LEVEL, char_id), pacc, temp);
	
	// save budget
	temp = CheckActorInventory(tid, "Budget");
	SetDBEntry(GetCharField(DND_DB_BUDGET, char_id), pacc, temp);
	
	// save unspent attribute/perk points
	temp = CheckActorInventory(tid, "AttributePoint");
	temp |= (0x7FF & CheckActorInventory(tid, "PerkPoint")) << 11;
	// send temp over
	SetDBEntry(GetCharField(DND_DB_ATTRIBUTEPERK, char_id), pacc, temp);
	
	// save player inventory state (might have been affected by an orb)
	SavePlayerInventoryStuff(pnum, char_id, tid, pacc, DND_PINVFLAGS_ALL);
}

void LoadPlayerStash(int pnum, str pacc) {
	int temp, w, h, i, j;
	ResetPlayerStash(pnum);
	// load stash
	SetInventory("DnD_PlayerInventoryPages", GetDBEntry(DND_DB_STASH_PAGES, pacc));
	// keep base amount at 1
	if(!CheckInventory("DnD_PlayerInventoryPages"))
		GiveInventory("DnD_PlayerInventoryPages", 1);
	for(i = 0; i < CheckInventory("DnD_PlayerInventoryPages"); ++i) {
		for(j = 0; j < MAX_INVENTORY_BOXES; ++j) {
			temp = GetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_TYPE), pacc);
			if(temp != DND_ITEM_NULL) {
				PlayerStashList[pnum][i][j].width = GetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_WIDTH), pacc);
				PlayerStashList[pnum][i][j].height = GetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_HEIGHT), pacc);
				PlayerStashList[pnum][i][j].item_image = GetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_IMAGE), pacc);
				PlayerStashList[pnum][i][j].item_type = temp;
				PlayerStashList[pnum][i][j].item_subtype = GetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_SUBTYPE), pacc);
				PlayerStashList[pnum][i][j].item_level = GetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_LEVEL), pacc);
				PlayerStashList[pnum][i][j].item_stack = GetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_STACK), pacc);
				PlayerStashList[pnum][i][j].attrib_count = GetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBCOUNT), pacc);
				for(temp = 0; temp < PlayerStashList[pnum][i][j].attrib_count; ++temp) {
					PlayerStashList[pnum][i][j].attributes[temp].attrib_val = GetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBVAL, s:"_", d:temp), pacc);
					PlayerStashList[pnum][i][j].attributes[temp].attrib_id = GetDBEntry(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_STASHPAGE, d:i, s:"_", d:j, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBID, s:"_", d:temp), pacc);
				}
				
				// init pointers
				for(w = 0; w < PlayerStashList[pnum][i][j].width; ++w)
					for(h = 0; h < PlayerStashList[pnum][i][j].height; ++h) {
						temp = j + w + h * MAXINVENTORYBLOCKS_VERT;
						PlayerStashList[pnum][i][temp].item_type = PlayerStashList[pnum][i][j].item_type;
						PlayerStashList[pnum][i][temp].topleftboxid = j + 1;
					}
			}
		}
	}
	// sync all of stash
	SyncAllItemData(DND_SYNC_ITEMSOURCE_STASH);
	
	// we must do this here after loading
	SyncAllClientsideVariables();
}

// Loads from database and gives necessary items
void LoadPlayerData(int pnum, int char_id) {
	// assumes all checks have been performed before reaching this function
	int i = 0, j = 0, h, w, temp;
	str pacc = GetPlayerAccountName(pnum);
	
	// reset weapons
	ResetPlayer();
	
	// reset currently acquired inventory
	for(i = 0; i < MAX_INVENTORY_BOXES; ++i) {
		PlayerInventoryList[pnum][i].topleftboxid = 0;
		PlayerInventoryList[pnum][i].item_type = DND_ITEM_NULL;
	}
	
	ResetPlayerInventory(pnum);
	// load player inventory
	for(i = 0; i < MAX_INVENTORY_BOXES; ++i) {
		temp = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_TYPE), char_id), pacc);
		// we got the main item pointer here
		if(temp != DND_ITEM_NULL) {
			PlayerInventoryList[pnum][i].width = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_WIDTH), char_id), pacc);
			PlayerInventoryList[pnum][i].height = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_HEIGHT), char_id), pacc);
			PlayerInventoryList[pnum][i].item_image = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_IMAGE), char_id), pacc);
			PlayerInventoryList[pnum][i].item_type = temp;
			PlayerInventoryList[pnum][i].item_subtype = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_SUBTYPE), char_id), pacc);
			PlayerInventoryList[pnum][i].item_level = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_LEVEL), char_id), pacc);
			PlayerInventoryList[pnum][i].item_stack = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_STACK), char_id), pacc);
			PlayerInventoryList[pnum][i].attrib_count = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBCOUNT), char_id), pacc);
			for(j = 0; j < PlayerInventoryList[pnum][i].attrib_count; ++j) {
				PlayerInventoryList[pnum][i].attributes[j].attrib_val = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBVAL, s:"_", d:j), char_id), pacc);
				PlayerInventoryList[pnum][i].attributes[j].attrib_id = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBID, s:"_", d:j), char_id), pacc);
			}
			
			// init pointers
			for(w = 0; w < PlayerInventoryList[pnum][i].width; ++w)
				for(h = 0; h < PlayerInventoryList[pnum][i].height; ++h) {
					temp = i + w + h * MAXINVENTORYBLOCKS_VERT;
					PlayerInventoryList[pnum][temp].item_type = PlayerInventoryList[pnum][i].item_type;
					PlayerInventoryList[pnum][temp].topleftboxid = i + 1;
				}
		}
	}
	// sync all of inventory
	SyncAllItemData(DND_SYNC_ITEMSOURCE_PLAYERINVENTORY);
	
	// remove whatever feature this player had on them prior to loading (just in case)
	for(i = 0; i < MAX_CHARMS_EQUIPPABLE; ++i)
		if(Charms_Used[pnum][i].item_type != DND_ITEM_NULL)
			RemoveItemFeatures(i, DND_SYNC_ITEMSOURCE_CHARMUSED);
	ResetPlayerCharmsUsed(pnum);
	// load charms used
	for(i = 0; i < MAX_CHARMS_EQUIPPABLE; ++i) {
		Charms_Used[pnum][i].topleftboxid = i + 1;
		Charms_Used[pnum][i].width = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_WIDTH), char_id), pacc);
		Charms_Used[pnum][i].height = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_HEIGHT), char_id), pacc);
		Charms_Used[pnum][i].item_image = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_IMAGE), char_id), pacc);
		Charms_Used[pnum][i].item_type = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_TYPE), char_id), pacc);
		Charms_Used[pnum][i].item_subtype = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_SUBTYPE), char_id), pacc);
		Charms_Used[pnum][i].item_level = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_LEVEL), char_id), pacc);
		Charms_Used[pnum][i].item_stack = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_STACK), char_id), pacc);
		Charms_Used[pnum][i].attrib_count = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBCOUNT), char_id), pacc);
		for(j = 0; j < Charms_Used[pnum][i].attrib_count; ++j) {
			Charms_Used[pnum][i].attributes[j].attrib_val = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBVAL, s:"_", d:j), char_id), pacc);
			Charms_Used[pnum][i].attributes[j].attrib_id = GetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBID, s:"_", d:j), char_id), pacc);
		}
		if(Charms_Used[pnum][i].item_type != DND_ITEM_NULL)
			ApplyItemFeatures(i, DND_SYNC_ITEMSOURCE_CHARMUSED);
	}
	// sync all of charms used
	SyncAllItemData(DND_SYNC_ITEMSOURCE_CHARMUSED);
	
	LoadPlayerStash(pnum, pacc);
	
	// damage type bonuses
	for(i = 0; i < MAX_TALENTS; ++i) {
		Player_Elixir_Bonuses[pnum].damage_type_bonus[i] = GetDBEntry(StrParam(s:GetCharField(DND_DB_ELIXIRDAMAGETYPEBONUS, char_id), d:i), pacc);
		SetDataToOrbBonus(pnum, OBI_DAMAGETYPE, i, GetDBEntry(StrParam(s:GetCharField(DND_DB_ORBDAMAGETYPEBONUS, char_id), d:i), pacc));
	}

	// load bonuses from orbs
	SetDataToOrbBonus(pnum, OBI_HPFLAT, -1, GetDBEntry(GetCharField(DND_DB_ORBFLATHPBONUS, char_id), pacc));
	SetDataToOrbBonus(pnum, OBI_ARMORFLAT, -1, GetDBEntry(GetCharField(DND_DB_ORBFLATARMBONUS, char_id), pacc));
	SetDataToOrbBonus(pnum, OBI_HPPERCENT, -1, GetDBEntry(GetCharField(DND_DB_ORBPERCENTHPBONUS, char_id), pacc));
	SetDataToOrbBonus(pnum, OBI_ARMORPERCENT, -1, GetDBEntry(GetCharField(DND_DB_ORBPERCENTARMBONUS, char_id), pacc));
	SetDataToOrbBonus(pnum, OBI_GREEDPERCENT, -1, GetDBEntry(GetCharField(DND_DB_ORBGREEDBONUS, char_id), pacc));
	SetDataToOrbBonus(pnum, OBI_WISDOMPERCENT, -1, GetDBEntry(GetCharField(DND_DB_ORBWISDOMBONUS, char_id), pacc));
	SetDataToOrbBonus(pnum, OBI_SPEED, -1, GetDBEntry(GetCharField(DND_DB_ORBSPEEDBONUS, char_id), pacc));
	SetDataToOrbBonus(pnum, OBI_DROPCHANCE, -1, GetDBEntry(GetCharField(DND_DB_ORBDROPCHANCEBONUS, char_id), pacc));
	SetDataToOrbBonus(pnum, OBI_HOLDING, -1, GetDBEntry(GetCharField(DND_DB_ORBHOLDINGBONUS, char_id), pacc));
	
	// load bonuses from elixirs
	Player_Elixir_Bonuses[pnum].hp_flat_bonus = GetDBEntry(GetCharField(DND_DB_ELIXIRFLATHPBONUS, char_id), pacc);
	Player_Elixir_Bonuses[pnum].armor_flat_bonus = GetDBEntry(GetCharField(DND_DB_ELIXIRFLATARMORBONUS, char_id), pacc);
	Player_Elixir_Bonuses[pnum].hp_percent_bonus = GetDBEntry(GetCharField(DND_DB_ELIXIRPERCENTHPBONUS, char_id), pacc);
	Player_Elixir_Bonuses[pnum].armor_percent_bonus = GetDBEntry(GetCharField(DND_DB_ELIXIRPERCENTARMORBONUS, char_id), pacc);
	Player_Elixir_Bonuses[pnum].speed_bonus = GetDBEntry(GetCharField(DND_DB_ELIXIRSPEEDBONUS, char_id), pacc);
	Player_Elixir_Bonuses[pnum].luck = GetDBEntry(GetCharField(DND_DB_ELIXIRLUCKBONUS, char_id), pacc);
	
	// read temp ammo -- first so weapon doesnt get removed
	for(i = 0; i < MAXTEMPAMMO; ++i)
		SetInventory(TemporaryAmmos[i], GetDBEntry(GetCharField(StrParam(s:DND_DB_TEMPAMMO, d:i), char_id), pacc));
		
	// read weapons
	temp = GetDBEntry(GetCharField(StrParam(s:DND_DB_WEAPONINT, d:1), char_id), pacc);
	for(i = 0; i < MAXWEPS; ++i) {
		j = i / 32;
		if(IsSet(temp, i - 32 * j)) {
			GiveInventory(Weapons[i][WEAPON_NAME], 1);
		}
		if(j != (i + 1) / 32 || i == MAXWEPS - 1) { // ie. our j changed
			// update bitset
			temp = GetDBEntry(GetCharField(StrParam(s:DND_DB_WEAPONINT, d:j + 2), char_id), pacc);
		}
	}
	
	// read stats
	temp = GetDBEntry(GetCharField(DND_DB_STATS_1, char_id), pacc);
	SetInventory("PSTAT_Strength", temp & 0xFF);
	temp >>= 8;
	SetInventory("PSTAT_Dexterity", temp & 0xFF);
	temp >>= 8;
	SetInventory("PSTAT_Bulkiness", temp & 0xFF);
	temp >>= 8;
	SetInventory("PSTAT_Charisma", temp & 0xFF);
	
	temp = GetDBEntry(GetCharField(DND_DB_STATS_2, char_id), pacc);
	SetInventory("PSTAT_Vitality", temp & 0xFF);
	temp >>= 8;
	SetInventory("BackpackCounter", temp & 0xFF);
	SetAllAmmoCapacities();
	
	// intellect + talent point
	temp = GetDBEntry(GetCharField(DND_DB_STATS_3, char_id), pacc);
	SetInventory("TalentPoint", temp & 0xFFFF);
	temp >>= 16;
	SetInventory("PSTAT_Intellect", temp & 0xFF);
	
	// read perks - 1
	temp = GetDBEntry(GetCharField(DND_DB_PERKS, char_id), pacc);
	SetInventory("Perk_Sharpshooting", temp & 0xF);
	temp >>= 4;
	SetInventory("Perk_Endurance", temp & 0xF);
	temp >>= 4;
	SetInventory("Perk_Wisdom", temp & 0xF);
	temp >>= 4;
	SetInventory("Perk_Greed", temp & 0xF);
	temp >>= 4;
	SetInventory("Perk_Medic", temp & 0xF);
	temp >>= 4;
	SetInventory("Perk_Munitionist", temp & 0xF);
	temp >>= 4;
	SetInventory("Perk_Deadliness", temp & 0xF);
	temp >>= 4;
	SetInventory("Perk_Savagery", temp & 0xF);
	
	// read perks - 2
	temp = GetDBEntry(GetCharField(DND_DB_PERKS2, char_id), pacc);
	SetInventory("Perk_Luck", temp & 0xF);
	
	// read health and armor
	temp = GetDBEntry(GetCharField(DND_DB_HEALTHARMOR, char_id), pacc);
	// make sure charms and shit are added here too
	int armor = temp & 0xFFFF;
	temp >>= 16;
	SetActorProperty(0, APROP_SPAWNHEALTH, GetSpawnHealth());
	SetActorProperty(0, APROP_HEALTH, (temp & 0xFFFF) ? temp & 0xFFFF : DND_BASE_HEALTH);
	
	// read armor type
	// reset whatever armor might have been on the player at the time
	SetInventory("Armor", 0);
	SetInventory("DnD_ArmorType", 0);
	temp = GetDBEntry(GetCharField(DND_DB_ARMORTYPE, char_id), pacc);
	for(i = 0; i < MAXARMORS; ++i) {
		if(IsSet(temp, i)) {
			GiveInventory(ArmorTypes[i], 1);
			GiveInventory("DnD_ArmorBonus", armor - 1);
			SetInventory("DnD_ArmorType", i + 1);
			break;
		}
	}
	
	// read accessories
	temp = GetDBEntry(GetCharField(DND_DB_ACCESSORIES, char_id), pacc);
	for(i = 0; i < MAX_ACCESSORY; ++i)
		SetInventory(StrParam(s:"Accessory_", d:i + 1), !!(temp & (1 << i)));
	// save active accessories
	SetInventory("Accessory_Index", GetDBEntry(GetCharField(DND_DB_ACTIVEACCESSORIES, char_id), pacc));
	DecideAccessories();
	
	// read each ammo count
	for(i = 0; i < MAX_SLOTS; ++i)
		for(j = 0; j < MAX_AMMOTYPES_PER_SLOT && AmmoInfo[i][j].initial_capacity != -1; ++j) {
			temp = GetDBEntry(StrParam(s:GetCharField(DND_DB_AMMO, char_id), s:AmmoInfo_Str[i][j][AMMOINFO_NAME]), pacc);
			SetInventory(AmmoInfo_Str[i][j][AMMOINFO_NAME], temp);
		}
	
	// read special ammos
	for(i = 0; i < MAX_SPECIAL_AMMOS; ++i) {
		temp = GetDBEntry(StrParam(s:GetCharField(DND_DB_SPECIALAMMO, char_id), s:SpecialAmmoInfo_Str[i][AMMOINFO_NAME]), pacc);
		SetInventory(SpecialAmmoInfo_Str[i][AMMOINFO_NAME], temp);
	}
	
	// read clip ammos
	for(i = 0; i < MAXCLIPAMMOTYPES; ++i) {
		temp = GetDBEntry(StrParam(s:GetCharField(DND_DB_AMMO, char_id), s:ClipAmmoTypes[i]), pacc);
		SetInventory(ClipAmmoTypes[i], temp);
	}
	
	// read talents
	temp = GetDBEntry(GetCharField(DND_DB_TALENT_1, char_id), pacc);
	for(i = 0; i < 4; ++i) {
		SetInventory(TalentNames[i][TALENT_TAG], temp & 0xFF);
		temp >>= 8;
	}
	
	temp = GetDBEntry(GetCharField(DND_DB_TALENT_2, char_id), pacc);
	for(i = 4; i < MAX_TALENTS; ++i) {
		SetInventory(TalentNames[i][TALENT_TAG], temp & 0xFF);
		temp >>= 8;
	}
	
	// set here the lowest possible talents (for quest)
	SetInventory("DnD_NonLowestTalents", GetNonLowestTalents()); //All higher talents should have bit set here.
	
	// read level
	temp = GetDBEntry(GetCharField(DND_DB_LEVEL, char_id), pacc);
	if(!temp)
		temp = 1;
	SetInventory("Level", temp);
	
	// read exp
	temp = GetDBEntry(GetCharField(DND_DB_EXP, char_id), pacc);
	SetAmmoCapacity("ExpVisual", GetExpLimit());
	SetInventory("ExpVisual", temp);
	SetInventory("Exp", temp);
	
	// read credits
	SetInventory("Credit", GetDBEntry(GetCharField(DND_DB_CREDIT, char_id), pacc));
	
	// read abilities
	temp = GetDBEntry(GetCharField(DND_DB_ABILITY, char_id), pacc);
	for(i = 0; i < MAXABILITIES; ++i) {
		if(IsSet(temp, i))
			GiveInventory(AbilityInfo[i], 1);
	}
	
	// read unspent attribute/perk points
	temp = GetDBEntry(GetCharField(DND_DB_ATTRIBUTEPERK, char_id), pacc);
	SetInventory("AttributePoint", temp & 0x7FF);
	temp >>= 11;
	SetInventory("PerkPoint", temp & 0x7FF);
	
	temp = GetDBEntry(GetCharField(DND_DB_ARTIFACTS, char_id), pacc);
	// read artifacts
	SetInventory("SalvationSphere", temp & 1);
	for(i = 3; i < MAXARTIFACTS - 3; ++i)
		// because 0th bit is for salvation sphere
		SetInventory(ArtifactInfo[i][ARTI_NAME], !!(temp & (1 << (i - 2)))); // these have only 1 carry limit
	// at this point MAXARTIFACTS - 3 bits are occupied
	temp >>= (MAXARTIFACTS - 5);
	SetInventory("FieldKit", temp & 0x3);
	temp >>= 2;
	SetInventory("PortableShield", temp & 0x3);
	temp >>= 2;
	SetInventory("StatReset", temp & 1);

	// read researches
	for(i = 0; i < RESEARCH_BITSETS; ++i) {
		int k;
		int res_on_cur_bitset = 31; //Each bitset fits 31-bits (Actor inventory can only use 31-bits).
		if (i == RESEARCH_BITSETS-1) {
			res_on_cur_bitset = MAX_RESEARCHES%31;
			if (res_on_cur_bitset == 0)
				res_on_cur_bitset = 31; //Make sure having exactly 31/62/93... researches don't break this.
		}
		
		temp = GetDBEntry(StrParam(s:GetCharField(DND_DB_RESEARCH_DONE, char_id), d: i + 1), pacc);
		k = 0;
		for(j = 0; j < res_on_cur_bitset; ++j)
			if(IsSet(temp, j))
				k = SetBit(k, j);
		SetInventory(StrParam(s:"Research_Done_", d:i + 1), k);
		
		temp = GetDBEntry(StrParam(s:GetCharField(DND_DB_RESEARCH_DISCOVERED, char_id), d: i + 1), pacc);
		k = 0;
		for(j = 0; j < res_on_cur_bitset; ++j)
			if(IsSet(temp, j))
				k = SetBit(k, j);
		SetInventory(StrParam(s:"Research_Discovered_", d:i + 1), k);
	}
	
	HandleResearchBonuses();
	
	// read research trackers
	for(i = 0; i < MAX_RESEARCH_TRACKERS; ++i)
		SetInventory(ResearchTrackers[i], GetDBEntry(StrParam(s:GetCharField(DND_DB_RESEARCHTRACKER, char_id), d:i + 1), pacc));
	
	// read budget
	temp = GetDBEntry(GetCharField(DND_DB_BUDGET, char_id), pacc);
	SetInventory("Budget", temp);
	
	// load quest states and give rewards accordingly
	// for now only load state 1 because quest amount < 32
	temp = GetDBEntry(GetCharField(DND_DB_QUESTSTATE1, char_id), pacc);
	SetInventory("DnD_QuestState1", temp);
	for(i = 0; i < MAX_QUESTS; ++i)
		if(IsSet(temp, i))
			GiveInventory(Quest_List[i].qreward, 1);
		
	if(!CheckInventory("HardcoreDebuff"))
		GiveInventory("HardcoreDebuff", 1);
	
	// load weapon checkers
	temp = GetDBEntry(GetCharField(DND_DB_PLAYERWEPCHECKERS, char_id), pacc);
	for(i = 0; i < MAX_WEPCONDITION_CHECKERS; ++i)
		if(IsSet(temp, i))
			GiveInventory(WeaponConditionCheckers[i], 1);
	
	
	// load player's weapon mods
	for(i = 0; i < MAXWEPS; ++i) {
		// check mods
		// enhancement orbs used
		temp = GetDBEntry(StrParam(s:GetCharField(DND_DB_WEAPONQUALITY, char_id), d:i), pacc);
		Player_Weapon_Infos[pnum][i].enchants = temp & 0xFF;
		SetDataToOrbBonus(pnum, OBI_WEAPON_ENCHANT, i, GetDBEntry(StrParam(s:GetCharField(DND_DB_ORBWEAPONQUALITY, char_id), d:i), pacc));
		for(j = 0; j < MAX_WEP_BONUSES; ++j) {
			Player_Weapon_Infos[pnum][i].wep_bonuses[j].amt = GetDBEntry(StrParam(s:GetCharField(DND_DB_WEAPONBONUS, char_id), d:j, s:"_Weapon", d:i), pacc);
			SetDataToOrbBonus(pnum, OBI_WEAPON_CRIT + j, i, GetDBEntry(StrParam(s:GetCharField(DND_DB_ORBWEAPONBONUS, char_id), d:j, s:"_Weapon", d:i), pacc));
		}
		// rest of the mods
		// to do: figure out loading these efficiently later
	}
	
	// load stored medkit
	temp = GetDBEntry(GetCharField(DND_DB_STOREDKIT, char_id), pacc);
	SetAmmoCapacity("StoredMedkit", GetAmmoCapacity("StoredMedkit") + 15 * CheckInventory("Perk_Medic"));
	SetInventory("StoredMedkit", temp);
	
	// Restoration steps
	RestoreRPGStat(RES_PLAYERSPEED);
	UpdatePlayerKnockbackResist();
	
	// Research stuff
	RestoreResearchItems();
}

// on Hardcore death, wipeout all data related to this player
void WipeoutPlayerData(int pnum, int cid) {
	int i, j, char_id = Clamp_Between(cid, 0, DND_MAX_CHARS - 1);
	str pacc = GetPlayerAccountName(pnum);
	for(i = 1; i <= (MAXWEPS / 32) + 1; ++i)
		SetDBEntry(GetCharField(StrParam(s:DND_DB_WEAPONINT, d:i), char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_TEMPAMMO, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_STATS_1, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_STATS_2, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_STATS_3, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_PERKS, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_HEALTHARMOR, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_ARMORTYPE, char_id), pacc, 0);
	
	// reset ammo counts
	for(i = 0; i < MAX_SLOTS; ++i)
		for(j = 0; j < MAX_AMMOTYPES_PER_SLOT && AmmoInfo[i][j].initial_capacity != -1; ++j) {
			SetDBEntry(StrParam(s:GetCharField(DND_DB_AMMO, char_id), s:AmmoInfo_Str[i][j][AMMOINFO_NAME]), pacc, 0);
		}
	
	for(i = 0; i < MAX_SPECIAL_AMMOS; ++i)
		SetDBEntry(StrParam(s:GetCharField(DND_DB_SPECIALAMMO, char_id), s:SpecialAmmoInfo_Str[i][AMMOINFO_NAME]), pacc, 0);
	
	// reset weapon clips/magazines that use them
	for(i = 0; i < MAXCLIPAMMOTYPES; ++i) {
		str amm = StrParam(s:GetCharField(DND_DB_AMMO, char_id), s:ClipAmmoTypes[i]);
		SetDBEntry(amm, pacc, GetAmmoCapacity(amm));
	}
	
	SetDBEntry(GetCharField(DND_DB_TALENT_1, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_TALENT_2, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_EXP, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_CREDIT, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_LEVEL, char_id), pacc, 1);
	SetDBEntry(GetCharField(DND_DB_ABILITY, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_ATTRIBUTEPERK, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_ACCESSORIES, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_ARTIFACTS, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_BUDGET, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_QUESTSTATE1, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_QUESTSTATE2, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_SURVIVECOUNT, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_PLAYERWEPCHECKERS, char_id), pacc, 0);
	
	for(i = 0; i < RESEARCH_BITSETS; ++i) {
		SetDBEntry(StrParam(s:GetCharField(DND_DB_RESEARCH_DONE, char_id), d:i + 1), pacc, 0);
		SetDBEntry(StrParam(s:GetCharField(DND_DB_RESEARCH_DISCOVERED, char_id), d:i + 1), pacc, 0);
	}
	
	// orbs
	SetDBEntry(GetCharField(DND_DB_ORBFLATHPBONUS, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_ORBFLATARMBONUS, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_ORBPERCENTHPBONUS, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_ORBPERCENTARMBONUS, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_ORBGREEDBONUS, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_ORBWISDOMBONUS, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_ORBSPEEDBONUS, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_ORBDROPCHANCEBONUS, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_ORBHOLDINGBONUS, char_id), pacc, 0);
	
	// elixirs
	SetDBEntry(GetCharField(DND_DB_ELIXIRFLATHPBONUS, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_ELIXIRFLATARMORBONUS, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_ELIXIRPERCENTHPBONUS, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_ELIXIRPERCENTARMORBONUS, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_ELIXIRSPEEDBONUS, char_id), pacc, 0);
	SetDBEntry(GetCharField(DND_DB_ELIXIRLUCKBONUS, char_id), pacc, 0);
	
	for(i = 0; i < MAX_RESEARCH_TRACKERS; ++i)
		SetDBEntry(StrParam(s:GetCharField(DND_DB_RESEARCHTRACKER, char_id), d:i + 1), pacc, 0);

	for(i = 0; i < MAXWEPS; ++i) {
		// enhancement orbs used
		SetDBEntry(StrParam(s:GetCharField(DND_DB_WEAPONQUALITY, char_id), d:i), pacc, 0);
		SetDBEntry(StrParam(s:GetCharField(DND_DB_ORBWEAPONQUALITY, char_id), d:i), pacc, 0);
		for(j = 0; j < MAX_WEP_BONUSES; ++j) {
			SetDBEntry(StrParam(s:GetCharField(DND_DB_WEAPONBONUS, char_id), d:j, s:"_Weapon", d:i), pacc, 0);
			SetDBEntry(StrParam(s:GetCharField(DND_DB_ORBWEAPONBONUS, char_id), d:j, s:"_Weapon", d:i), pacc, 0);
		}
		// rest of the mods
	}
	
	// damage type bonuses
	for(i = 0; i < MAX_TALENTS; ++i) {
		SetDBEntry(StrParam(s:GetCharField(DND_DB_ELIXIRDAMAGETYPEBONUS, char_id), d:i), pacc, 0);
		SetDBEntry(StrParam(s:GetCharField(DND_DB_ORBDAMAGETYPEBONUS, char_id), d:i), pacc, 0);
	}
	
	// clean up inventory stuff
	for(i = 0; i < MAX_INVENTORY_BOXES; ++i) {
		SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_WIDTH), char_id), pacc, 0);
		SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_HEIGHT), char_id), pacc, 0);
		SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_IMAGE), char_id), pacc, 0);
		SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_TYPE), char_id), pacc, 0);
		SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_SUBTYPE), char_id), pacc, 0);
		SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_LEVEL), char_id), pacc, 0);
		SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_STACK), char_id), pacc, 0);
		SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBCOUNT), char_id), pacc, 0);
		for(j = 0; j < PlayerInventoryList[pnum][i].attrib_count; ++j) {
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBVAL, s:"_", d:j), char_id), pacc, 0);
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBID, s:"_", d:j), char_id), pacc, 0);
		}
	}
	SyncAllItemData(DND_SYNC_ITEMSOURCE_PLAYERINVENTORY);
	// reset charms used
	for(i = 0; i < MAX_CHARMS_EQUIPPABLE; ++i) {
		SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_WIDTH), char_id), pacc, 0);
		SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_HEIGHT), char_id), pacc, 0);
		SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_IMAGE), char_id), pacc, 0);
		SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_TYPE), char_id), pacc, 0);
		SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_SUBTYPE), char_id), pacc, 0);
		SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_LEVEL), char_id), pacc, 0);
		SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_STACK), char_id), pacc, 0);
		SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBCOUNT), char_id), pacc, 0);
		for(j = 0; j < Charms_Used[pnum][i].attrib_count; ++j) {
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBVAL, s:"_", d:j), char_id), pacc, 0);
			SetDBEntry(GetCharField(StrParam(s:DND_DB_PLAYERINVENTORY, s:DND_DB_CHARMUSED, d:i, s:DND_DB_PLAYERINVENTORYFIELD_ATTRIBID, s:"_", d:j), char_id), pacc, 0);
		}
	}
	SyncAllItemData(DND_SYNC_ITEMSOURCE_CHARMUSED);
	// we don't reset the stash, we're merciful xD
}

// Handle all database stuff now
Script "DND Player Save" OPEN {
	while(1) {
		//Log(d:HardcoreSet, d:MapChanged);
		if(HardcoreSet && MapInfo[DND_MAPINFO_MAPCHANGED]) {
			BeginDBTransaction();
			for(int i = 0; i < MAXPLAYERS; ++i) {
				// don't save peoples stuff while they are in load period
				//Log(d:i,s:": ",d:PlayerInGame(i), d:CheckActorInventory(i + P_TIDSTART, "CanLoad"), d:PlayerWillBeSaved[i]);
				if(PlayerInGame(i) && !CheckActorInventory(i + P_TIDSTART, "CanLoad") && PlayerWillBeSaved[i]) {
					if (PlayerIsLoggedIn(i)) {
						// self note: if people still lose chars in softcore in any slot when they die and map ends, this wasn't the cause
						if((GetCVar("dnd_mode") >= DND_MODE_SOFTCORE) && PlayerDied[i])
							continue; // don't save this player as they died
						if(PlayerTransferred[i]) {
							WipeoutPlayerData(i, CheckActorInventory(i + P_TIDSTART, "DnD_CharacterID"));
							SetActorInventory(i + P_TIDSTART, "DnD_CharacterID", CheckActorInventory(i + P_TIDSTART, "DnD_TransfCharacterID"));
							PlayerTransferred[i] = false;
						}
						SavePlayerData(i, CheckActorInventory(i + P_TIDSTART, "DnD_CharacterID"));
						PlayerLoaded[i] = 1; //Also make sure the auto-save gets considered as loading a char - which will prevent unecessary loading periods.
						Log(s:"Saving player ", d:i, s:"'s data.");
					}
					PlayerWillBeSaved[i] = false; //This will prevent players that joined and logged in in intermission get the auto-saved character erased.
				}
			}
			EndDBTransaction();
			
			Terminate; //No need to repeat this script for whole map if players have been saved already - even more with db transactions
		}
		Delay(70);
	}
}

void load_char(int pnum, int char_id) {
	SetInventory("DnD_CharacterID", char_id);
	PlayerLoaded[pnum] = 1;
	SetInventory("CanLoad", 0);
	LoadPlayerData(pnum, char_id);
}

int check_load_char(int pnum, int char_id) {
	// if not hardcore don't bother trying to load
	if(!(GetCVar("dnd_mode") >= DND_MODE_SOFTCORE) || !HardcoreSet) return DND_LOGIN_NOTHARDCORE;
	if(!PlayerIsLoggedIn(pnum)) return DND_LOGIN_NOTLOGGED;
	if(!PlayerInGame(pnum)) return DND_LOGIN_NOTINGAME;
	// if gamestate is countdown don't let them because it'll be reset anyways
	if(GetGameModeState() == GAMESTATE_COUNTDOWN) return DND_LOGIN_INCOUNTDOWN;
	if(char_id < 0 || char_id > DND_MAX_CHARS - 1) return DND_LOGIN_CHARNOTINRANGE;
	// handle no data case -- only let people to load their stuff if there really is some data
	if(!GetDBEntry(GetCharField(DND_DB_HEALTHARMOR, char_id), GetPlayerAccountName(pnum))) return DND_LOGIN_NOCHAR;
	// prevent people from loading their stuff to escape death, prevent loading if a save on this player happened already!
	if(PlayerLoaded[pnum]) return DND_LOGIN_CHARINUSE;
	if(!CheckInventory("CanLoad")) return DND_LOGIN_NOTIME;
	return DND_CHARLOADED;
}

Script "DnD Load Character Check" (int pnum, int char_id) {
	SetResultValue(check_load_char(pnum, char_id));	
}

Script 1001 (int char_id) NET {
	int pnum = PlayerNumber();
	int result = check_load_char(pnum, char_id);
	if (result == DND_CHARLOADED) load_char(pnum, char_id);
	ACS_NamedExecuteAlways("DnD Login Message", 0, pnum, result, char_id);
}

void create_char(int pnum, int char_id) {
	SetInventory("DnD_CharacterID", char_id);
	PlayerLoaded[pnum] = 1;
	SetInventory("CanLoad", 0); //Let create char end loading timer
}

int check_create_char(int pnum, int char_id) {
	if(!(GetCVar("dnd_mode") >= DND_MODE_SOFTCORE) || !HardcoreSet) return DND_LOGIN_NOTHARDCORE;
	if (!PlayerIsLoggedIn(pnum)) return DND_LOGIN_NOTLOGGED;
	if(!PlayerInGame(pnum)) return DND_LOGIN_NOTINGAME;
	if(GetGameModeState() == GAMESTATE_COUNTDOWN) return DND_LOGIN_INCOUNTDOWN;
	if(char_id < 0 || char_id > DND_MAX_CHARS-1) return DND_LOGIN_CHARNOTINRANGE;
	if(PlayerLoaded[pnum]) return DND_LOGIN_CHARINUSE;
	if(!CheckInventory("CanLoad")) return DND_LOGIN_NOTIME; //For now, allow player to setchar until end of map manually. -- Uncommented to see if it prevents stashes being destroyed.
	return DND_LOGIN_CREATECHAROK;
}

Script "DnD Create Character Check" (int pnum, int char_id) {
	SetResultValue(check_create_char(pnum, char_id));	
}

Script 1003 (int char_id) NET {
	int pnum = PlayerNumber();
	int result = check_create_char(pnum, char_id);
	if (result == DND_LOGIN_CREATECHAROK) create_char(pnum, char_id);
	// load player stash
	LoadPlayerStash(pnum, GetPlayerAccountName(pnum));
	ACS_NamedExecuteAlways("DnD Login Message", 0, pnum, result, char_id);
}

void transfer_char(int pnum, int char_id) {
	if(char_id == CheckInventory("DnD_CharacterID"))
		PlayerTransferred[pnum] = false;
	else {
		PlayerTransferred[pnum] = true;
		SetInventory("DnD_TransfCharacterID", char_id);
	}
}

int check_transfer_char(int pnum, int char_id) {
	if(!(GetCVar("dnd_mode") >= DND_MODE_SOFTCORE) || !HardcoreSet) return DND_LOGIN_NOTHARDCORE;
	if (!PlayerIsLoggedIn(pnum)) return DND_LOGIN_NOTLOGGED;
	if(!PlayerInGame(pnum)) return DND_LOGIN_NOTINGAME;
	if(GetGameModeState() == GAMESTATE_COUNTDOWN) return DND_LOGIN_INCOUNTDOWN;
	if(!PlayerLoaded[pnum]) return DND_LOGIN_NOCHARINUSE;
	if(char_id < 0 || char_id > DND_MAX_CHARS-1) return DND_LOGIN_CHARNOTINRANGE;
	
	if(char_id == CheckInventory("DnD_CharacterID")) return DND_LOGIN_TRANSFSAMESLOT;
	return DND_LOGIN_CHARTRANSFERRED;
}

Script 1005 (int char_id) NET {
	int pnum = PlayerNumber();
	int result = check_transfer_char(pnum, char_id);
	if ((result == DND_LOGIN_CHARTRANSFERRED) || (result == DND_LOGIN_TRANSFSAMESLOT)) transfer_char(pnum, char_id);
	ACS_NamedExecuteAlways("DnD Login Message", 0, pnum, result, char_id);
}

Script "DND Database Reset On Death" DEATH {
	// remove player saved data if they die once in hardcore, if they are loaded
	int pnum = PlayerNumber(), cid = CheckInventory("DnD_CharacterID");
	if(HardcoreSet && PlayerIsLoggedIn(pnum) && PlayerLoaded[pnum]) {
		if(GetCVar("dnd_mode") == DND_MODE_HARDCORE) {
			// reset variables here
			ResetHardcoreStuff(pnum);
			BeginDBTransaction();
			WipeoutPlayerData(pnum, cid); // it can't get any more wiped than this (also comes here if char is created and not saved).
			EndDBTransaction();
		}
		PlayerLoaded[pnum] = 0;
	}
}

Script "DnD Login Message" (int pnum, int msg_no, int extra) CLIENTSIDE {
	if(ConsolePlayerNumber() != pnum && msg_no != DND_CHARLOADED)
		Terminate;
	switch(msg_no) {
		case DND_LOGIN_NOCHAR:
			Log(s:"\cgLOAD CHAR ERROR: Loading failed due to non-existent character! Character slot number should be between 0 - ", d:DND_MAX_CHARS-1, s:" and must've been declared previously using \"setchar\" command.");
		break;
		case DND_LOGIN_CREATECHAROK:
			Log(s:"CREATE CHAR: Character successfully created on slot \cd", d:extra, s:"\c-.");
		break;
		case DND_LOGIN_CHARINUSE:
			Log(s:"\cgCHAR ERROR: Can't do this while a character is already loaded!");
		break;
		case DND_LOGIN_NOCHARINUSE:
			Log(s:"\cgCHAR ERROR: Can't do this if no characters are loaded!");
		break;
		case DND_LOGIN_NOTINGAME:
			Log(s:"\cgCHAR ERROR: You have to be in game to use this!");
		break;
		case DND_LOGIN_NOTHARDCORE:
			Log(s:"\cgCHAR ERROR: Gamemode is either not set to hardcore or softcore, or server tried to set both!");
		break;
		case DND_LOGIN_INCOUNTDOWN:
			Log(s:"\cgCHAR ERROR: Can't do this during countdown!");
		break;
		case DND_LOGIN_NOTLOGGED:
			Log(s:"\cgCHAR ERROR: You have to be logged in for this to work!");
		break;
		case DND_LOGIN_NOTIME:
			Log(s:"\cgCHAR ERROR: The load time for this map is over!");
		break;
		case DND_LOGIN_CHARNOTINRANGE:
			Log(s:"\cgCHAR ERROR: Character slot number needs to be between 0 - ", d:DND_MAX_CHARS - 1, s:"!");
		break;
		case DND_LOGIN_TRANSFSAMESLOT:
			Log(s:"TRANSFER CHAR: Character will remain at the current slot \cd", d:extra, s:"\c- on character save.");
		break;
		case DND_CHARLOADED:
			Log(n:0, s:" has loaded a character (Level ", d:CheckActorInventory(P_TIDSTART + pnum, "Level"), s:")!");
		break;
		case DND_LOGIN_CHARTRANSFERRED:
			Log(s:"TRANSFER CHAR: Character will be transferred to slot \cd", d:extra, s:"\c- on character save. Previous character on that slot will be deleted!");
		break;
	}
}

Script "DnD Save Player Orb and Stat Data" (int pnum) {
	if(HardcoreSet && PlayerInGame(pnum) && PlayerIsLoggedIn(pnum) && !CheckActorInventory(pnum + P_TIDSTART, "CanLoad")) {
		// if somehow you died...
		if((GetCVar("dnd_mode") == DND_MODE_HARDCORE) && PlayerDied[pnum] && !PlayerLoaded[pnum]) //make sure char is loaded first as well before saving.
			Terminate;
		BeginDBTransaction();
			SavePlayerOrbData(pnum, CheckActorInventory(pnum + P_TIDSTART, "DnD_CharacterID"));
		EndDBTransaction();
	}
}

Script "DnD Save Player Item Data" (int pnum_char, int itemid, int source) {
	SavePlayerItem(pnum_char & 0xFFFF, pnum_char >> 16, itemid, source);
}

Script "DnD Save Player Inventory" (int pnc1, int pnc2) {
	int pn1 = pnc1 & 0xFFFF;
	int pn2 = pnc2 & 0xFFFF;
	if(HardcoreSet && (GetCVar("dnd_mode") >= DND_MODE_SOFTCORE)) {
		BeginDBTransaction();
		if(PlayerIsLoggedIn(pn1)) {
			pnc1 >>= 16;
			SavePlayerInventoryStuff(pn1, pnc1, pn1 + P_TIDSTART, GetPlayerAccountName(pn1), DND_PINVFLAGS_INVENTORY);
		}
		if(PlayerIsLoggedIn(pn2)) {
			pnc2 >>= 16;
			SavePlayerInventoryStuff(pn2, pnc1, pn2 + P_TIDSTART, GetPlayerAccountName(pn2), DND_PINVFLAGS_INVENTORY);
		}
		EndDBTransaction();
	}
}